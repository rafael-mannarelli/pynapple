{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>PYthon Neural Analysis Package.</p> <p>pynapple is a light-weight python library for neurophysiological data analysis. The goal is to offer a versatile set of tools to study typical data in the field, i.e. time series (spike times, behavioral events, etc.) and time intervals (trials, brain states, etc.). It also provides users with generic functions for neuroscience such as tuning curves and cross-correlograms.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://pynapple-org.github.io/pynapple</li> <li>Notebooks and tutorials : https://pynapple-org.github.io/pynapple/generated/gallery/</li> </ul> <p>Note If you are using pynapple, please cite the following biorxiv paper</p>"},{"location":"#community","title":"Community","text":"<p>To ask any questions or get support for using pynapple, please consider joining our slack. Please send an email to thepynapple[at]gmail[dot]com to receive an invitation link.</p>"},{"location":"#new-release","title":"New release","text":"<p>Starting with 0.4, pynapple rely on the numpy array container approach instead of Pandas. Pynapple builtin functions will remain the same except for functions inherited from Pandas. Typically this line of code in <code>pynapple&lt;=0.3.6</code> : <pre><code>meantsd = tsdframe.mean(1)\n</code></pre> is now : <pre><code>meantsd = np.mean(tsdframe, 1)\n</code></pre> in <code>pynapple&gt;=0.4.0</code>. This allows for a better handling of returned objects.</p> <p>Additionaly, it is now possible to define time series objects with more than 2 dimensions with <code>TsdTensor</code>. You can also look at this notebook for a demonstration of numpy compatibilities.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>The best way to install pynapple is with pip within a new conda environment :</p> <pre><code>$ conda create --name pynapple pip python=3.8\n$ conda activate pynapple\n$ pip install pynapple\n</code></pre> <p>or directly from the source code:</p> <pre><code>$ conda create --name pynapple pip python=3.8\n$ conda activate pynapple\n$ # clone the repository\n$ git clone https://github.com/pynapple-org/pynapple.git\n$ cd pynapple\n$ # Install in editable mode with `-e` or, equivalently, `--editable`\n$ pip install -e .\n</code></pre> <p>Note The package is now using a pyproject.toml file for installation and dependencies management. If you want to run the tests, use pip install -e .[dev]</p> <p>This procedure will install all the dependencies including </p> <ul> <li>pandas</li> <li>numpy</li> <li>scipy</li> <li>numba</li> <li>pynwb 2.0</li> <li>tabulate</li> <li>h5py</li> </ul>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>After installation, you can now import the package: </p> <pre><code>$ python\n&gt;&gt;&gt; import pynapple as nap\n</code></pre> <p>You'll find an example of the package below. Click here to download the example dataset. The folder includes a NWB file containing the data.</p> <p><pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nimport pynapple as nap\n\n# LOADING DATA FROM NWB\ndata = nap.load_file(\"A2929-200711.nwb\")\n\nspikes = data[\"units\"]\nhead_direction = data[\"ry\"]\nwake_ep = data[\"position_time_support\"]\n\n# COMPUTING TUNING CURVES\ntuning_curves = nap.compute_1d_tuning_curves(\n    spikes, head_direction, 120, minmax=(0, 2 * np.pi)\n)\n\n\n# PLOT\nplt.figure()\nfor i in spikes:\n    plt.subplot(3, 5, i + 1, projection=\"polar\")\n    plt.plot(tuning_curves[i])\n    plt.xticks([0, np.pi / 2, np.pi, 3 * np.pi / 2])\n\nplt.show()\n</code></pre> Shown below, the final figure from the example code displays the firing rate of 15 neurons as a function of the direction of the head of the animal in the horizontal plane.</p> <p> </p>"},{"location":"#credits","title":"Credits","text":"<p>Special thanks to Francesco P. Battaglia (https://github.com/fpbattaglia) for the development of the original TSToolbox (https://github.com/PeyracheLab/TStoolbox) and neuroseries (https://github.com/NeuroNetMem/neuroseries) packages, the latter constituting the core of pynapple.</p> <p>This package was developped by Guillaume Viejo (https://github.com/gviejo) and other members of the Peyrache Lab.</p> <p>Logo: Sofia Skromne Carrasco, 2021.</p>"},{"location":"AUTHORS/","title":"Credits","text":""},{"location":"AUTHORS/#development-lead","title":"Development Lead","text":"<ul> <li>Guillaume Viejo guillaume.viejo@gmail.com</li> </ul>"},{"location":"AUTHORS/#contributors","title":"Contributors","text":"<ul> <li>Adrien Peyrache</li> <li>Dan Levenstein</li> <li>Sofia Skromne Carrasco</li> <li>Sara Mahallati</li> <li>Gilberto Vite</li> <li>Davide Spalla</li> <li>Luigi Petrucco</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"CONTRIBUTING/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"CONTRIBUTING/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/pynapple-org/pynapple/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in     troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"CONTRIBUTING/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \\\"bug\\\" and \\\"help wanted\\\" is open to whoever wants to implement it.</p>"},{"location":"CONTRIBUTING/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \\\"enhancement\\\" and \\\"help wanted\\\" is open to whoever wants to implement it.</p>"},{"location":"CONTRIBUTING/#write-documentation","title":"Write Documentation","text":"<p>pynapple could always use more documentation, whether as part of the official pynapple docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"CONTRIBUTING/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/pynapple-org/pynapple/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to     implement.</li> <li>Remember that this is a volunteer-driven project, and that     contributions are welcome :)</li> </ul>"},{"location":"CONTRIBUTING/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up [pynapple]{https://github.com/pynapple-org/pynapple} for local development.</p> <ol> <li>Fork the [pynapple]{https://github.com/pynapple-org/pynapple} repo on GitHub.</li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/pynapple.git\n</code></pre> </li> <li> <p>Install your local copy with pip. </p> <pre><code>$ cd pynapple/\n$ pip install -e .\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> </ol> <ol> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"CONTRIBUTING/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.nd.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and     for PyPy.      </li> </ol>"},{"location":"HISTORY/","title":"History","text":"<p>This package somehow started about 20 years ago in Bruce McNaughton's lab. Dave Redish started the TSToolbox package in Matlab.  Another postdoc in the lab, Francesco Battaglia, then made major contributions to the package. Francesco passed it on to Adrien Peyrache and other trainees in Paris and The Netherlands. Around 2016-2017, Luke Sjulson started TSToolbox2, still in Matlab and which includes some important changes.</p> <p>In 2018, Francesco started neuroseries, a Python package built on Pandas. It was quickly adopted in Adrien's lab, especially by Guillaume Viejo, a postdoc in the lab. Gradually, the majority of the lab was using it and new functions were constantly added. In 2021, Guillaume and other trainees in Adrien's lab decided to fork from neuroseries and started pynapple. The core of pynapple is largely built upon neuroseries. Some of the original changes to TSToolbox made by Luke were included in this package, especially the time_support property of all ts/tsd objects.</p>"},{"location":"HISTORY/#051-2024-01-29","title":"0.5.1 (2024-01-29)","text":"<ul> <li>Implementing <code>event_trigger_average</code> for all dimensions.</li> <li>Hiding jitted functions from users.</li> </ul>"},{"location":"HISTORY/#050-2023-12-12","title":"0.5.0 (2023-12-12)","text":"<ul> <li>Removing GUI stack from pynapple. To create a NWB file, users need to install nwbmatic (https://github.com/pynapple-org/nwbmatic)</li> <li>Implementing <code>compute_perievent_continuous</code></li> <li>Implementing <code>convolve</code> for Tsd, TsdFrame and TsdTensor</li> <li>Implementing <code>smooth</code> for fast gaussian smoothing of time series</li> </ul>"},{"location":"HISTORY/#041-2023-10-30","title":"0.4.1 (2023-10-30)","text":"<ul> <li>Implementing <code>get</code> method that return both an interval or the closest timepoint</li> </ul>"},{"location":"HISTORY/#040-2023-10-11","title":"0.4.0 (2023-10-11)","text":"<ul> <li>Implementing the numpy array container approach within pynapple</li> <li>TsdTensor for objects larger than 2 dimensions is now available</li> </ul>"},{"location":"HISTORY/#036-2023-09-11","title":"0.3.6 (2023-09-11)","text":"<ul> <li>Fix issue in NWB reader class with units</li> <li>Implement a linear interpolation function.</li> </ul>"},{"location":"HISTORY/#035-2023-08-08","title":"0.3.5 (2023-08-08)","text":"<ul> <li>NWB reader class</li> <li>NPZ reader class</li> <li>Folder class for navigating a dataset.</li> <li>Cross-correlograms function can take tuple</li> <li>New doc with mkdocs-gallery</li> </ul>"},{"location":"HISTORY/#034-2023-06-29","title":"0.3.4 (2023-06-29)","text":"<ul> <li><code>TsGroup.to_tsd</code> and <code>Tsd.to_tsgroup</code> transformations</li> <li><code>count</code> can take IntervalSet</li> <li>Saving to npz functions for all objects.</li> <li><code>tsd.value_from</code> can take TsdFrame</li> <li>Warning message for deprecating current IO. </li> </ul>"},{"location":"HISTORY/#033-2023-04-17","title":"0.3.3 (2023-04-17)","text":"<ul> <li>Fixed minor bug with tkinter</li> </ul>"},{"location":"HISTORY/#032-2023-04-12","title":"0.3.2 (2023-04-12)","text":"<ul> <li>PyQt removed from the list of dependencies</li> </ul>"},{"location":"HISTORY/#031-2022-12-08","title":"0.3.1 (2022-12-08)","text":"<ul> <li>Core functions rewritten with Numba</li> </ul>"},{"location":"HISTORY/#024-2022-05-02","title":"0.2.4 (2022-05-02)","text":""},{"location":"HISTORY/#023-2022-04-05","title":"0.2.3 (2022-04-05)","text":"<ul> <li>Fixed minor bug when saving DLC in NWB.</li> </ul>"},{"location":"HISTORY/#023-2022-04-05_1","title":"0.2.3 (2022-04-05)","text":"<ul> <li>Alpha release</li> </ul>"},{"location":"HISTORY/#022-2022-04-05","title":"0.2.2 (2022-04-05)","text":"<ul> <li>Beta testing version for public</li> </ul>"},{"location":"HISTORY/#021-2022-02-07","title":"0.2.1 (2022-02-07)","text":"<ul> <li>Beta testing version for Peyrache Lab.</li> </ul>"},{"location":"HISTORY/#020-2022-01-10","title":"0.2.0 (2022-01-10)","text":"<ul> <li>First version for pynapple with main features in core, process and IO.</li> </ul>"},{"location":"HISTORY/#020-pre-release-2022-01-06","title":"0.2.0 Pre-release (2022-01-06)","text":"<ul> <li>Pre-release version for pynapple with main features in core and process.</li> </ul>"},{"location":"HISTORY/#011-2021-10-25","title":"0.1.1 (2021-10-25)","text":"<ul> <li>First release on PyPI.</li> <li>Firt minimal version</li> </ul>"},{"location":"generated/gallery/","title":"Usage","text":""},{"location":"generated/gallery/#examples","title":"Examples","text":"<p>Tutorials and examples for the pynapple package.</p> <p> IO Tutorial </p> <p> Numpy tutorial </p> <p> Calcium Imaging </p> <p> Streaming data from DANDI </p> <p> Core Tutorial </p> <p> Quick start </p> <p> Peyrache et al (2015) Tutorial </p> <p> Zheng et al (2022) Dataset Tutorial </p> <p> Advanced processing </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/draft_pynapple_fastplotlib/","title":"Draft pynapple fastplotlib","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/draft_pynapple_fastplotlib/#fastplotlib","title":"Fastplotlib","text":"<p>Working with calcium data.</p> <p>For the example dataset, we will be working with a recording of a freely-moving mouse imaged with a Miniscope (1-photon imaging). The area recorded for this experiment is the postsubiculum - a region that is known to contain head-direction cells, or cells that fire when the animal's head is pointing in a specific direction.</p> <p>The NWB file for the example is hosted on OSF. We show below how to stream it.</p> <p>See the documentation of Pynapple for instructions on installing the package.</p> <p>This tutorial was made by Sofia Skromne Carrasco and Guillaume Viejo.</p> <p>Warning</p> <p>This tutorial uses seaborn and matplotlib for displaying the figure</p> <p>You can install all with <code>pip install matplotlib seaborn tqdm</code></p> <p>mkdocs_gallery_thumbnail_number = 1</p> <p>Now, import the necessary libraries:</p> <pre><code>import pynapple as nap\nimport numpy as np\nimport fastplotlib as fpl\n#from PyQt6 import QtWidgets\nimport imageio.v3 as iio\nimport sys\n# mkdocs_gallery_thumbnail_path = '../_static/fastplotlib_demo.png'\n\nnwb = nap.load_file(\"/Users/gviejo/pynapple/Mouse32-220101.nwb\")\n\nunits = nwb['units'].getby_category(\"location\")['adn']\n\ntmp = units.to_tsd()\n\ntmp = np.vstack((tmp.index.values, tmp.values)).T \n\nfplot = fpl.Plot()\n\nfplot.add_scatter(tmp)\n\nfplot.graphics[0].cmap = \"jet\" \n\nfplot.graphics[0].cmap.values = tmp[:, 1]\n\nfplot.show()\n\n\nsys.exit()\n</code></pre> <pre><code>#frames = iio.imread(\"/Users/gviejo/pynapple/A0670-221213_filtered.avi\")\n#frames = frames[:,:,:,0]\nframes = np.random.randn(10, 100, 100)\n</code></pre> <pre><code>app = QtWidgets.QApplication([])\n</code></pre> <pre><code>iw = fpl.ImageWidget(frames, cmap=\"gnuplot2\")\n\niw.show()\n\nimageVar2 = iw.widget.grab(iw.widget.rect()) #returns QPixMap\nimageVar2.save(\"../_static/fastplotlib_demo.png\") #again any file name/path and image type possible here\n\niw.close()\n\napp.exec()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.000 seconds)</p> <p> Download Python source code: draft_pynapple_fastplotlib.py</p> <p> Download Jupyter notebook: draft_pynapple_fastplotlib.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:23.908 total execution time for generated_gallery files:</p> <p>+----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_pynapple_quick_start (docs/examples/tutorial_pynapple_quick_start.py) | 00:06.402 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_pynapple_dandi (docs/examples/tutorial_pynapple_dandi.py)                   | 00:04.798 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_HD_dataset (docs/examples/tutorial_HD_dataset.py)                               | 00:02.305 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_pynapple_io (docs/examples/tutorial_pynapple_io.py)                            | 00:02.231 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_pynapple_process (docs/examples/tutorial_pynapple_process.py)             | 00:01.856 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_calcium_imaging (docs/examples/tutorial_calcium_imaging.py)                | 00:01.825 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_pynapple_core (docs/examples/tutorial_pynapple_core.py)                      | 00:01.751 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_pynapple_numpy (docs/examples/tutorial_pynapple_numpy.py)                   | 00:01.500 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_human_dataset (docs/examples/tutorial_human_dataset.py)                      | 00:01.241 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | draft_pynapple_fastplotlib (docs/examples/draft_pynapple_fastplotlib.py)          | 00:00.000 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/tutorial_HD_dataset/","title":"Peyrache et al (2015) Tutorial","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_HD_dataset/#peyrache-et-al-2015-tutorial","title":"Peyrache et al (2015) Tutorial","text":"<p>This tutorial demonstrates how we use Pynapple to generate Figure 4a in the publication. The NWB file for the example is hosted on OSF. We show below how to stream it. The entire dataset can be downloaded here.</p> <p>See the documentation of Pynapple for instructions on installing the package.</p> <p>This tutorial was made by Dhruv Mehrotra and Guillaume Viejo.</p> <p>Warning</p> <p>This tutorial uses seaborn and matplotlib for displaying the figure</p> <p>You can install all with <code>pip install matplotlib seaborn tqdm</code></p> <p>mkdocs_gallery_thumbnail_number = 2</p> <p>Now, import the necessary libraries:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport pynapple as nap\nimport scipy.ndimage\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport requests, math, os\nimport tqdm\n\ncustom_params = {\"axes.spines.right\": False, \"axes.spines.top\": False}\nsns.set_theme(style=\"ticks\", palette=\"colorblind\", font_scale=1.5, rc=custom_params)\n</code></pre>"},{"location":"generated/gallery/tutorial_HD_dataset/#downloading-the-data","title":"Downloading the data","text":"<p>It's a small NWB file.</p> <pre><code>path = \"Mouse32-140822.nwb\"\nif path not in os.listdir(\".\"):\n    r = requests.get(f\"https://osf.io/jb2gd/download\", stream=True)\n    block_size = 1024*1024\n    with open(path, 'wb') as f:\n        for data in tqdm.tqdm(r.iter_content(block_size), unit='MB', unit_scale=True,\n            total=math.ceil(int(r.headers.get('content-length', 0))//block_size)):\n            f.write(data)\n</code></pre>"},{"location":"generated/gallery/tutorial_HD_dataset/#parsing-the-data","title":"Parsing the data","text":"<p>The first step is to load the data and other relevant variables of interest</p> <pre><code>data = nap.load_file(path)  # Load the NWB file for this dataset\n</code></pre> <p>What does this look like ?</p> <pre><code>print(data)\n</code></pre> <p>Out:</p> <pre><code>Mouse32-140822\n\u250d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2511\n\u2502 Keys                  \u2502 Type        \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 units                 \u2502 TsGroup     \u2502\n\u2502 sws                   \u2502 IntervalSet \u2502\n\u2502 rem                   \u2502 IntervalSet \u2502\n\u2502 position_time_support \u2502 IntervalSet \u2502\n\u2502 epochs                \u2502 IntervalSet \u2502\n\u2502 ry                    \u2502 Tsd         \u2502\n\u2515\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2519\n</code></pre>"},{"location":"generated/gallery/tutorial_HD_dataset/#head-direction-tuning-curves","title":"Head-Direction Tuning Curves","text":"<p>To plot Head-Direction Tuning curves, we need the spike timings and the orientation of the animal. These quantities are stored in the variables 'units' and 'ry'.</p> <pre><code>spikes = data[\"units\"]  # Get spike timings\nepochs = data[\"epochs\"]  # Get the behavioural epochs (in this case, sleep and wakefulness)\nangle = data[\"ry\"]  # Get the tracked orientation of the animal\n</code></pre> <p>What does this look like ?</p> <pre><code>print(spikes)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate  location      group\n-------  ------  ----------  -------\n      0    2.97  thalamus          1\n      1    2.43  thalamus          1\n      2    5.93  thalamus          1\n      3    5.04  thalamus          1\n      4    0.3   adn               2\n      5    0.87  adn               2\n      6    0.36  adn               2\n      7   10.52  adn               2\n      8    2.62  adn               2\n      9    2.56  adn               2\n     10    7.07  adn               2\n     11    0.38  adn               2\n     12    1.58  adn               2\n     13    4.88  adn               2\n     14    8.47  adn               2\n     15    0.24  adn               3\n     16    0.27  adn               3\n     17    6.13  adn               3\n     18   11.01  adn               3\n     19    5.23  adn               3\n     20    6.2   adn               3\n     21    2.85  adn               3\n     22    9.71  adn               3\n     23    1.71  adn               3\n     24   19.65  adn               3\n     25    3.88  adn               3\n     26    4.02  adn               3\n     27    0.69  adn               3\n     28    1.78  adn               4\n     29    4.23  adn               4\n     30    2.15  adn               4\n     31    0.59  adn               4\n     32    1.13  adn               4\n     33    5.26  adn               4\n     34    1.57  adn               4\n     35    4.75  thalamus          5\n     36    1.31  thalamus          5\n     37    0.77  thalamus          5\n     38    2.02  thalamus          5\n     39   27.21  thalamus          5\n     40    7.28  thalamus          5\n     41    0.88  thalamus          5\n     42    1.02  thalamus          5\n     43    6.85  thalamus          6\n     44    0.94  thalamus          6\n     45    0.56  thalamus          6\n     46    1.15  thalamus          6\n     47    0.46  thalamus          6\n     48    0.19  thalamus          7\n</code></pre> <p>Here, rate is the mean firing rate of the unit. Location indicates the brain region the unit was recorded from, and group refers to the shank number on which the cell was located.</p> <p>This dataset contains units recorded from the anterior thalamus. Head-direction (HD) cells are found in the anterodorsal nucleus of the thalamus (henceforth referred to as ADn). Units were also recorded from nearby thalamic nuclei in this animal. For the purposes of our tutorial, we are interested in the units recorded in ADn. We can restrict ourselves to analysis of these units rather easily, using Pynapple.</p> <pre><code>spikes_adn = spikes.getby_category(\"location\")[\"adn\"]  # Select only those units that are in ADn\n</code></pre> <p>What does this look like ?</p> <pre><code>print(spikes_adn)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate  location      group\n-------  ------  ----------  -------\n      4    0.3   adn               2\n      5    0.87  adn               2\n      6    0.36  adn               2\n      7   10.52  adn               2\n      8    2.62  adn               2\n      9    2.56  adn               2\n     10    7.07  adn               2\n     11    0.38  adn               2\n     12    1.58  adn               2\n     13    4.88  adn               2\n     14    8.47  adn               2\n     15    0.24  adn               3\n     16    0.27  adn               3\n     17    6.13  adn               3\n     18   11.01  adn               3\n     19    5.23  adn               3\n     20    6.2   adn               3\n     21    2.85  adn               3\n     22    9.71  adn               3\n     23    1.71  adn               3\n     24   19.65  adn               3\n     25    3.88  adn               3\n     26    4.02  adn               3\n     27    0.69  adn               3\n     28    1.78  adn               4\n     29    4.23  adn               4\n     30    2.15  adn               4\n     31    0.59  adn               4\n     32    1.13  adn               4\n     33    5.26  adn               4\n     34    1.57  adn               4\n</code></pre> <p>Let's compute some head-direction tuning curves. To do this in Pynapple, all you need is a single line of code!</p> <p>Plot firing rate of ADn units as a function of heading direction, i.e. a head-direction tuning curve</p> <pre><code>tuning_curves = nap.compute_1d_tuning_curves(\n    group=spikes_adn, \n    feature=angle, \n    nb_bins=61, \n    ep = epochs['wake'],\n    minmax=(0, 2 * np.pi)\n    )\n</code></pre> <p>What does this look like ?</p> <pre><code>print(tuning_curves)\n</code></pre> <p>Out:</p> <pre><code>                4         5         6   ...        32         33        34\n0.051502  0.255172  0.127586  0.170115  ...  0.467815   5.273551  1.786203\n0.154505  0.300635  0.000000  0.187897  ...  0.375794   8.380200  1.954127\n0.257508  0.189885  0.094943  0.094943  ...  0.158238  10.506971  3.892643\n0.360511  0.498062  0.052428  0.078641  ...  0.235924  12.556397  5.321396\n0.463514  0.362941  0.111674  0.139593  ...  0.307104  15.271458  8.431408\n...            ...       ...       ...  ...       ...        ...       ...\n5.819672  0.063460  0.158650  0.190380  ...  0.253841   0.285571  0.507681\n5.922675  0.024772  0.123861  0.123861  ...  0.396357   0.767941  0.272495\n6.025678  0.000000  0.112276  0.028069  ...  0.364896   0.954343  0.196482\n6.128681  0.000000  0.138009  0.165611  ...  0.331222   1.021266  0.441629\n6.231684  0.067699  0.101548  0.135397  ...  0.541589   2.234055  0.609288\n\n[61 rows x 31 columns]\n</code></pre> <p>Each row indicates an angular bin (in radians), and each column corresponds to a single unit. Let's compute the preferred angle quickly as follows:</p> <pre><code>pref_ang = tuning_curves.idxmax()\n</code></pre> <p>For easier visualization, we will colour our plots according to the preferred angle of the cell. To do so, we will normalize the range of angles we have, over a colourmap.</p> <pre><code>norm = plt.Normalize()  # Normalizes data into the range [0,1]\ncolor = plt.cm.hsv(norm([i / (2 * np.pi) for i in pref_ang.values]))  # Assigns a colour in the HSV colourmap for each value of preferred angle\ncolor = pd.DataFrame(index=pref_ang.index, data = color, columns = ['r', 'g', 'b', 'a'])\n</code></pre> <p>To make the tuning curves look nice, we will smooth them before plotting, using this custom function:</p> <pre><code>from scipy.ndimage import gaussian_filter1d\ndef smoothAngularTuningCurves(tuning_curves, sigma=2):\n\n    tmp = np.concatenate((tuning_curves.values, tuning_curves.values, tuning_curves.values))\n    tmp = gaussian_filter1d(tmp, sigma=sigma, axis=0)\n\n    return pd.DataFrame(index = tuning_curves.index,\n        data = tmp[tuning_curves.shape[0]:tuning_curves.shape[0]*2], \n        columns = tuning_curves.columns\n        )\n</code></pre> <p>Therefore, we have:</p> <pre><code>smoothcurves = smoothAngularTuningCurves(tuning_curves, sigma=3)\n</code></pre> <p>What does this look like? Let's plot the tuning curves!</p> <pre><code>plt.figure(figsize=(12, 9))\nfor i, n in enumerate(pref_ang.sort_values().index.values):\n    plt.subplot(8, 4, i + 1, projection='polar')  # Plot the curves in 8 rows and 4 columns\n    plt.plot(\n        smoothcurves[n], color=color.loc[n]\n    )  # Colour of the curves determined by preferred angle    \n    plt.xlabel(\"Angle (rad)\")  # Angle in radian, on the X-axis\n    plt.ylabel(\"Firing Rate (Hz)\")  # Firing rate in Hz, on the Y-axis\n    plt.xticks([])\nplt.show()\n</code></pre> <p></p> <p>Awesome!</p>"},{"location":"generated/gallery/tutorial_HD_dataset/#decoding","title":"Decoding","text":"<p>Now that we have HD tuning curves, we can go one step further. Using only the population activity of ADn units, we can decode the direction the animal is looking in. We will then compare this to the real head direction of the animal, and discover that population activity in the ADn indeed codes for HD.</p> <p>To decode the population activity, we will be using a Bayesian Decoder as implemented in Pynapple. Just a single line of code!</p> <pre><code>decoded, proba_feature = nap.decode_1d(\n    tuning_curves=tuning_curves,\n    group=spikes_adn,\n    ep=epochs[\"wake\"],\n    bin_size=0.1,  # second\n    feature=angle,\n)\n</code></pre> <p>What does this look like ?</p> <pre><code>print(decoded)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n---------------  --------\n8812.35          0.772523\n8812.45          0.66952\n8812.55          0.463514\n8812.65          0.66952\n8812.75          0.66952\n...\n10770.850000007  5.71667\n10770.950000007  5.92267\n10771.050000007  5.92267\n10771.150000007  5.92267\n10771.250000007  5.92267\ndtype: float64, shape: (19590,)\n</code></pre> <p>The variable 'decoded' indicates the most probable angle in which the animal was looking. There is another variable, 'proba_feature' that denotes the probability of a given angular bin at a given time point. We can look at it below:</p> <pre><code>print(proba_feature.as_dataframe())\n</code></pre> <p>Out:</p> <pre><code>              0.051502  0.154505  ...      6.128681      6.231684\n8812.35   2.199077e-06  0.000223  ...  1.483408e-14  2.212419e-11\n8812.45   8.561129e-08  0.000013  ...  1.628816e-16  2.464448e-13\n8812.55   4.168300e-04  0.022715  ...  2.698994e-09  4.014847e-07\n8812.65   1.082000e-05  0.000156  ...  6.175847e-13  4.426551e-10\n8812.75   4.128198e-05  0.001369  ...  5.077673e-12  5.290852e-09\n...                ...       ...  ...           ...           ...\n10770.85  6.695624e-05  0.000003  ...  3.310523e-02  4.842028e-03\n10770.95  2.924858e-04  0.000005  ...  5.668237e-02  8.429181e-03\n10771.05  1.093979e-03  0.000115  ...  6.114471e-02  2.121581e-02\n10771.15  5.537065e-03  0.001235  ...  1.547459e-01  1.115693e-01\n10771.25  5.969857e-04  0.000058  ...  6.686085e-02  1.501718e-02\n\n[19590 rows x 61 columns]\n</code></pre> <p>Each row of this pandas DataFrame is a time bin, and each column is an angular bin. The sum of all values in a row add up to 1.</p> <p>Now, let's plot the raster plot for a given period of time, and overlay the actual and decoded HD on the population activity.</p> <pre><code>ep = nap.IntervalSet(\n    start=10717, end=10730\n)  # Select an arbitrary interval for plotting\n\nplt.figure()\nplt.rc(\"font\", size=12)\nfor i, n in enumerate(spikes_adn.keys()):\n    plt.plot(\n        spikes[n].restrict(ep).fillna(pref_ang[n]), \"|\", color=color.loc[n]\n    )  # raster plot for each cell\nplt.plot(\n    decoded.restrict(ep), \"--\", color=\"grey\", linewidth=2, label=\"decoded HD\"\n)  # decoded HD\nplt.legend(loc=\"upper left\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;matplotlib.legend.Legend object at 0x7fb324ee0ca0&gt;\n</code></pre> <p>From this plot, we can see that the decoder is able to estimate the head-direction based on the population activity in ADn. Amazing!</p> <p>What does the probability distribution in this example event look like? Ideally, the bins with the highest probability will correspond to the bins having the most spikes. Let's plot the probability matrix to visualize this.</p> <pre><code>smoothed = scipy.ndimage.gaussian_filter(\n    proba_feature, 1\n)  # Smoothening the probability distribution\n\n# Create a DataFrame with the smoothed distribution\np_feature = pd.DataFrame(\n    index=proba_feature.index.values,\n    columns=proba_feature.columns.values,\n    data=smoothed,\n)\np_feature = nap.TsdFrame(p_feature)  # Make it a Pynapple TsdFrame\n\nplt.figure()\nplt.plot(\n    angle.restrict(ep), \"w\", linewidth=2, label=\"actual HD\", zorder=1\n)  # Actual HD, in white\nplt.plot(\n    decoded.restrict(ep), \"--\", color=\"grey\", linewidth=2, label=\"decoded HD\", zorder=1\n)  # Decoded HD, in grey\n\n# Plot the smoothed probability distribution\nplt.imshow(\n    np.transpose(p_feature.restrict(ep).values),\n    aspect=\"auto\",\n    interpolation=\"bilinear\",\n    extent=[ep[\"start\"].values[0], ep[\"end\"].values[0], 0, 2 * np.pi],\n    origin=\"lower\",\n    cmap=\"viridis\",\n)\n\nplt.xlabel(\"Time (s)\")  # X-axis is time in seconds\nplt.ylabel(\"Angle (rad)\")  # Y-axis is the angle in radian\nplt.colorbar(label=\"probability\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;matplotlib.colorbar.Colorbar object at 0x7fb324ec0520&gt;\n</code></pre> <p>From this probability distribution, we observe that the decoded HD very closely matches the actual HD. Therefore, the population activity in ADn is a reliable estimate of the heading direction of the animal.</p> <p>I hope this tutorial was helpful. If you have any questions, comments or suggestions, please feel free to reach out to the Pynapple Team!</p> <p>Total running time of the script: ( 0 minutes  2.305 seconds)</p> <p> Download Python source code: tutorial_HD_dataset.py</p> <p> Download Jupyter notebook: tutorial_HD_dataset.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_calcium_imaging/","title":"Calcium Imaging","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_calcium_imaging/#calcium-imaging","title":"Calcium Imaging","text":"<p>Working with calcium data.</p> <p>For the example dataset, we will be working with a recording of a freely-moving mouse imaged with a Miniscope (1-photon imaging). The area recorded for this experiment is the postsubiculum - a region that is known to contain head-direction cells, or cells that fire when the animal's head is pointing in a specific direction.</p> <p>The NWB file for the example is hosted on OSF. We show below how to stream it.</p> <p>See the documentation of Pynapple for instructions on installing the package.</p> <p>This tutorial was made by Sofia Skromne Carrasco and Guillaume Viejo.</p> <p>Warning</p> <p>This tutorial uses seaborn and matplotlib for displaying the figure</p> <p>You can install all with <code>pip install matplotlib seaborn tqdm</code></p> <p>mkdocs_gallery_thumbnail_number = 1</p> <p>Now, import the necessary libraries:</p> <pre><code>import numpy as pd\nimport pynapple as nap\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sys, os\nimport requests, math\nimport tqdm\n\ncustom_params = {\"axes.spines.right\": False, \"axes.spines.top\": False}\nsns.set_theme(style=\"ticks\", palette=\"colorblind\", font_scale=1.5, rc=custom_params)\n</code></pre>"},{"location":"generated/gallery/tutorial_calcium_imaging/#downloading-the-data","title":"Downloading the data","text":"<p>First things first: Let's find our file</p> <pre><code>path = \"A0670-221213.nwb\"\nif path not in os.listdir(\".\"):\n  r = requests.get(f\"https://osf.io/sbnaw/download\", stream=True)\n  block_size = 1024*1024\n  with open(path, 'wb') as f:\n    for data in tqdm.tqdm(r.iter_content(block_size), unit='MB', unit_scale=True,\n      total=math.ceil(int(r.headers.get('content-length', 0))//block_size)):\n      f.write(data)\n</code></pre>"},{"location":"generated/gallery/tutorial_calcium_imaging/#parsing-the-data","title":"Parsing the data","text":"<p>Now that we have the file, let's load the data</p> <pre><code>data = nap.load_file(path)\nprint(data)\n</code></pre> <p>Out:</p> <pre><code>A0670-221213\n\u250d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2511\n\u2502 Keys                  \u2502 Type        \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 position_time_support \u2502 IntervalSet \u2502\n\u2502 RoiResponseSeries     \u2502 TsdFrame    \u2502\n\u2502 z                     \u2502 Tsd         \u2502\n\u2502 y                     \u2502 Tsd         \u2502\n\u2502 x                     \u2502 Tsd         \u2502\n\u2502 rz                    \u2502 Tsd         \u2502\n\u2502 ry                    \u2502 Tsd         \u2502\n\u2502 rx                    \u2502 Tsd         \u2502\n\u2515\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2519\n</code></pre> <p>Let's save the RoiResponseSeries as a variable called 'transients' and print it</p> <pre><code>transients = data['RoiResponseSeries']\nprint(transients)\n</code></pre> <p>Out:</p> <pre><code>Time (s)          0        1         2         3         4  ...\n----------  -------  -------  --------  --------  --------  -----\n3.1187      0.27546  0.79973  0.16383   0.20118   0.029255  ...\n3.15225     0.26665  0.86751  0.15879   0.23682   0.027189  ...\n3.18585     0.25796  0.89419  0.15352   0.25074   0.036514  ...\n3.2194      0.24943  0.89513  0.14812   0.25215   0.056273  ...\n3.253       0.24111  0.88023  0.14898   0.24651   0.070954  ...\n...\n1203.4566   0.19654  0.17056  0.11461   0.085079  1.62      ...\n1203.4902   0.19052  0.16645  0.11096   0.080197  1.8811    ...\n1203.52375  0.18449  0.16105  0.10717   0.075416  2.0599    ...\n1203.55735  0.17851  0.15494  0.10331   0.070814  2.2176    ...\n1203.5909   0.17264  0.14851  0.099416  0.066429  2.311     ...\ndtype: float64, shape: (35757, 65)\n</code></pre>"},{"location":"generated/gallery/tutorial_calcium_imaging/#plotting-the-activity-of-one-neuron","title":"Plotting the activity of one neuron","text":"<p>Our transients are saved as a (35757, 65) TsdFrame. Looking at the printed object, you can see that we have 35757 data points for each of our 65 regions of interest. We want to see which of these are head-direction cells, so we need to plot a tuning curve of fluorescence vs head-direction of the animal.</p> <pre><code>plt.figure(figsize=(6, 2))\nplt.plot(transients[0:2000,0], linewidth=5)\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Fluorescence\")\nplt.show()\n</code></pre> <p></p> <p>Here we extract the head-direction as a variable called angle</p> <pre><code>angle = data['ry']\nprint(angle)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  -------\n3.0994      2.58326\n3.10775     2.5864\n3.11605     2.5905\n3.1244      2.59191\n3.13275     2.59263\n...\n1206.18945  3.69804\n1206.1978   3.6728\n1206.20615  3.65452\n1206.21445  3.61199\n1206.2228   3.5495\ndtype: float64, shape: (144382,)\n</code></pre> <p>As you can see, we have a longer recording for our tracking of the animal's head than we do for our calcium imaging - something to keep in mind.</p> <pre><code>print(transients.time_support)\nprint(angle.time_support)\n</code></pre> <p>Out:</p> <pre><code>    start        end\n0  3.1187  1203.5909\n    start        end\n0  3.0994  1206.2228\n</code></pre>"},{"location":"generated/gallery/tutorial_calcium_imaging/#calcium-tuning-curves","title":"Calcium tuning curves","text":"<p>Here we compute the tuning curves of all the neurons</p> <pre><code>tcurves = nap.compute_1d_tuning_curves_continuous(transients, angle, nb_bins = 120)\n\nprint(tcurves)\n</code></pre> <p>Out:</p> <pre><code>                0         1         2   ...        62        63        64\n0.026195  0.395699  0.055843  0.150304  ...  0.086804  0.090393  0.090931\n0.078555  0.279695  0.052430  0.153925  ...  0.098154  0.112558  0.101200\n0.130915  0.398603  0.044422  0.201113  ...  0.089716  0.092577  0.127856\n0.183274  0.379213  0.043964  0.149085  ...  0.087498  0.071661  0.144850\n0.235634  0.266577  0.038920  0.175439  ...  0.072857  0.070615  0.177883\n...            ...       ...       ...  ...       ...       ...       ...\n6.047557  0.390266  0.072893  0.174015  ...  0.115768  0.108395  0.080172\n6.099916  0.266773  0.065594  0.118181  ...  0.110677  0.103724  0.081672\n6.152276  0.268866  0.060269  0.120475  ...  0.121157  0.099209  0.083993\n6.204636  0.281763  0.064460  0.131925  ...  0.099411  0.098601  0.088175\n6.256995  0.293497  0.048092  0.117291  ...  0.089862  0.084487  0.100030\n\n[120 rows x 65 columns]\n</code></pre> <p>We now have a DataFrame, where our index is the angle of the animal's head in radians, and each column represents the tuning curve of each region of interest. We can plot one neuron.</p> <pre><code>plt.figure()\nplt.plot(tcurves[4])\nplt.xlabel(\"Angle\")\nplt.ylabel(\"Fluorescence\")\nplt.show()\n</code></pre> <p></p> <p>It looks like this could be a head-direction cell. One important property of head-directions cells however, is that their firing with respect to head-direction is stable. To check for their stability, we can split our recording in two and compute a tuning curve for each half of the recording.</p> <p>We start by finding the midpoint of the recording, using the function <code>get_intervals_center</code>. Using this, then create one new IntervalSet with two rows, one for each half of the recording.</p> <pre><code>center = transients.time_support.get_intervals_center()\n\nhalves = nap.IntervalSet(\n    start = [transients.time_support.start[0], center.t[0]],\n    end = [center.t[0], transients.time_support.end[0]]\n    )\n</code></pre> <p>Out:</p> <pre><code>/mnt/home/gviejo/pynapple/docs/examples/tutorial_calcium_imaging.py:118: UserWarning: Some starts and ends are equal. Removing 1 microsecond!\n  halves = nap.IntervalSet(\n</code></pre> <p>Now we can compute the tuning curves for each half of the recording and plot the tuning curves for the fifth region of interest. </p> <pre><code>half1 = nap.compute_1d_tuning_curves_continuous(transients, angle, nb_bins = 120, ep = halves.loc[[0]])\nhalf2 = nap.compute_1d_tuning_curves_continuous(transients, angle, nb_bins = 120, ep = halves.loc[[1]])\n\nplt.figure(figsize=(12, 5))\nplt.subplot(1,2,1)\nplt.plot(half1[4])\nplt.title(\"First half\")\nplt.xlabel(\"Angle\")\nplt.ylabel(\"Fluorescence\")\nplt.subplot(1,2,2)\nplt.plot(half2[4])\nplt.title(\"Second half\")\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  1.825 seconds)</p> <p> Download Python source code: tutorial_calcium_imaging.py</p> <p> Download Jupyter notebook: tutorial_calcium_imaging.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_human_dataset/","title":"Zheng et al (2022) Dataset Tutorial","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_human_dataset/#zheng-et-al-2022-dataset-tutorial","title":"Zheng et al (2022) Dataset Tutorial","text":"<p>This tutorial demonstrates how we use Pynapple on various publicly available datasets in systems neuroscience to streamline analysis. In this tutorial, we will examine the dataset from Zheng et al (2022), which was used to generate Figure 4c in the publication.</p> <p>The NWB file for the example used here is provided in this repository. The entire dataset can be downloaded here.</p> <p>See the documentation of Pynapple for instructions on installing the package.</p> <p>This tutorial was made by Dhruv Mehrotra.</p> <p>First, import the necessary libraries:</p> <p>Warning</p> <p>This tutorial uses seaborn and matplotlib for displaying the figure as well as the dandi package</p> <p>You can install all with <code>pip install matplotlib seaborn dandi dandischema</code></p> <p>Now, import the necessary libraries:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport pynapple as nap\nimport seaborn as sns\n</code></pre>"},{"location":"generated/gallery/tutorial_human_dataset/#stream-the-data-from-dandi","title":"Stream the data from DANDI","text":"<pre><code>from pynwb import NWBHDF5IO\n\nfrom dandi.dandiapi import DandiAPIClient\nimport fsspec\nfrom fsspec.implementations.cached import CachingFileSystem\nimport h5py\n\n# Enter the session ID and path to the file\ndandiset_id, filepath = (\"000207\", \"sub-4/sub-4_ses-4_ecephys.nwb\")\n\nwith DandiAPIClient() as client:\n    asset = client.get_dandiset(dandiset_id, \"draft\").get_asset_by_path(filepath)\n    s3_url = asset.get_content_url(follow_redirects=1, strip_query=True)\n\n# first, create a virtual filesystem based on the http protocol\nfs = fsspec.filesystem(\"http\")\n\n# create a cache to save downloaded data to disk (optional)\nfs = CachingFileSystem(\n    fs=fs,\n    cache_storage=\"nwb-cache\",  # Local folder for the cache\n)\n\n# next, open the file\nfile = h5py.File(fs.open(s3_url, \"rb\"))\nio = NWBHDF5IO(file=file, load_namespaces=True)\n</code></pre> <p>Out:</p> <pre><code>/mnt/home/gviejo/mambaforge/envs/pynapple/lib/python3.10/site-packages/hdmf/spec/namespace.py:531: UserWarning: Ignoring cached namespace 'hdmf-common' version 1.5.0 because version 1.7.0 is already loaded.\n  warn(\"Ignoring cached namespace '%s' version %s because version %s is already loaded.\"\n/mnt/home/gviejo/mambaforge/envs/pynapple/lib/python3.10/site-packages/hdmf/spec/namespace.py:531: UserWarning: Ignoring cached namespace 'core' version 2.5.0 because version 2.6.0-alpha is already loaded.\n  warn(\"Ignoring cached namespace '%s' version %s because version %s is already loaded.\"\n/mnt/home/gviejo/mambaforge/envs/pynapple/lib/python3.10/site-packages/hdmf/spec/namespace.py:531: UserWarning: Ignoring cached namespace 'hdmf-experimental' version 0.1.0 because version 0.4.0 is already loaded.\n  warn(\"Ignoring cached namespace '%s' version %s because version %s is already loaded.\"\n</code></pre>"},{"location":"generated/gallery/tutorial_human_dataset/#parsing-the-data","title":"Parsing the data","text":"<p>The first step is to load the data from the Neurodata Without Borders (NWB) file. This is done as follows:</p> <pre><code>custom_params = {\"axes.spines.right\": False, \"axes.spines.top\": False}\nsns.set_theme(style=\"ticks\", palette=\"colorblind\", font_scale=1.5, rc=custom_params)\n\ndata = nap.NWBFile(io.read())  # Load the NWB file for this dataset\n\n# What does this look like?\nprint(data)\n</code></pre> <p>Out:</p> <pre><code>4\n\u250d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2511\n\u2502 Keys                     \u2502 Type        \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 units                    \u2502 TsGroup     \u2502\n\u2502 timediscrimination_table \u2502 IntervalSet \u2502\n\u2502 recognition_table        \u2502 IntervalSet \u2502\n\u2502 encoding_table           \u2502 IntervalSet \u2502\n\u2502 experiment_ids           \u2502 Tsd         \u2502\n\u2502 events                   \u2502 Tsd         \u2502\n\u2515\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2519\n</code></pre> <p>Get spike timings</p> <pre><code>spikes = data[\"units\"]\n</code></pre> <p>What does this look like?</p> <pre><code>print(spikes)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate      x       y       z    imp  location           filtering    group_name      origChannel\n-------  ------  -----  ------  ------  -----  -----------------  -----------  ------------  -------------\n      0    7     26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  139\n      1    7.24  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  139\n      2    6.09  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  140\n      3    6.92  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  142\n      4    0.4   26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  142\n      5    0.46  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  143\n      6    1.81  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  143\n      7    4.79  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  144\n      8    1.31  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  154\n      9    0.62  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  156\n     10    1.51  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  157\n     11    0.77  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  157\n     12    1.46  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  158\n     13    0.4   21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  158\n     14    6.27  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  158\n     15    1.15  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  159\n     16    2.15  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  159\n     17    0.63  21.36   -0.59  -21.55    nan  amygdala_right     300-3000Hz   micros                  159\n     18    2.88  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  184\n     19    0.35  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  185\n     20    1.75  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  185\n     21    0.58  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  186\n     22    2.13  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  186\n     23    1.51  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  187\n     24    0.27  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  188\n     25    7.35  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  188\n     26    0.37  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  188\n     27    1.89  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  188\n     28    1.13  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  189\n     29    0.6   26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  190\n     30    0.18  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  190\n     31    2.33  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  191\n     32    0.31  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  191\n     33    0.69  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  191\n     34    0.66  26.63  -15.83  -16.49    nan  hippocampus_right  300-3000Hz   micros                  192\n</code></pre> <p>This TsGroup has, among other information, the mean firing rate of the unit, the X, Y and Z coordinates, the brain region the unit was recorded from, and the channel number on which the unit was located.</p> <p>Next, let's get the encoding table of all stimulus times, as shown below:</p> <pre><code>encoding_table = data[\"encoding_table\"]\n\n# What does this look like?\nprint(encoding_table)\n</code></pre> <p>Out:</p> <pre><code>/mnt/home/gviejo/pynapple/pynapple/io/interface_nwb.py:449: UserWarning: Too many metadata. Returning pandas.DataFrame, not IntervalSet\n  data = self._f_eval[self.data[key][\"type\"]](obj)\n    start_time   stop_time  fixcross_time  ...  boundary3_time  stimCategory  Clip_name\nid                                         ...                                         \n0     1.068463    9.101330       0.056555  ...             NaN             0  NB_24.mp4\n1    10.182342   18.114558       9.116686  ...             NaN             1  SB_23.mp4\n2    19.071072   27.137388      18.130498  ...             NaN             2  HB_20.mp4\n3    28.160476   36.390234      27.154926  ...             NaN             0  NB_26.mp4\n4    37.470909   44.584497      36.409347  ...             NaN             0  NB_25.mp4\n..         ...         ...            ...  ...             ...           ...        ...\n85  892.755233  900.921092     891.747973  ...             NaN             1   SB_2.mp4\n86  901.906850  910.171979     900.940121  ...             NaN             2  HB_27.mp4\n87  911.138396  919.335950     910.190938  ...      917.067151             2  HB_10.mp4\n88  920.363950  928.329845     919.354902  ...      924.924117             1  SB_27.mp4\n89  930.639635  939.073029     929.718098  ...             NaN             1  SB_25.mp4\n\n[90 rows x 9 columns]\n</code></pre> <p>This table has, among other things, the scene boundary times for which we will plot the peri-event time histogram (PETH).</p> <p>There are 3 types of scene boundaries in this data. For the purposes of demonstration, we will use only the \"No boundary\" (NB) and the \"Hard boundary\" (HB conditions). The encoding table has a stimCategory field, which tells us the type of boundary corresponding to a given trial.</p> <pre><code>stimCategory = np.array(\n    encoding_table.stimCategory\n)  # Get the scene boundary type for all trials\n\n# What does this look like?\nprint(stimCategory)\n</code></pre> <p>Out:</p> <pre><code>[0 1 2 0 0 0 1 0 2 1 2 0 2 0 1 1 1 1 0 0 2 0 0 2 0 1 0 2 0 0 2 0 0 0 0 2 2\n 2 0 0 1 1 1 1 0 2 1 1 0 2 1 0 2 2 2 0 1 0 1 1 2 2 0 2 2 2 1 1 2 1 0 2 2 1\n 0 1 2 0 2 2 1 1 1 1 2 1 2 2 1 1]\n</code></pre> <p>Trials marked 0 correspond to NB, while trials marked 2 correspond to HB. Let's extract the trial numbers for NB and HB trials, as shown below:</p> <pre><code>indxNB = np.where(stimCategory == 0)  # NB trial indices\nindxHB = np.where(stimCategory == 2)  # HB trial indices\n</code></pre> <p>The encoding table also has 3 types of boundary times. For the purposes of our demonstration, we will focus on boundary1 times, and extract them as shown below:</p> <pre><code>boundary1_time = np.array(encoding_table.boundary1_time)  # Get timings of Boundary1\n\n# What does this look like?\nprint(boundary1_time)\n</code></pre> <p>Out:</p> <pre><code>[  5.06846275  12.88060075  23.071072    32.1604755   41.470909\n  49.5747065   56.07442325  72.803867    82.1299925   92.77667275\n  99.9925845  109.0787315  118.0778575  133.12435825 140.94827125\n 147.8236585  160.726736   170.441769   183.29262575 191.11327175\n 199.63382425 208.5142425  217.6186295  232.62687825 241.7270365\n 250.58327775 259.5545145  268.6661045  278.026902   287.04517875\n 301.2426685  310.21093375 319.1822215  328.13037175 337.16751875\n 363.737004   372.785663   381.86749625 391.2704085  400.5077995\n 407.28660475 416.0272855  431.792285   441.75272875 448.88401175\n 456.97766275 463.88864475 472.13035175 490.53584775 499.7064625\n 507.6917495  518.78793775 528.140675   537.1412335  552.5116415\n 562.4287995  569.44012625 580.99649325 591.974217   597.74463025\n 608.3638655  624.44389125 633.4175285  642.3969695  651.776966\n 660.699774   676.9439885  681.3602465  692.799878   699.53861175\n 711.341688   720.4819275  729.43782175 772.99961425 780.19490625\n 788.1175045  798.34264525 807.54519    817.25781375 835.1736475\n 842.54760125 852.294991   861.40924725 868.63873425 887.93252325\n 898.284193   905.9068505  915.1383965  921.90619325 932.99710575]\n</code></pre> <p>This contains the timings of all boundaries in this block of trials. Note that we also have the type of boundary for each trial. Let's store the NB and HB boundary timings in separate variables, as Pynapple Ts objects:</p> <pre><code>NB = nap.Ts(boundary1_time[indxNB])  # NB timings\nHB = nap.Ts(boundary1_time[indxHB])  # HB timings\n</code></pre>"},{"location":"generated/gallery/tutorial_human_dataset/#peri-event-time-histogram-peth","title":"Peri-Event Time Histogram (PETH)","text":"<p>A PETH is a plot where we align a variable of interest (for example, spikes) to an external event (in this case, to boundary times). This visualization helps us infer relationships between the two.</p> <p>For our demonstration, we will align the spikes of the first unit, which is located in the hippocampus, to the times of NB and HB. You can do a quick check to verify that the first unit is indeed located in the hippocampus, we leave it to you.</p> <p>With Pynapple, PETHs can be computed with a single line of code!</p> <pre><code>NB_peth = nap.compute_perievent(\n    spikes[0], NB, minmax=(-0.5, 1)\n)  # Compute PETH of unit aligned to NB, for -0.5 to 1s windows\nHB_peth = nap.compute_perievent(\n    spikes[0], HB, minmax=(-0.5, 1)\n)  # Compute PETH of unit aligned to HB, for -0.5 to 1s windows\n</code></pre> <p>Let's plot the PETH</p> <pre><code>plt.figure(figsize =(15,8))\nplt.subplot(211)  # Plot the figures in 2 rows\nfor i, n in enumerate(NB_peth):\n    plt.plot(\n        NB_peth[n].as_units(\"s\").fillna(i),\n        \"o\",\n        color=[102 / 255, 204 / 255, 0 / 255],\n        markersize=4,\n    )  # Plot PETH\nplt.axvline(0, linewidth=2, color=\"k\", linestyle=\"--\")  # Plot a line at t = 0\nplt.yticks([0, 30])  # Set ticks on Y-axis\nplt.gca().set_yticklabels([\"1\", \"30\"])  # Label the ticks\nplt.xlabel(\"Time from NB (s)\")  # Time from boundary in seconds, on X-axis\nplt.ylabel(\"Trial Number\")  # Trial number on Y-axis\n\nplt.subplot(212)\nfor i, n in enumerate(HB_peth):\n    plt.plot(\n        HB_peth[n].as_units(\"s\").fillna(i),\n        \"o\",\n        color=[255 / 255, 99 / 255, 71 / 255],\n        markersize=4,\n    )  # Plot PETH\nplt.axvline(0, linewidth=2, color=\"k\", linestyle=\"--\")  # Plot a line at t = 0\nplt.yticks([0, 30])  # Set ticks on Y-axis\nplt.gca().set_yticklabels([\"1\", \"30\"])  # Label the ticks\nplt.xlabel(\"Time from HB (s)\")  # Time from boundary in seconds, on X-axis\nplt.ylabel(\"Trial Number\")  # Trial number on Y-axis\nplt.subplots_adjust(wspace=0.2, hspace=0.5, top=0.85)\n</code></pre> <p></p> <p>Awesome! From the PETH, we can see that this neuron fires after boundary onset in HB trials. This is an example of what the authors describe here as a boundary cell.</p>"},{"location":"generated/gallery/tutorial_human_dataset/#peth-of-firing-rate-for-nb-and-hb-cells","title":"PETH of firing rate for NB and HB cells","text":"<p>Now that we have the PETH of spiking, we can go one step further. We will plot the mean firing rate of this cell aligned to the boundary for each trial type. Doing this in Pynapple is very simple!</p> <pre><code>bin_size = 0.2  # 200ms bin size\nstep_size = 0.01  # 10ms step size, to make overlapping bins\nwinsize = int(bin_size / step_size)  # Window size\n</code></pre> <p>Use Pynapple to compute binned spike counts</p> <pre><code>counts_NB = NB_peth.count(step_size)  # Spike counts binned in 10ms steps, for NB trials\ncounts_HB = HB_peth.count(step_size)  # Spike counts binned in 10ms steps, for HB trials\n</code></pre> <p>Smooth the binned spike counts using a window of size 20, for both trial types</p> <pre><code>counts_NB = (\n    counts_NB.as_dataframe()\n    .rolling(winsize, win_type=\"gaussian\", min_periods=1, center=True, axis=0)\n    .mean(std=0.2 * winsize)\n)\ncounts_HB = (\n    counts_HB.as_dataframe()\n    .rolling(winsize, win_type=\"gaussian\", min_periods=1, center=True, axis=0)\n    .mean(std=0.2 * winsize)\n)\n</code></pre> <p>Out:</p> <pre><code>/mnt/home/gviejo/mambaforge/envs/pynapple/lib/python3.10/site-packages/pandas/core/window/rolling.py:1218: DeprecationWarning: Importing gaussian from 'scipy.signal' is deprecated and will raise an error in SciPy 1.13.0. Please use 'scipy.signal.windows.gaussian' or the convenience function 'scipy.signal.get_window' instead.\n  window = self._scipy_weight_generator(  # type: ignore[misc]\n/mnt/home/gviejo/mambaforge/envs/pynapple/lib/python3.10/site-packages/pandas/core/window/rolling.py:1218: DeprecationWarning: Importing gaussian from 'scipy.signal' is deprecated and will raise an error in SciPy 1.13.0. Please use 'scipy.signal.windows.gaussian' or the convenience function 'scipy.signal.get_window' instead.\n  window = self._scipy_weight_generator(  # type: ignore[misc]\n</code></pre> <p>Compute firing rate for both trial types</p> <pre><code>fr_NB = counts_NB * winsize\nfr_HB = counts_HB * winsize\n</code></pre> <p>Compute the mean firing rate for both trial types</p> <pre><code>meanfr_NB = fr_NB.mean(axis=1)\nmeanfr_HB = fr_HB.mean(axis=1)\n</code></pre> <p>Compute standard error of mean (SEM) of the firing rate for both trial types</p> <pre><code>error_NB = fr_NB.sem(axis=1)\nerror_HB = fr_HB.sem(axis=1)\n</code></pre> <p>Plot the mean +/- SEM of firing rate for both trial types</p> <pre><code>plt.figure(figsize =(15,8))\nplt.plot(\n    meanfr_NB, color=[102 / 255, 204 / 255, 0 / 255], label=\"NB\"\n)  # Plot mean firing rate for NB trials\n\n# Plot SEM for NB trials\nplt.fill_between(\n    meanfr_NB.index.values,\n    meanfr_NB.values - error_NB,\n    meanfr_NB.values + error_NB,\n    color=[102 / 255, 204 / 255, 0 / 255],\n    alpha=0.2,\n)\n\nplt.plot(\n    meanfr_HB, color=[255 / 255, 99 / 255, 71 / 255], label=\"HB\"\n)  # Plot mean firing rate for HB trials\n\n# Plot SEM for NB trials\nplt.fill_between(\n    meanfr_HB.index.values,\n    meanfr_HB.values - error_HB,\n    meanfr_HB.values + error_HB,\n    color=[255 / 255, 99 / 255, 71 / 255],\n    alpha=0.2,\n)\n\nplt.axvline(0, linewidth=2, color=\"k\", linestyle=\"--\")  # Plot a line at t = 0\nplt.xlabel(\"Time from boundary (s)\")  # Time from boundary in seconds, on X-axis\nplt.ylabel(\"Firing rate (Hz)\")  # Firing rate in Hz on Y-axis\nplt.legend(loc=\"upper right\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;matplotlib.legend.Legend object at 0x7fb325ac60b0&gt;\n</code></pre> <p>This plot verifies what we visualized in the PETH rasters above, that this cell responds to a hard boundary. Hence, it is a boundary cell. To learn more about these cells, please check out the original study here.</p> <p>I hope this tutorial was helpful. If you have any questions, comments or suggestions, please feel free to reach out to the Pynapple Team!</p> <p>Total running time of the script: ( 0 minutes  1.241 seconds)</p> <p> Download Python source code: tutorial_human_dataset.py</p> <p> Download Jupyter notebook: tutorial_human_dataset.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_pynapple_core/","title":"Core Tutorial","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_pynapple_core/#core-tutorial","title":"Core Tutorial","text":"<p>This script will introduce the basics of handling time series data with pynapple.</p> <p>Warning</p> <p>This tutorial uses seaborn and matplotlib for displaying the figure.</p> <p>You can install both with <code>pip install matplotlib seaborn</code></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport pynapple as nap\nimport pandas as pd\nimport seaborn as sns\n\ncustom_params = {\"axes.spines.right\": False, \"axes.spines.top\": False}\nsns.set_theme(style=\"ticks\", palette=\"colorblind\", font_scale=1.5, rc=custom_params)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_core/#time-series-object","title":"Time series object","text":"<p>Let's create a Tsd object with artificial data. In this example, every time point is 1 second apart.</p> <pre><code>tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100), time_units=\"s\")\n\nprint(tsd)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --------\n0.0         0.873544\n1.0         0.338862\n2.0         0.110709\n3.0         0.311105\n4.0         0.303162\n...\n95.0        0.553655\n96.0        0.782862\n97.0        0.880976\n98.0        0.381859\n99.0        0.591959\ndtype: float64, shape: (100,)\n</code></pre> <p>It is possible to toggle between seconds, milliseconds and microseconds. Note that when using as_units, the returned object is a simple pandas series.</p> <pre><code>print(tsd.as_units(\"ms\"), \"\\n\")\nprint(tsd.as_units(\"us\"))\n</code></pre> <p>Out:</p> <pre><code>Time (ms)\n0.0        0.873544\n1000.0     0.338862\n2000.0     0.110709\n3000.0     0.311105\n4000.0     0.303162\n             ...   \n95000.0    0.553655\n96000.0    0.782862\n97000.0    0.880976\n98000.0    0.381859\n99000.0    0.591959\nLength: 100, dtype: float64 \n\nTime (us)\n0           0.873544\n1000000     0.338862\n2000000     0.110709\n3000000     0.311105\n4000000     0.303162\n              ...   \n95000000    0.553655\n96000000    0.782862\n97000000    0.880976\n98000000    0.381859\n99000000    0.591959\nLength: 100, dtype: float64\n</code></pre> <p>Pynapple is able to handle data that only contains timestamps, such as an object containing only spike times. To do so, we construct a Ts object which holds only times. In this case, we generate 10 random spike times between 0 and 100 ms.</p> <pre><code>ts = nap.Ts(t=np.sort(np.random.uniform(0, 100, 10)), time_units=\"ms\")\n\nprint(ts)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n7.0318e-05\n0.006442014\n0.02783863\n0.033229842\n0.06585496\n0.066233547\n0.067912419\n0.076053715\n0.086820079\n0.086883154\nshape: 10\n</code></pre> <p>If the time series contains multiple columns, we use a TsdFrame.</p> <pre><code>tsdframe = nap.TsdFrame(\n    t=np.arange(100), d=np.random.rand(100, 3), time_units=\"s\", columns=[\"a\", \"b\", \"c\"]\n)\n\nprint(tsdframe)\n</code></pre> <p>Out:</p> <pre><code>Time (s)            a          b         c\n----------  ---------  ---------  --------\n0.0         0.324763   0.822091   0.156993\n1.0         0.935788   0.434967   0.790606\n2.0         0.167278   0.760678   0.499396\n3.0         0.0140697  0.0312312  0.203528\n4.0         0.442239   0.193309   0.596894\n...\n95.0        0.516754   0.857937   0.796121\n96.0        0.0148898  0.496021   0.376045\n97.0        0.172442   0.498695   0.558303\n98.0        0.910105   0.20274    0.240644\n99.0        0.135198   0.962653   0.408282\ndtype: float64, shape: (100, 3)\n</code></pre> <p>And if the number of dimension is even larger, we can use the TsdTensor (typically movies).</p> <pre><code>tsdframe = nap.TsdTensor(\n    t=np.arange(100), d=np.random.rand(100, 3, 4)\n)\n\nprint(tsdframe)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --------------------------------------------------\n0.0         [[0.26356910402427103 ... 0.8218959326299046] ...]\n1.0         [[0.39450025353572604 ... 0.9840948055045872] ...]\n2.0         [[0.45964776548326514 ... 0.5316589496414997] ...]\n3.0         [[0.48108818106788 ... 0.910452373543708] ...]\n4.0         [[0.5687991914696697 ... 0.4251292405181387] ...]\n...\n95.0        [[0.8370175610121228 ... 0.20604469043633034] ...]\n96.0        [[0.728448111147726 ... 0.7160131798912954] ...]\n97.0        [[0.5833379550788237 ... 0.9571767745470622] ...]\n98.0        [[0.18609620806639715 ... 0.3001596873516522] ...]\n99.0        [[0.5773457394684139 ... 0.3478204809469623] ...]\ndtype: float64, shape: (100, 3, 4)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_core/#interval-sets-object","title":"Interval Sets object","text":"<p>The IntervalSet object stores multiple epochs with a common time unit. It can then be used to restrict time series to this particular set of epochs.</p> <pre><code>epochs = nap.IntervalSet(start=[0, 10], end=[5, 15], time_units=\"s\")\n\nnew_tsd = tsd.restrict(epochs)\n\nprint(epochs)\nprint(\"\\n\")\nprint(new_tsd)\n</code></pre> <p>Out:</p> <pre><code>   start   end\n0    0.0   5.0\n1   10.0  15.0\n\n\nTime (s)\n----------  --------\n0           0.873544\n1           0.338862\n2           0.110709\n3           0.311105\n4           0.303162\n5           0.396723\n10          0.677118\n11          0.683525\n12          0.509349\n13          0.630584\n14          0.49476\n15          0.47755\ndtype: float64, shape: (12,)\n</code></pre> <p>Multiple operations are available for IntervalSet. For example, IntervalSet can be merged. See the full documentation of the class here for a list of all the functions that can be used to manipulate IntervalSets.</p> <pre><code>epoch1 = nap.IntervalSet(start=[0], end=[10])  # no time units passed. Default is us.\nepoch2 = nap.IntervalSet(start=[5, 30], end=[20, 45])\n\nepoch = epoch1.union(epoch2)\nprint(epoch1, \"\\n\")\nprint(epoch2, \"\\n\")\nprint(epoch)\n</code></pre> <p>Out:</p> <pre><code>   start   end\n0    0.0  10.0 \n\n   start   end\n0    5.0  20.0\n1   30.0  45.0 \n\n   start   end\n0    0.0  20.0\n1   30.0  45.0\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_core/#tsgroup-object","title":"TsGroup object","text":"<p>Multiple time series with different time stamps (.i.e. a group of neurons with different spike times from one session) can be grouped with the TsGroup object. The TsGroup behaves like a dictionary but it is also possible to slice with a list of indexes</p> <pre><code>my_ts = {\n    0: nap.Ts(\n        t=np.sort(np.random.uniform(0, 100, 1000)), time_units=\"s\"\n    ),  # here a simple dictionary\n    1: nap.Ts(t=np.sort(np.random.uniform(0, 100, 2000)), time_units=\"s\"),\n    2: nap.Ts(t=np.sort(np.random.uniform(0, 100, 3000)), time_units=\"s\"),\n}\n\ntsgroup = nap.TsGroup(my_ts)\n\nprint(tsgroup, \"\\n\")\nprint(tsgroup[0], \"\\n\")  # dictionary like indexing returns directly the Ts object\nprint(tsgroup[[0, 2]])  # list like indexing\n</code></pre> <p>Out:</p> <pre><code>  Index    rate\n-------  ------\n      0   10\n      1   20\n      2   30.01 \n\nTime (s)\n0.052171354\n0.096815653\n0.139977659\n0.196933875\n0.298956222\n...\n99.486588173\n99.725069767\n99.836849129\n99.837732431\n99.967444786\nshape: 1000 \n\n  Index    rate\n-------  ------\n      0   10\n      2   30.01\n</code></pre> <p>Operations such as restrict can thus be directly applied to the TsGroup as well as other operations.</p> <pre><code>newtsgroup = tsgroup.restrict(epochs)\n\ncount = tsgroup.count(\n    1, epochs, time_units=\"s\"\n)  # Here counting the elements within bins of 1 seconds\n\nprint(count)\n</code></pre> <p>Out:</p> <pre><code>  Time (s)    0    1    2\n----------  ---  ---  ---\n       0.5   10   22   34\n       1.5   13   22   40\n       2.5   14   17   24\n       3.5   12   18   20\n       4.5   13   12   32\n      10.5    9   16   27\n      11.5    5   18   36\n      12.5    8   25   40\n      13.5   14   23   28\n      14.5   10   17   32\ndtype: int64, shape: (10, 3)\n</code></pre> <p>One advantage of grouping time series is that metainformation can be appended directly on an element-wise basis. In this case, we add labels to each Ts object when instantiating the group and after. We can then use this label to split the group. See the TsGroup documentation for a complete methodology for splitting TsGroup objects.</p> <pre><code>label1 = pd.Series(index=list(my_ts.keys()), data=[0, 1, 0])\n\ntsgroup = nap.TsGroup(my_ts, time_units=\"s\", label1=label1)\ntsgroup.set_info(label2=np.array([\"a\", \"a\", \"b\"]))\n\nprint(tsgroup, \"\\n\")\n\nnewtsgroup = tsgroup.getby_category(\"label1\")\nprint(newtsgroup[0], \"\\n\")\nprint(newtsgroup[1])\n</code></pre> <p>Out:</p> <pre><code>  Index    rate    label1  label2\n-------  ------  --------  --------\n      0   10            0  a\n      1   20            1  a\n      2   30.01         0  b \n\n  Index    rate    label1  label2\n-------  ------  --------  --------\n      0   10            0  a\n      2   30.01         0  b \n\n  Index    rate    label1  label2\n-------  ------  --------  --------\n      1      20         1  a\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_core/#time-support","title":"Time support","text":"<p>A key feature of how pynapple manipulates time series is an inherent time support object defined for Ts, Tsd, TsdFrame and TsGroup objects. The time support object is defined as an IntervalSet that provides the time serie with a context. For example, the restrict operation will automatically update the time support object for the new time series. Ideally, the time support object should be defined for all time series when instantiating them. If no time series is given, the time support is inferred from the start and end of the time series.</p> <p>In this example, a TsGroup is instantiated with and without a time support. Notice how the frequency of each Ts element is changed when the time support is defined explicitly.</p> <pre><code>time_support = nap.IntervalSet(start=0, end=200, time_units=\"s\")\n\nmy_ts = {\n    0: nap.Ts(\n        t=np.sort(np.random.uniform(0, 100, 10)), time_units=\"s\"\n    ),  # here a simple dictionnary\n    1: nap.Ts(t=np.sort(np.random.uniform(0, 100, 20)), time_units=\"s\"),\n    2: nap.Ts(t=np.sort(np.random.uniform(0, 100, 30)), time_units=\"s\"),\n}\n\ntsgroup = nap.TsGroup(my_ts)\n\ntsgroup_with_time_support = nap.TsGroup(my_ts, time_support=time_support)\n\nprint(tsgroup, \"\\n\")\n\nprint(tsgroup_with_time_support, \"\\n\")\n\nprint(tsgroup_with_time_support.time_support)  # acceding the time support\n</code></pre> <p>Out:</p> <pre><code>  Index    rate\n-------  ------\n      0    0.11\n      1    0.22\n      2    0.32 \n\n  Index    rate\n-------  ------\n      0    0.05\n      1    0.1\n      2    0.15 \n\n   start    end\n0    0.0  200.0\n</code></pre> <p>We can use value_from which as it indicates assign to every timestamps the closed value in time from another time series. Let's define the time series we want to assign values from.</p> <pre><code>tsd_sin = nap.Tsd(t=np.arange(0, 100, 1), d=np.sin(np.arange(0, 10, 0.1)))\n\ntsgroup_sin = tsgroup.value_from(tsd_sin)\n\nplt.figure(figsize=(12, 6))\nplt.plot(tsgroup[0].fillna(0), \"|\", markersize=20, mew=3)\nplt.plot(tsd_sin, linewidth=2)\nplt.plot(tsgroup_sin[0], \"o\", markersize=20)\nplt.title(\"ts.value_from(tsd)\")\nplt.xlabel(\"Time (s)\")\nplt.yticks([-1, 0, 1])\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  1.751 seconds)</p> <p> Download Python source code: tutorial_pynapple_core.py</p> <p> Download Jupyter notebook: tutorial_pynapple_core.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_pynapple_dandi/","title":"Streaming data from DANDI","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_pynapple_dandi/#streaming-data-from-dandi","title":"Streaming data from DANDI","text":"<p>This script shows how to stream data from the DANDI Archive all the way to pynapple.</p> <p>Warning</p> <p>This tutorial uses seaborn and matplotlib for displaying the figure as well as the DANDI package</p> <p>You can install all with <code>pip install matplotlib seaborn dandi</code></p>"},{"location":"generated/gallery/tutorial_pynapple_dandi/#prelude","title":"Prelude","text":"<p>The data used in this tutorial were used in this publication: Sargolini, Francesca, et al. \"Conjunctive representation of position, direction, and velocity in entorhinal cortex.\" Science 312.5774 (2006): 758-762. The data can be found on the DANDI Archive in Dandiset 000582.</p> <p>mkdocs_gallery_thumbnail_number = 2</p>"},{"location":"generated/gallery/tutorial_pynapple_dandi/#dandi","title":"DANDI","text":"<p>DANDI allows you to stream data without downloading all the files. In this case the data extracted from the NWB file are stored in the nwb-cache folder.</p> <pre><code>from pynwb import NWBHDF5IO\n\nfrom dandi.dandiapi import DandiAPIClient\nimport fsspec\nfrom fsspec.implementations.cached import CachingFileSystem\nimport h5py\n\n\n# ecephys\ndandiset_id, filepath = (\n    \"000582\",\n    \"sub-10073/sub-10073_ses-17010302_behavior+ecephys.nwb\",\n)\n\n\nwith DandiAPIClient() as client:\n    asset = client.get_dandiset(dandiset_id, \"draft\").get_asset_by_path(filepath)\n    s3_url = asset.get_content_url(follow_redirects=1, strip_query=True)\n\n# first, create a virtual filesystem based on the http protocol\nfs = fsspec.filesystem(\"http\")\n\n# create a cache to save downloaded data to disk (optional)\nfs = CachingFileSystem(\n    fs=fs,\n    cache_storage=\"nwb-cache\",  # Local folder for the cache\n)\n\n# next, open the file\nfile = h5py.File(fs.open(s3_url, \"rb\"))\nio = NWBHDF5IO(file=file, load_namespaces=True)\n\nprint(io)\n</code></pre> <p>Out:</p> <pre><code>A newer version (0.58.1) of dandi/dandi-cli is available. You are using 0.56.1\n/mnt/home/gviejo/mambaforge/envs/pynapple/lib/python3.10/site-packages/hdmf/spec/namespace.py:531: UserWarning: Ignoring cached namespace 'hdmf-common' version 1.8.0 because version 1.7.0 is already loaded.\n  warn(\"Ignoring cached namespace '%s' version %s because version %s is already loaded.\"\n/mnt/home/gviejo/mambaforge/envs/pynapple/lib/python3.10/site-packages/hdmf/spec/namespace.py:531: UserWarning: Ignoring cached namespace 'hdmf-experimental' version 0.5.0 because version 0.4.0 is already loaded.\n  warn(\"Ignoring cached namespace '%s' version %s because version %s is already loaded.\"\n&lt;pynwb.NWBHDF5IO object at 0x7fb32d1e4730&gt;\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_dandi/#pynapple","title":"Pynapple","text":"<p>If opening the NWB works, you can start streaming data straight into pynapple with the <code>NWBFile</code> class.</p> <pre><code>import pynapple as nap\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\n\ncustom_params = {\"axes.spines.right\": False, \"axes.spines.top\": False}\nsns.set_theme(style=\"ticks\", palette=\"colorblind\", font_scale=1.5, rc=custom_params)\n\nnwb = nap.NWBFile(io.read())\n\nprint(nwb)\n</code></pre> <p>Out:</p> <pre><code>17010302\n\u250d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2511\n\u2502 Keys                \u2502 Type     \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 units               \u2502 TsGroup  \u2502\n\u2502 ElectricalSeriesLFP \u2502 Tsd      \u2502\n\u2502 SpatialSeriesLED1   \u2502 TsdFrame \u2502\n\u2502 ElectricalSeries    \u2502 Tsd      \u2502\n\u2515\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2519\n</code></pre> <p>We can load the spikes as a TsGroup for inspection.</p> <pre><code>units = nwb[\"units\"]\n\nprint(units)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate  unit_name    histology    hemisphere      depth\n-------  ------  -----------  -----------  ------------  -------\n      0    2.93  t1c1         MEC LII                     0.0024\n      1    1.5   t2c1         MEC LII                     0.0024\n      2    2.58  t2c3         MEC LII                     0.0024\n      3    1.13  t3c1         MEC LII                     0.0024\n      4    1.29  t3c2         MEC LII                     0.0024\n      5    1.36  t3c3         MEC LII                     0.0024\n      6    2.89  t3c4         MEC LII                     0.0024\n      7    1.47  t4c1         MEC LII                     0.0024\n</code></pre> <p>As well as the position</p> <pre><code>position = nwb[\"SpatialSeriesLED1\"]\n</code></pre> <p>Here we compute the 2d tuning curves</p> <pre><code>tc, binsxy = nap.compute_2d_tuning_curves(units, position, 20)\n</code></pre> <p>Out:</p> <pre><code>/mnt/home/gviejo/pynapple/pynapple/process/tuning_curves.py:203: RuntimeWarning: invalid value encountered in divide\n  count = count / occupancy\n</code></pre> <p>Let's plot the tuning curves</p> <pre><code>plt.figure(figsize=(15, 7))\nfor i in tc.keys():\n    plt.subplot(2, 4, i + 1)\n    plt.imshow(tc[i], origin=\"lower\", aspect=\"auto\")\n    plt.title(\"Unit {}\".format(i))\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>Let's plot the spikes of unit 1 who has a nice grid Here I use the function <code>value_from</code> to assign to each spike the closest position in time.</p> <pre><code>plt.figure(figsize=(15, 6))\nplt.subplot(121)\nextent = (\n    np.min(position[\"x\"]),\n    np.max(position[\"x\"]),\n    np.min(position[\"y\"]),\n    np.max(position[\"y\"]),\n)\nplt.imshow(tc[1], origin=\"lower\", extent=extent, aspect=\"auto\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\nplt.subplot(122)\nplt.plot(position[\"y\"], position[\"x\"], color=\"grey\")\nspk_pos = units[1].value_from(position)\nplt.plot(spk_pos[\"y\"], spk_pos[\"x\"], \"o\", color=\"red\", markersize=5, alpha=0.5)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  4.798 seconds)</p> <p> Download Python source code: tutorial_pynapple_dandi.py</p> <p> Download Jupyter notebook: tutorial_pynapple_dandi.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_pynapple_io/","title":"IO Tutorial","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_pynapple_io/#io-tutorial","title":"IO Tutorial","text":"<p>This notebook is designed to demonstrate the pynapple IO. It is build around the specifications of the BIDS standard for sharing datasets. The key ideas are summarized as follow :</p> <ul> <li> <p>Hierarchy of folders</p> <p></p> </li> <li> <p>Filename template</p> <p></p> </li> <li> <p>Metadata files</p> <p></p> </li> </ul>"},{"location":"generated/gallery/tutorial_pynapple_io/#navigating-a-structured-dataset","title":"Navigating a structured dataset","text":"<p>The dataset in this example can be found here.</p> <pre><code>import numpy as np\nimport pynapple as nap\n\n# mkdocs_gallery_thumbnail_path = '_static/treeview.png'\n\nproject_path = \"../../your/path/to/MyProject\"\n\nproject = nap.load_folder(project_path)\n\nprint(project)\n</code></pre> <p>Out:</p> <pre><code>\ud83d\udcc2 MyProject\n\u2514\u2500\u2500 \ud83d\udcc2 sub-A2929\n</code></pre> <p>The pynapple IO offers a convenient way of visualizing and navigating a folder based dataset. To visualize the whole hierarchy of Folders, you can call the view property or the expand function.</p> <pre><code>project.view\n</code></pre> <p>Out:</p> <pre><code>\ud83d\udcc2 MyProject\n\u2514\u2500\u2500 \ud83d\udcc2 sub-A2929\n    \u2514\u2500\u2500 \ud83d\udcc2 ses-A2929-200711\n        \u251c\u2500\u2500 \ud83d\udcc2 derivatives\n        \u2502   \u251c\u2500\u2500 spikes.npz      |        TsGroup\n        \u2502   \u251c\u2500\u2500 sleep_ep.npz    |        IntervalSet\n        \u2502   \u251c\u2500\u2500 position.npz    |        TsdFrame\n        \u2502   \u2514\u2500\u2500 wake_ep.npz     |        IntervalSet\n        \u251c\u2500\u2500 \ud83d\udcc2 pynapplenwb\n        \u2502   \u251c\u2500\u2500 A2929-200711_nc         |        NWB file\n        \u2502   \u2514\u2500\u2500 A2929-200711    |        NWB file\n        \u251c\u2500\u2500 x_plus_1.npz    |        Tsd\n        \u251c\u2500\u2500 x_plus_y.npz    |        Tsd\n        \u2514\u2500\u2500 stimulus-fish.npz       |        IntervalSet\n</code></pre> <p>Here it shows all the subjects (in this case only A2929), all the sessions and all of the derivatives folders. It shows as well all the NPZ files that contains a pynapple object and the NWB files.</p> <p>The object project behaves like a nested dictionnary. It is then easy to loop and navigate through a hierarchy of folders when doing analyses. In this case, we are gonna take only the session A2929-200711.</p> <pre><code>session = project[\"sub-A2929\"][\"ses-A2929-200711\"]\n\nprint(session)\n</code></pre> <p>Out:</p> <pre><code>\ud83d\udcc2 ses-A2929-200711\n\u251c\u2500\u2500 \ud83d\udcc2 derivatives\n\u251c\u2500\u2500 \ud83d\udcc2 pynapplenwb\n\u251c\u2500\u2500 x_plus_1.npz    |        Tsd\n\u251c\u2500\u2500 x_plus_y.npz    |        Tsd\n\u2514\u2500\u2500 stimulus-fish.npz       |        IntervalSet\n</code></pre> <p>I can expand to see what the folders contains.</p> <pre><code>print(session.expand())\n</code></pre> <p>Out:</p> <pre><code>\ud83d\udcc2 ses-A2929-200711\n\u251c\u2500\u2500 \ud83d\udcc2 derivatives\n\u2502   \u251c\u2500\u2500 spikes.npz      |        TsGroup\n\u2502   \u251c\u2500\u2500 sleep_ep.npz    |        IntervalSet\n\u2502   \u251c\u2500\u2500 position.npz    |        TsdFrame\n\u2502   \u2514\u2500\u2500 wake_ep.npz     |        IntervalSet\n\u251c\u2500\u2500 \ud83d\udcc2 pynapplenwb\n\u2502   \u251c\u2500\u2500 A2929-200711_nc         |        NWB file\n\u2502   \u2514\u2500\u2500 A2929-200711    |        NWB file\n\u251c\u2500\u2500 x_plus_1.npz    |        Tsd\n\u251c\u2500\u2500 x_plus_y.npz    |        Tsd\n\u2514\u2500\u2500 stimulus-fish.npz       |        IntervalSet\nNone\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_io/#loading-files","title":"Loading files","text":"<p>By default, pynapple save objects as NPZ. It is a convenient way to save all the properties of an object such as the time support. The pynapple IO offers an easy way to load any NPZ files that matches the structures defined for a pynapple object.</p> <pre><code>spikes = session[\"derivatives\"][\"spikes\"]\nposition = session[\"derivatives\"][\"position\"]\nwake_ep = session[\"derivatives\"][\"wake_ep\"]\nsleep_ep = session[\"derivatives\"][\"sleep_ep\"]\n</code></pre> <p>Objects are only loaded when they are called.</p> <pre><code>print(session[\"derivatives\"][\"spikes\"])\n</code></pre> <p>Out:</p> <pre><code>  Index    rate    group  location\n-------  ------  -------  ----------\n      0    7.3         0  adn\n      1    5.73        0  adn\n      2    8.12        0  adn\n      3    6.68        0  adn\n      4   10.77        0  adn\n      5   11           0  adn\n      6   16.52        0  adn\n      7    2.2         1  ca1\n      8    2.02        1  ca1\n      9    1.07        1  ca1\n     10    3.92        1  ca1\n     11    3.31        1  ca1\n     12    1.09        1  ca1\n     13    1.28        1  ca1\n     14    1.32        1  ca1\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_io/#metadata","title":"Metadata","text":"<p>A good practice for sharing datasets is to write as many metainformation as possible. Following BIDS specifications, any data files should be accompagned by a JSON sidecar file.</p> <pre><code>import os\n\nfor f in os.listdir(session[\"derivatives\"].path):\n    print(f)\n</code></pre> <p>Out:</p> <pre><code>wake_ep.json\nposition.json\nsleep_ep.json\nspikes.npz\nsleep_ep.npz\nspikes.json\nposition.npz\nwake_ep.npz\n</code></pre> <p>To read the metainformation associated with a file, you can use the functions <code>doc</code>, <code>info</code> or <code>metadata</code> :</p> <pre><code>session[\"derivatives\"].doc(\"spikes\")\n\n\nsession[\"derivatives\"].doc(\"position\")\n</code></pre> <p>Out:</p> <pre><code>\u256d\u2500 ../../your/path/to/MyProject/sub-A2929/ses-A2929-200711/derivatives/spikes.npz\u2500\u256e\n\u2502 time : 2023-07-11 12:40:10.338066                                               \u2502\n\u2502 info : Neurons recorded simultaneously in ADN and CA1                           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 ../../your/path/to/MyProject/sub-A2929/ses-A2929-200711/derivatives/position.n\u2500\u256e\n\u2502 time : 2023-07-11 12:40:10.364061                                               \u2502\n\u2502 info : Position and head-direction of the mouse recorded with Optitrack         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_io/#saving-a-pynapple-object","title":"Saving a pynapple object","text":"<p>In this case, we define a new Tsd and a new IntervalSet that we would like to save in the session folder.</p> <pre><code>tsd = position[\"x\"] + 1\nepoch = nap.IntervalSet(start=np.array([0, 3]), end=np.array([1, 6]))\n\nsession.save(\"x_plus_1\", tsd, description=\"Random position\")\nsession.save(\"stimulus-fish\", epoch, description=\"Fish pictures to V1\")\n</code></pre> <p>We can visualize the newly saved objects.</p> <pre><code>session.expand()\n</code></pre> <p>Out:</p> <pre><code>\ud83d\udcc2 ses-A2929-200711\n\u251c\u2500\u2500 \ud83d\udcc2 derivatives\n\u2502   \u251c\u2500\u2500 spikes.npz      |        TsGroup\n\u2502   \u251c\u2500\u2500 sleep_ep.npz    |        IntervalSet\n\u2502   \u251c\u2500\u2500 position.npz    |        TsdFrame\n\u2502   \u2514\u2500\u2500 wake_ep.npz     |        IntervalSet\n\u251c\u2500\u2500 \ud83d\udcc2 pynapplenwb\n\u2502   \u251c\u2500\u2500 A2929-200711_nc         |        NWB file\n\u2502   \u2514\u2500\u2500 A2929-200711    |        NWB file\n\u251c\u2500\u2500 x_plus_1.npz    |        Tsd\n\u251c\u2500\u2500 x_plus_y.npz    |        Tsd\n\u2514\u2500\u2500 stimulus-fish.npz       |        IntervalSet\n</code></pre> <pre><code>session.doc(\"stimulus-fish\")\n</code></pre> <p>Out:</p> <pre><code>\u256d\u2500 ../../your/path/to/MyProject/sub-A2929/ses-A2929-200711/stimulus-fish.npz \u2500\u256e\n\u2502 time : 2023-12-12 18:25:24.389173                                           \u2502\n\u2502 info : Fish pictures to V1                                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <pre><code>session[\"x_plus_1\"]\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --------\n670.6407    0.957143\n670.649     0.956137\n670.65735   0.955147\n670.66565   0.954213\n670.674     0.953244\n...\n1199.9616   1.01124\n1199.96995  1.01097\n1199.97825  1.01079\n1199.9866   1.01066\n1199.99495  1.01062\ndtype: float64, shape: (63527,)\n</code></pre> <p>Total running time of the script: ( 0 minutes  2.231 seconds)</p> <p> Download Python source code: tutorial_pynapple_io.py</p> <p> Download Jupyter notebook: tutorial_pynapple_io.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_pynapple_numpy/","title":"Numpy tutorial","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#numpy-tutorial","title":"Numpy tutorial","text":"<p>This tutorial shows how pynapple interact with numpy.</p> <pre><code>import numpy as np\nimport pynapple as nap\nimport pandas as pd\n</code></pre> <p>Multiple time series object are avaible depending on the shape of the data.</p> <ul> <li><code>TsdTensor</code> : for data with of more than 2 dimensions, typically movies.</li> <li><code>TsdFrame</code> : for column-based data. It can be easily converted to a pandas.DataFrame. Columns can be labelled and selected similar to pandas.</li> <li><code>Tsd</code> : One-dimensional time series. It can be converted to a pandas.Series.</li> <li><code>Ts</code> : For timestamps data only.</li> </ul>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#initialization","title":"Initialization","text":"<pre><code>tsdtensor = nap.TsdTensor(t=np.arange(100), d=np.random.rand(100, 5, 5), time_units=\"s\")\ntsdframe = nap.TsdFrame(t=np.arange(100), d=np.random.rand(100, 3), columns = ['a', 'b', 'c'])\ntsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\nts = nap.Ts(t=np.arange(100))\n\nprint(tsdtensor)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  ----------------------------------------------------\n0.0         [[0.16030978018956243 ... 0.3200733010387198] ...]\n1.0         [[0.6824265435848482 ... 0.8838755509309568] ...]\n2.0         [[0.985963109757545 ... 0.5174614544841756] ...]\n3.0         [[0.3904435355999102 ... 0.2935417968055649] ...]\n4.0         [[0.08047027992994815 ... 0.015352918719395814] ...]\n...\n95.0        [[0.1692356547545103 ... 0.1950187456414365] ...]\n96.0        [[0.08697600700649133 ... 0.9580777645190037] ...]\n97.0        [[0.6445362966310901 ... 0.5624660568391467] ...]\n98.0        [[0.15251632291789763 ... 0.5995175571857989] ...]\n99.0        [[0.08507619966334212 ... 0.12411692689801324] ...]\ndtype: float64, shape: (100, 5, 5)\n</code></pre> <p>tsd and ts can be converted to a pandas.Series</p> <pre><code>print(tsd.as_series())\n</code></pre> <p>Out:</p> <pre><code>0.0     0.125050\n1.0     0.612449\n2.0     0.225466\n3.0     0.473468\n4.0     0.854429\n          ...   \n95.0    0.710269\n96.0    0.978893\n97.0    0.927982\n98.0    0.308838\n99.0    0.152390\nLength: 100, dtype: float64\n</code></pre> <p>tsdframe to a pandas.DataFrame</p> <pre><code>print(tsdframe.as_dataframe())\n</code></pre> <p>Out:</p> <pre><code>             a         b         c\n0.0   0.143238  0.218956  0.990287\n1.0   0.580203  0.502060  0.559367\n2.0   0.989733  0.970728  0.969262\n3.0   0.318581  0.716659  0.841172\n4.0   0.274841  0.284739  0.999413\n...        ...       ...       ...\n95.0  0.144900  0.477373  0.406370\n96.0  0.840106  0.633803  0.223582\n97.0  0.376190  0.924564  0.513035\n98.0  0.933163  0.148098  0.810128\n99.0  0.081547  0.770898  0.646337\n\n[100 rows x 3 columns]\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#attributes","title":"Attributes","text":"<p>The numpy array is accesible with the attributes <code>.values</code>, <code>.d</code> and functions <code>.as_array()</code>, <code>to_numpy()</code>. The time index array is a <code>TsIndex</code> object accessible with <code>.index</code> or <code>.t</code>. <code>.shape</code> and <code>.ndim</code> are also accessible.</p> <pre><code>print(tsdtensor.ndim)\nprint(tsdframe.shape)\nprint(len(tsd))\n</code></pre> <p>Out:</p> <pre><code>3\n(100, 3)\n100\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#slicing","title":"Slicing","text":"<p>Slicing is very similar to numpy array. The first dimension is always time and time support is always passed on if a pynapple object is returned.</p> <p>First 10 elements. Return a TsdTensor</p> <pre><code>print(tsdtensor[0:10]) \n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  ----------------------------------------------------\n0           [[0.16030978018956243 ... 0.3200733010387198] ...]\n1           [[0.6824265435848482 ... 0.8838755509309568] ...]\n2           [[0.985963109757545 ... 0.5174614544841756] ...]\n3           [[0.3904435355999102 ... 0.2935417968055649] ...]\n4           [[0.08047027992994815 ... 0.015352918719395814] ...]\n5           [[0.7297474751420581 ... 0.9066980554295024] ...]\n6           [[0.37738950533699245 ... 0.843781316126003] ...]\n7           [[0.315956527860933 ... 0.5275943864747835] ...]\n8           [[0.8591130699488202 ... 0.7805758793388509] ...]\n9           [[0.24285691252986297 ... 0.29326151335818706] ...]\ndtype: float64, shape: (10, 5, 5)\n</code></pre> <p>First column. Return a Tsd</p> <pre><code>print(tsdframe[:,0])\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --------\n0.0         0.143238\n1.0         0.580203\n2.0         0.989733\n3.0         0.318581\n4.0         0.274841\n...\n95.0        0.1449\n96.0        0.840106\n97.0        0.37619\n98.0        0.933163\n99.0        0.081547\ndtype: float64, shape: (100,)\n</code></pre> <p>First element. Return a numpy ndarray</p> <pre><code>print(tsdtensor[0])\n</code></pre> <p>Out:</p> <pre><code>[[0.16030978 0.17126498 0.10705324 0.47009981 0.3200733 ]\n [0.34209566 0.09989871 0.19263691 0.05745728 0.66229196]\n [0.77837188 0.64435865 0.82020644 0.4656266  0.37351002]\n [0.02726072 0.46002608 0.48292452 0.43728904 0.92455123]\n [0.75698096 0.66191222 0.93236669 0.14425595 0.08562664]]\n</code></pre> <p>The time support is never changing when slicing time down.</p> <pre><code>print(tsd.time_support)\nprint(tsd[0:20].time_support)\n</code></pre> <p>Out:</p> <pre><code>   start   end\n0    0.0  99.0\n   start   end\n0    0.0  99.0\n</code></pre> <p>TsdFrame offers special slicing similar to pandas.DataFrame.</p> <p>Only TsdFrame can have columns labelling and indexing.</p> <pre><code>print(tsdframe.loc['a'])\nprint(tsdframe.loc[['a', 'c']])\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --------\n0.0         0.143238\n1.0         0.580203\n2.0         0.989733\n3.0         0.318581\n4.0         0.274841\n...\n95.0        0.1449\n96.0        0.840106\n97.0        0.37619\n98.0        0.933163\n99.0        0.081547\ndtype: float64, shape: (100,)\nTime (s)           a         c\n----------  --------  --------\n0.0         0.143238  0.990287\n1.0         0.580203  0.559367\n2.0         0.989733  0.969262\n3.0         0.318581  0.841172\n4.0         0.274841  0.999413\n...\n95.0        0.1449    0.40637\n96.0        0.840106  0.223582\n97.0        0.37619   0.513035\n98.0        0.933163  0.810128\n99.0        0.081547  0.646337\ndtype: float64, shape: (100, 2)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#arithmetic","title":"Arithmetic","text":"<p>Arithmetical operations works similar to numpy</p> <pre><code>tsd = nap.Tsd(t=np.arange(5), d=np.ones(5))\nprint(tsd + 1)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --\n0            2\n1            2\n2            2\n3            2\n4            2\ndtype: float64, shape: (5,)\n</code></pre> <p>It is possible to do array operations on the time series provided that the dimensions matches. The output will still be a time series object.</p> <pre><code>print(tsd - np.ones(5))\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --\n0            0\n1            0\n2            0\n3            0\n4            0\ndtype: float64, shape: (5,)\n</code></pre> <p>Nevertheless operations like this are not permitted :</p> <pre><code>try:\n    tsd + tsd\nexcept Exception as error:\n    print(error)\n</code></pre> <p>Out:</p> <pre><code>operand type(s) all returned NotImplemented from __array_ufunc__(&lt;ufunc 'add'&gt;, '__call__', Time (s)\n----------  --\n0            1\n1            1\n2            1\n3            1\n4            1\ndtype: float64, shape: (5,), Time (s)\n----------  --\n0            1\n1            1\n2            1\n3            1\n4            1\ndtype: float64, shape: (5,)): 'Tsd', 'Tsd'\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#array-operations","title":"Array operations","text":"<p>The most common numpy functions will return a time series if the output first dimension matches the shape of the time index.</p> <p>Here i average along the time axis and get a numpy array.</p> <pre><code>print(np.mean(tsdtensor, 0))\n</code></pre> <p>Out:</p> <pre><code>[[0.50177724 0.4688047  0.52978051 0.49579244 0.49416237]\n [0.54656925 0.51921085 0.48024167 0.48442483 0.53412301]\n [0.51413013 0.53041375 0.44682444 0.43830312 0.47947267]\n [0.46128471 0.50086357 0.5450657  0.49867021 0.53713824]\n [0.51090388 0.50074346 0.46952468 0.54334209 0.55471323]]\n</code></pre> <p>Here I average across the second dimension and get a TsdFrame</p> <pre><code>print(np.mean(tsdtensor, 1))\n</code></pre> <p>Out:</p> <pre><code>Time (s)           0         1         2         3         4\n----------  --------  --------  --------  --------  --------\n0.0         0.413004  0.407492  0.507038  0.314946  0.473211\n1.0         0.421394  0.677879  0.542773  0.679793  0.568476\n2.0         0.629451  0.610463  0.443739  0.328271  0.46217\n3.0         0.511138  0.389817  0.425515  0.376148  0.493179\n4.0         0.605086  0.699093  0.499498  0.440976  0.486868\n...\n95.0        0.38555   0.670493  0.447997  0.458065  0.465762\n96.0        0.288979  0.354906  0.603987  0.586551  0.455062\n97.0        0.471771  0.419108  0.218985  0.573108  0.664287\n98.0        0.359428  0.436131  0.344027  0.461508  0.740564\n99.0        0.451554  0.388488  0.621892  0.567428  0.318548\ndtype: float64, shape: (100, 5)\n</code></pre> <p>This is not true for fft functions though.</p> <pre><code>try:\n    np.fft.fft(tsd)\nexcept Exception as error:\n    print(error)\n</code></pre> <p>Out:</p> <pre><code>no implementation found for 'numpy.fft.fft' on types that implement __array_function__: [&lt;class 'pynapple.core.time_series.Tsd'&gt;]\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#concatenating","title":"Concatenating","text":"<p>It is possible to concatenate time series providing than they don't overlap meaning time indexe should be already sorted through all time series to concatenate</p> <pre><code>tsd1 = nap.Tsd(t=np.arange(5), d=np.ones(5))\ntsd2 = nap.Tsd(t=np.arange(5)+10, d=np.ones(5)*2)\ntsd3 = nap.Tsd(t=np.arange(5)+20, d=np.ones(5)*3)\n\nprint(np.concatenate((tsd1, tsd2, tsd3)))\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --\n0            1\n1            1\n2            1\n3            1\n4            1\n10           2\n11           2\n12           2\n13           2\n14           2\n20           3\n21           3\n22           3\n23           3\n24           3\ndtype: float64, shape: (15,)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#spliting","title":"Spliting","text":"<p>Array split functions are also implemented</p> <pre><code>print(np.array_split(tsdtensor[0:10], 2))\n</code></pre> <p>Out:</p> <pre><code>[Time (s)\n----------  ----------------------------------------------------\n0           [[0.16030978018956243 ... 0.3200733010387198] ...]\n1           [[0.6824265435848482 ... 0.8838755509309568] ...]\n2           [[0.985963109757545 ... 0.5174614544841756] ...]\n3           [[0.3904435355999102 ... 0.2935417968055649] ...]\n4           [[0.08047027992994815 ... 0.015352918719395814] ...]\ndtype: float64, shape: (5, 5, 5), Time (s)\n----------  ---------------------------------------------------\n5           [[0.7297474751420581 ... 0.9066980554295024] ...]\n6           [[0.37738950533699245 ... 0.843781316126003] ...]\n7           [[0.315956527860933 ... 0.5275943864747835] ...]\n8           [[0.8591130699488202 ... 0.7805758793388509] ...]\n9           [[0.24285691252986297 ... 0.29326151335818706] ...]\ndtype: float64, shape: (5, 5, 5)]\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#modifying","title":"Modifying","text":"<p>It is possible to modify a time series element wise</p> <pre><code>print(tsd1)\n\ntsd1[0] = np.pi\n\nprint(tsd1)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --\n0            1\n1            1\n2            1\n3            1\n4            1\ndtype: float64, shape: (5,)\nTime (s)\n----------  -------\n0           3.14159\n1           1\n2           1\n3           1\n4           1\ndtype: float64, shape: (5,)\n</code></pre> <p>It is also possible to modify a time series with logical operations</p> <pre><code>tsd[tsd.values&gt;0.5] = 0.0\n\nprint(tsd)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --\n0            0\n1            0\n2            0\n3            0\n4            0\ndtype: float64, shape: (5,)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_numpy/#sorting","title":"Sorting","text":"<p>It is not possible to sort along the first dimension as it would break the sorting of the time index</p> <pre><code>tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n\ntry:\n    np.sort(tsd)\nexcept Exception as error:\n    print(error)\n</code></pre> <p>Out:</p> <pre><code>no implementation found for 'numpy.sort' on types that implement __array_function__: [&lt;class 'pynapple.core.time_series.Tsd'&gt;]\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.500 seconds)</p> <p> Download Python source code: tutorial_pynapple_numpy.py</p> <p> Download Jupyter notebook: tutorial_pynapple_numpy.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_pynapple_process/","title":"Advanced processing","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_pynapple_process/#advanced-processing","title":"Advanced processing","text":"<p>The pynapple package provides a small set of high-level functions that are widely used in systems neuroscience.</p> <ul> <li>Discrete correlograms</li> <li>Tuning curves</li> <li>Decoding</li> <li>PETH</li> <li>Randomization</li> </ul> <p>This notebook provides few examples with artificial data.</p> <p>Warning</p> <p>This tutorial uses seaborn and matplotlib for displaying the figure.</p> <p>You can install both with <code>pip install matplotlib seaborn</code></p> <pre><code>import numpy as np\nimport pandas as pd\nimport pynapple as nap\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ncustom_params = {\"axes.spines.right\": False, \"axes.spines.top\": False}\nsns.set_theme(style=\"ticks\", palette=\"colorblind\", font_scale=1.5, rc=custom_params)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_process/#discrete-correlograms","title":"Discrete correlograms","text":"<p>The function to compute cross-correlogram is cross_correlogram.</p> <p>The function is compiled with numba to improve performances. This means it only accepts pure numpy arrays as input arguments.</p> <pre><code>ts1 = nap.Ts(t=np.sort(np.random.uniform(0, 1000, 1000)), time_units=\"s\")\nts2 = nap.Ts(t=np.sort(np.random.uniform(0, 1000, 10)), time_units=\"s\")\n\nts1_time_array = ts1.as_units(\"s\").index.values\nts2_time_array = ts2.as_units(\"s\").index.values\n\nbinsize = 0.1  # second\ncc12, xt = nap.cross_correlogram(\n    t1=ts1_time_array, t2=ts2_time_array, binsize=binsize, windowsize=1  # second\n)\n\nplt.figure(figsize=(10, 6))\nplt.bar(xt, cc12, binsize)\nplt.xlabel(\"Time t1 (us)\")\nplt.ylabel(\"CC\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>Text(40.75, 0.5, 'CC')\n</code></pre> <p>To simplify converting to a numpy.ndarray, pynapple provides wrappers for computing autocorrelogram and crosscorrelogram for TsGroup. The function is then called for each unit or each pairs of units. It returns directly a pandas.DataFrame holding all the correlograms. In this example, autocorrelograms and cross-correlograms are computed for the same TsGroup.</p> <pre><code>epoch = nap.IntervalSet(start=0, end=1000, time_units=\"s\")\nts_group = nap.TsGroup({0: ts1, 1: ts2}, time_support=epoch)\n\nautocorrs = nap.compute_autocorrelogram(\n    group=ts_group, binsize=100, windowsize=1000, time_units=\"ms\", ep=epoch  # ms  # ms\n)\ncrosscorrs = nap.compute_crosscorrelogram(\n    group=ts_group, binsize=100, windowsize=1000, time_units=\"ms\"  # ms  # ms\n)\n\nprint(autocorrs, \"\\n\")\nprint(crosscorrs, \"\\n\")\n</code></pre> <p>Out:</p> <pre><code>         0    1\n-0.9  1.03  0.0\n-0.8  0.88  0.0\n-0.7  1.06  0.0\n-0.6  0.92  0.0\n-0.5  0.89  0.0\n-0.4  0.91  0.0\n-0.3  1.02  0.0\n-0.2  1.10  0.0\n-0.1  0.98  0.0\n 0.0  0.00  0.0\n 0.1  0.98  0.0\n 0.2  1.10  0.0\n 0.3  1.02  0.0\n 0.4  0.91  0.0\n 0.5  0.89  0.0\n 0.6  0.92  0.0\n 0.7  1.06  0.0\n 0.8  0.88  0.0\n 0.9  1.03  0.0 \n\n        0\n        1\n-0.9  1.0\n-0.8  1.0\n-0.7  0.0\n-0.6  0.0\n-0.5  0.0\n-0.4  1.0\n-0.3  0.0\n-0.2  1.0\n-0.1  1.0\n 0.0  0.0\n 0.1  0.0\n 0.2  1.0\n 0.3  0.0\n 0.4  0.0\n 0.5  1.0\n 0.6  1.0\n 0.7  1.0\n 0.8  1.0\n 0.9  1.0 \n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_process/#peri-event-time-histogram-peth","title":"Peri-Event Time Histogram (PETH)","text":"<p>A second way to examine the relationship between spiking and an event (i.e. stimulus) is to compute a PETH. pynapple uses the function <code>compute_perievent</code> to center spike time around the timestamps of an event within a given window.</p> <pre><code>stim = nap.Tsd(\n    t=np.sort(np.random.uniform(0, 1000, 50)), d=np.random.rand(50), time_units=\"s\"\n)\n\npeth0 = nap.compute_perievent(ts1, stim, minmax=(-0.1, 0.2), time_unit=\"s\")\n\nprint(peth0)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate    ref_times\n-------  ------  -----------\n      0    6.67      35.4757\n      1  nan         79.1868\n      2  nan         88.1569\n      3  nan         90.508\n      4  nan        115.251\n      5  nan        137.802\n      6  nan        151.913\n      7  nan        179.321\n      8  nan        214.017\n      9    3.33     257.196\n     10  nan        258.962\n     11    3.33     284.541\n     12  nan        378.832\n     13  nan        389.061\n     14  nan        393.176\n     15  nan        402.263\n     16  nan        418.468\n     17  nan        424.354\n     18  nan        429.849\n     19    3.33     455.055\n     20  nan        471.276\n     21  nan        494.362\n     22    3.33     511.343\n     23  nan        527.743\n     24    3.33     536.806\n     25    3.33     581.077\n     26  nan        598.782\n     27  nan        626.413\n     28  nan        639.655\n     29  nan        657.579\n     30  nan        675.623\n     31  nan        682.449\n     32  nan        688.411\n     33    3.33     704.469\n     34  nan        705.446\n     35  nan        706.43\n     36  nan        723.528\n     37  nan        727.386\n     38  nan        751.515\n     39  nan        774.906\n     40  nan        817.495\n     41    3.33     823.103\n     42  nan        840.159\n     43  nan        865.826\n     44    3.33     889.637\n     45    3.33     891.784\n     46  nan        922.455\n     47  nan        942.382\n     48    3.33     950.896\n     49    3.33     953.499\n</code></pre> <p>It is then easy to create a raster plot around the times of the stimulation event by calling the <code>to_tsd</code> function of pynapple to \"flatten\" the TsGroup peth0.</p> <p>mkdocs_gallery_thumbnail_number = 2</p> <pre><code>plt.figure(figsize=(10, 6))\nplt.subplot(211)\nplt.plot(np.sum(peth0.count(0.01), 1), linewidth=3, color=\"red\")\nplt.xlim(-0.1, 0.2)\nplt.ylabel(\"Count\")\nplt.axvline(0.0)\nplt.subplot(212)\nplt.plot(peth0.to_tsd(), \"|\", markersize=20, color=\"red\", mew=4)\nplt.xlabel(\"Time from stim (s)\")\nplt.ylabel(\"Stimulus\")\nplt.xlim(-0.1, 0.2)\nplt.axvline(0.0)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;matplotlib.lines.Line2D object at 0x7fb32529d690&gt;\n</code></pre> <p>The same function can be applied to a group of neurons. In this case, it returns a dict of TsGroup</p> <pre><code>pethall = nap.compute_perievent(ts_group, stim, minmax=(-0.1, 0.2), time_unit=\"s\")\n\nprint(pethall[1])\n</code></pre> <p>Out:</p> <pre><code>  Index    rate    ref_times\n-------  ------  -----------\n      0  nan         35.4757\n      1  nan         79.1868\n      2  nan         88.1569\n      3  nan         90.508\n      4  nan        115.251\n      5  nan        137.802\n      6  nan        151.913\n      7    3.33     179.321\n      8  nan        214.017\n      9  nan        257.196\n     10  nan        258.962\n     11  nan        284.541\n     12  nan        378.832\n     13  nan        389.061\n     14  nan        393.176\n     15  nan        402.263\n     16  nan        418.468\n     17  nan        424.354\n     18  nan        429.849\n     19  nan        455.055\n     20  nan        471.276\n     21  nan        494.362\n     22  nan        511.343\n     23  nan        527.743\n     24  nan        536.806\n     25  nan        581.077\n     26  nan        598.782\n     27  nan        626.413\n     28  nan        639.655\n     29  nan        657.579\n     30  nan        675.623\n     31  nan        682.449\n     32  nan        688.411\n     33  nan        704.469\n     34  nan        705.446\n     35  nan        706.43\n     36  nan        723.528\n     37  nan        727.386\n     38  nan        751.515\n     39  nan        774.906\n     40  nan        817.495\n     41  nan        823.103\n     42  nan        840.159\n     43  nan        865.826\n     44  nan        889.637\n     45  nan        891.784\n     46  nan        922.455\n     47  nan        942.382\n     48  nan        950.896\n     49  nan        953.499\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_process/#tuning-curves","title":"Tuning curves","text":"<p>pynapple can compute 1 dimension tuning curves (for example firing rate as a function of angular direction) and 2 dimension tuning curves ( for example firing rate as a function of position). In both cases, a TsGroup object can be directly passed to the function.</p> <p>First we will create the 2D features:</p> <pre><code>dt = 0.1\nfeatures = np.vstack((np.cos(np.arange(0, 1000, dt)), np.sin(np.arange(0, 1000, dt)))).T\n# features += np.random.randn(features.shape[0], features.shape[1])*0.05\nfeatures = nap.TsdFrame(\n    t=np.arange(0, 1000, dt),\n    d=features,\n    time_units=\"s\",\n    time_support=epoch,\n    columns=[\"a\", \"b\"],\n)\n\nprint(features)\n\nplt.figure(figsize=(15, 7))\nplt.subplot(121)\nplt.plot(features[0:100])\nplt.title(\"Features\")\nplt.xlabel(\"Time(s)\")\nplt.subplot(122)\nplt.title(\"Features\")\nplt.plot(features[\"a\"][0:100], features[\"b\"][0:100])\nplt.xlabel(\"Feature a\")\nplt.ylabel(\"Feature b\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>Time (s)           a          b\n----------  --------  ---------\n0.0         1         0\n0.1         0.995004  0.0998334\n0.2         0.980067  0.198669\n0.3         0.955336  0.29552\n0.4         0.921061  0.389418\n...\n999.5       0.889961  0.456036\n999.6       0.839987  0.542606\n999.7       0.781621  0.623754\n999.8       0.715445  0.69867\n999.9       0.64212   0.766604\ndtype: float64, shape: (10000, 2)\n\nText(732.5909090909089, 0.5, 'Feature b')\n</code></pre> <p>Here we call the function <code>compute_2d_tuning_curves</code>. To check the accuracy of the tuning curves, we will display the spikes aligned to the features with the function <code>value_from</code> which assign to each spikes the corresponding feature value for neuron 0.</p> <pre><code>tcurves2d, binsxy = nap.compute_2d_tuning_curves(\n    group=ts_group, feature=features, nb_bins=10\n)\n\nts_to_features = ts_group[1].value_from(features)\n\nplt.figure()\nplt.plot(ts_to_features[\"a\"], ts_to_features[\"b\"], \"o\", color=\"red\", markersize=4)\nextents = (\n    np.min(features[\"b\"]),\n    np.max(features[\"b\"]),\n    np.min(features[\"a\"]),\n    np.max(features[\"a\"]),\n)\nplt.imshow(tcurves2d[1].T, origin=\"lower\", extent=extents, cmap=\"viridis\")\nplt.title(\"Tuning curve unit 0 2d\")\nplt.xlabel(\"feature a\")\nplt.ylabel(\"feature b\")\nplt.grid(False)\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>/mnt/home/gviejo/pynapple/pynapple/process/tuning_curves.py:203: RuntimeWarning: invalid value encountered in divide\n  count = count / occupancy\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_process/#decoding","title":"Decoding","text":"<p>Pynapple supports 1 dimensional and 2 dimensional bayesian decoding. The function returns the decoded feature as well as the probabilities for each timestamps.</p> <p>First we generate some artificial \"place fields\" in 2 dimensions based on the features.</p> <p>This part is just to generate units with a relationship to the features (i.e. \"place fields\")</p> <pre><code>times = features.as_units(\"us\").index.values\nft = features.values\nalpha = np.arctan2(ft[:, 1], ft[:, 0])\nbins = np.repeat(np.linspace(-np.pi, np.pi, 13)[::, np.newaxis], 2, 1)\nbins += np.array([-2 * np.pi / 24, 2 * np.pi / 24])\nts_group = {}\nfor i in range(12):\n    ts = times[(alpha &gt;= bins[i, 0]) &amp; (alpha &lt;= bins[i + 1, 1])]\n    ts_group[i] = nap.Ts(ts, time_units=\"us\")\n\nts_group = nap.TsGroup(ts_group, time_support=epoch)\nprint(ts_group)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate\n-------  ------\n      0    1.25\n      1    1.67\n      2    1.67\n      3    1.66\n      4    1.67\n      5    1.67\n      6    1.67\n      7    1.67\n      8    1.67\n      9    1.67\n     10    1.67\n     11    1.25\n</code></pre> <p>To decode we need to compute tuning curves in 2D.</p> <pre><code>import warnings\n\nwarnings.filterwarnings(\"ignore\")\n\ntcurves2d, binsxy = nap.compute_2d_tuning_curves(\n    group=ts_group,\n    feature=features,\n    nb_bins=10,\n    ep=epoch,\n    minmax=(-1.0, 1.0, -1.0, 1.0),\n)\n</code></pre> <p>Then we plot the \"place fields\".</p> <pre><code>plt.figure(figsize=(20, 9))\nfor i in ts_group.keys():\n    plt.subplot(2, 6, i + 1)\n    plt.imshow(\n        tcurves2d[i], extent=(binsxy[1][0], binsxy[1][-1], binsxy[0][0], binsxy[0][-1])\n    )\n    plt.xticks()\nplt.show()\n</code></pre> <p></p> <p>Then we call the actual decoding function in 2d.</p> <pre><code>decoded, proba_feature = nap.decode_2d(\n    tuning_curves=tcurves2d,\n    group=ts_group,\n    ep=epoch,\n    bin_size=0.1,  # second\n    xy=binsxy,\n    features=features,\n)\n\n\nplt.figure(figsize=(15, 5))\nplt.subplot(131)\nplt.plot(features[\"a\"].as_units(\"s\").loc[0:20], label=\"True\")\nplt.plot(decoded[\"a\"].as_units(\"s\").loc[0:20], label=\"Decoded\")\nplt.legend()\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Feature a\")\nplt.subplot(132)\nplt.plot(features[\"b\"].as_units(\"s\").loc[0:20], label=\"True\")\nplt.plot(decoded[\"b\"].as_units(\"s\").loc[0:20], label=\"Decoded\")\nplt.legend()\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Feature b\")\nplt.subplot(133)\nplt.plot(\n    features[\"a\"].as_units(\"s\").loc[0:20],\n    features[\"b\"].as_units(\"s\").loc[0:20],\n    label=\"True\",\n)\nplt.plot(\n    decoded[\"a\"].as_units(\"s\").loc[0:20],\n    decoded[\"b\"].as_units(\"s\").loc[0:20],\n    label=\"Decoded\",\n)\nplt.xlabel(\"Feature a\")\nplt.ylabel(\"Feature b\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"generated/gallery/tutorial_pynapple_process/#randomization","title":"Randomization","text":"<p>Pynapple provides some ready-to-use randomization methods to compute null distributions for statistical testing. Different methods preserve or destroy different features of the data, here's a brief overview.</p> <p><code>shift_timestamps</code> shifts all the timestamps in a <code>Ts</code> object by the same random amount, wrapping the end of the time support to its beginning. This randomization preserves the temporal structure in the data but destroys the temporal relationships with other quantities (e.g. behavioural data). When applied on a <code>TsGroup</code> object, each series in the group is shifted independently.</p> <pre><code>ts = nap.Ts(t=np.sort(np.random.uniform(0, 100, 10)), time_units=\"ms\")\nrand_ts = nap.shift_timestamps(ts, min_shift=1, max_shift=20)\n</code></pre> <p><code>shuffle_ts_intervals</code> computes the intervals between consecutive timestamps, permutes them, and generates a new set of timestamps with the permuted intervals. This procedure preserve the distribution of intervals, but not their sequence.</p> <pre><code>ts = nap.Ts(t=np.sort(np.random.uniform(0, 100, 10)), time_units=\"s\")\nrand_ts = nap.shuffle_ts_intervals(ts)\n</code></pre> <p><code>jitter_timestamps</code> shifts each timestamp in the data of an independent random amount. When applied with a small <code>max_jitter</code>, this procedure destroys the fine temporal structure of the data, while preserving structure on longer timescales.</p> <pre><code>ts = nap.Ts(t=np.sort(np.random.uniform(0, 100, 10)), time_units=\"s\")\nrand_ts = nap.jitter_timestamps(ts, max_jitter=1)\n</code></pre> <p><code>resample_timestamps</code> uniformly re-draws the same number of timestamps in <code>ts</code>, in the same time support. This procedures preserve the total number of timestamps, but destroys any other feature of the original data.</p> <pre><code>ts = nap.Ts(t=np.sort(np.random.uniform(0, 100, 10)), time_units=\"s\")\nrand_ts = nap.resample_timestamps(ts)\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.856 seconds)</p> <p> Download Python source code: tutorial_pynapple_process.py</p> <p> Download Jupyter notebook: tutorial_pynapple_process.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_pynapple_quick_start/","title":"Quick start","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_pynapple_quick_start/#quick-start","title":"Quick start","text":"<p>The examplar data to replicate the figure in the jupyter notebook can be found here. </p> <p>The data contains a sample recordings taken simultaneously from the anterodorsal thalamus and the hippocampus and contains both a sleep and wake session. It contains both head-direction cells (i.e. cells that fire for a particular head direction in the horizontal plane) and place cells (i.e. cells that fire for a particular position in the environment).</p> <p>Preprocessing of the data was made with Kilosort 2.0 and spike sorting was made with Klusters.</p> <p>Instructions for installing pynapple can be found here.</p> <p>This notebook is meant to provide an overview of pynapple by going through:</p> <ul> <li>Input output (IO). In this case, pynapple will load a NWB file using the NWBFile object within a project Folder that represent a dataset. </li> <li>Core functions that handle time series, interval sets and groups of time series. See this notebook for a detailled usage of the core functions.</li> <li>Process functions. A small collection of high-level functions widely used in system neuroscience. This notebook details those functions.</li> </ul> <p>Warning</p> <p>This tutorial uses seaborn and matplotlib for displaying the figure.</p> <p>You can install both with <code>pip install matplotlib seaborn</code></p> <pre><code>import numpy as np\nimport pandas as pd\nimport pynapple as nap\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ncustom_params = {\"axes.spines.right\": False, \"axes.spines.top\": False}\nsns.set_theme(style=\"ticks\", palette=\"colorblind\", font_scale=1.5, rc=custom_params)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_quick_start/#io","title":"IO","text":"<p>The first step is to give the path to the data folder.</p> <pre><code>DATA_DIRECTORY = \"../../your/path/to/MyProject/\"\n</code></pre> <p>We can load the session with the function load_folder. Pynapple will walks throught the folder and collects every subfolders. We can use the attribute <code>view</code> or the function <code>expand</code> to display a tree view of the dataset. The treeview shows all the compatible data format (i.e npz files or NWBs files) and their equivalent pynapple type.</p> <pre><code>data = nap.load_folder(DATA_DIRECTORY)\ndata.view\n</code></pre> <p>Out:</p> <pre><code>\ud83d\udcc2 MyProject\n\u2514\u2500\u2500 \ud83d\udcc2 sub-A2929\n    \u2514\u2500\u2500 \ud83d\udcc2 ses-A2929-200711\n        \u251c\u2500\u2500 \ud83d\udcc2 derivatives\n        \u2502   \u251c\u2500\u2500 spikes.npz      |        TsGroup\n        \u2502   \u251c\u2500\u2500 sleep_ep.npz    |        IntervalSet\n        \u2502   \u251c\u2500\u2500 position.npz    |        TsdFrame\n        \u2502   \u2514\u2500\u2500 wake_ep.npz     |        IntervalSet\n        \u251c\u2500\u2500 \ud83d\udcc2 pynapplenwb\n        \u2502   \u251c\u2500\u2500 A2929-200711_nc         |        NWB file\n        \u2502   \u2514\u2500\u2500 A2929-200711    |        NWB file\n        \u251c\u2500\u2500 x_plus_1.npz    |        Tsd\n        \u251c\u2500\u2500 x_plus_y.npz    |        Tsd\n        \u2514\u2500\u2500 stimulus-fish.npz       |        IntervalSet\n</code></pre> <p>The object <code>data</code> is a <code>Folder</code> object that allows easy navigation and interaction with a dataset. In this case, we want to load the NWB file in the folder <code>/pynapplenwb</code>. Data are always lazy loaded. No time series is loaded until it's actually called. When calling the NWB file, the object <code>nwb</code> is an interface to the NWB file. All the data inside the NWB file that are compatible with one of the pynapple objects are shown with their corresponding keys.</p> <pre><code>nwb = data[\"sub-A2929\"][\"ses-A2929-200711\"][\"pynapplenwb\"][\"A2929-200711\"]\nprint(nwb)\n</code></pre> <p>Out:</p> <pre><code>A2929-200711\n\u250d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2511\n\u2502 Keys                  \u2502 Type        \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 units                 \u2502 TsGroup     \u2502\n\u2502 position_time_support \u2502 IntervalSet \u2502\n\u2502 epochs                \u2502 IntervalSet \u2502\n\u2502 z                     \u2502 Tsd         \u2502\n\u2502 y                     \u2502 Tsd         \u2502\n\u2502 x                     \u2502 Tsd         \u2502\n\u2502 rz                    \u2502 Tsd         \u2502\n\u2502 ry                    \u2502 Tsd         \u2502\n\u2502 rx                    \u2502 Tsd         \u2502\n\u2515\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2519\n</code></pre> <p>We can individually call each object and they are actually loaded.</p> <p><code>units</code> is a TsGroup object. It allows to group together time series with different timestamps and couple metainformation to each neuron. In this case, the location of where the neuron was recorded has been added when loading the session for the first time. We load <code>units</code> as <code>spikes</code></p> <pre><code>spikes = nwb[\"units\"]\nprint(spikes)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate  location      group\n-------  ------  ----------  -------\n      0    7.3   adn               0\n      1    5.73  adn               0\n      2    8.12  adn               0\n      3    6.68  adn               0\n      4   10.77  adn               0\n      5   11     adn               0\n      6   16.52  adn               0\n      7    2.2   ca1               1\n      8    2.02  ca1               1\n      9    1.07  ca1               1\n     10    3.92  ca1               1\n     11    3.31  ca1               1\n     12    1.09  ca1               1\n     13    1.28  ca1               1\n     14    1.32  ca1               1\n</code></pre> <p>In this case, the TsGroup holds 15 neurons and it is possible to access, similar to a dictionnary, the spike times of a single neuron:</p> <pre><code>neuron_0 = spikes[0]\nprint(neuron_0)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n0.00845\n0.03265\n0.1323\n0.3034\n0.329\n...\n1186.12755\n1189.384\n1194.13475\n1196.2075\n1196.67675\nshape: 8764\n</code></pre> <p><code>neuron_0</code> is a Ts object containing the times of the spikes.</p> <p>The other information about the session is contained in <code>nwb[\"epochs\"]</code>. In this case, the start and end of the sleep and wake epochs. If the NWB time intervals contains tags of the epochs, pynapple will try to group them together and return a dictionnary of IntervalSet instead of IntervalSet.</p> <pre><code>epochs = nwb[\"epochs\"]\nprint(epochs)\n</code></pre> <p>Out:</p> <pre><code>{'sleep':    start    end\n0    0.0  600.0, 'wake':    start     end\n0  600.0  1200.0}\n</code></pre> <p>Finally this dataset contains tracking of the animal in the environment. <code>rx</code>, <code>ry</code>, <code>rz</code> represent respectively the roll, the yaw and the pitch of the head of the animal. <code>x</code> and <code>z</code> represent the position of the animal in the horizontal plane while <code>y</code> represents the elevation. Here we load only the head-direction as a Tsd object.</p> <pre><code>head_direction = nwb[\"ry\"]\nprint(head_direction)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  -------\n670.6407    5.20715\n670.649     5.18103\n670.65735   5.15551\n670.66565   5.13654\n670.674     5.12085\n...\n1199.9616   3.66595\n1199.96995  3.63462\n1199.97825  3.61785\n1199.9866   3.60945\n1199.99495  3.60938\ndtype: float64, shape: (63527,)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_quick_start/#core","title":"Core","text":"<p>The core functions of pynapple provides many ways to manipulate time series. In this example, spike times are restricted to the wake epoch. Notice how the frequencies change from the original object.</p> <pre><code>wake_ep = epochs[\"wake\"]\n\nspikes_wake = spikes.restrict(wake_ep)\nprint(spikes_wake)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate  location      group\n-------  ------  ----------  -------\n      0    4.85  adn               0\n      1    8.06  adn               0\n      2    7.11  adn               0\n      3    7.66  adn               0\n      4    7.97  adn               0\n      5   11.29  adn               0\n      6   22.08  adn               0\n      7    1.82  ca1               1\n      8    2.84  ca1               1\n      9    0.7   ca1               1\n     10    4.78  ca1               1\n     11    4.93  ca1               1\n     12    1.71  ca1               1\n     13    0.97  ca1               1\n     14    0.26  ca1               1\n</code></pre> <p>The same operation can be applied to all time series.</p> <pre><code># In this example, we want all the epochs for which position in `x` is above a certain threhsold. For this we use the function `threshold`.\nposx = nwb[\"x\"]\n\nthreshold = 0.08\n\nposxpositive = posx.threshold(threshold)\n\nplt.figure()\nplt.plot(posx)\nplt.plot(posxpositive, \".\")\nplt.axhline(threshold)\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"x\")\nplt.title(\"x &gt; {}\".format(threshold))\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>The epochs above the threshold can be accessed through the time support of the Tsd object. The time support is an important concept in the pynapple package. It helps the user to define the epochs for which the time serie should be defined. By default, Ts, Tsd and TsGroup objects possess a time support (defined as an IntervalSet). It is recommended to pass the time support when instantiating one of those objects.</p> <pre><code>epochs_above_thr = posxpositive.time_support\nprint(epochs_above_thr)\n</code></pre> <p>Out:</p> <pre><code>        start         end\n0  682.660850  745.565725\n1  752.240350  752.440325\n2  752.582000  752.673650\n3  757.498375  758.998300\n4  789.863275  790.271575\n5  875.225250  876.066875\n6  878.158425  878.641725\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_quick_start/#tuning-curves","title":"Tuning curves","text":"<p>Let's do a more advanced analysis. Neurons from ADn (group 0 in the <code>spikes</code> group object) are know to fire for a particular direction. Therefore, we can compute their tuning curves, i.e. their firing rates as a function of the head-direction of the animal in the horizontal plane (ry). To do this, we can use the function <code>compute_1d_tuning_curves</code>. In this case, the tuning curves are computed over 120 bins and between 0 and 2$\\pi$.</p> <pre><code>tuning_curves = nap.compute_1d_tuning_curves(\n    group=spikes, feature=head_direction, nb_bins=121, minmax=(0, 2 * np.pi)\n)\n\nprint(tuning_curves)\n</code></pre> <p>Out:</p> <pre><code>                 0    1         2   ...         12        13        14\n0.025964  45.520459  0.0  0.000000  ...  14.483782  0.000000  2.069112\n0.077891  55.049762  0.0  0.000000  ...   1.100995  0.000000  0.000000\n0.129818  76.369034  0.0  0.000000  ...   9.351310  1.558552  0.000000\n0.181745  82.179721  0.0  0.000000  ...   9.131080  2.608880  0.000000\n0.233672  73.851374  0.0  0.000000  ...   7.912647  2.637549  0.000000\n...             ...  ...       ...  ...        ...       ...       ...\n6.049513  15.001060  0.0  0.000000  ...   0.000000  0.000000  1.363733\n6.101440  22.327159  0.0  0.000000  ...   2.790895  0.000000  0.000000\n6.153367  47.062150  0.0  0.000000  ...   0.000000  2.353107  0.000000\n6.205295  56.003958  0.0  2.000141  ...   6.000424  0.000000  0.000000\n6.257222  38.712414  0.0  0.000000  ...   7.742483  0.000000  0.000000\n\n[121 rows x 15 columns]\n</code></pre> <p>We can plot tuning curves in polar plots.</p> <pre><code>neuron_location = spikes.get_info(\"location\")  # to know where the neuron was recorded\nplt.figure(figsize=(12, 9))\n\nfor i, n in enumerate(tuning_curves.columns):\n    plt.subplot(3, 5, i + 1, projection=\"polar\")\n    plt.plot(tuning_curves[n])\n    plt.title(neuron_location[n] + \"-\" + str(n), fontsize=18)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>While ADN neurons show obvious modulation for head-direction, it is not obvious for all CA1 cells. Therefore we want to restrict the remaining of the analyses to only ADN neurons. We can split the <code>spikes</code> group with the function <code>getby_category</code>.</p> <pre><code>spikes_by_location = spikes.getby_category(\"location\")\n\nprint(spikes_by_location[\"adn\"])\nprint(spikes_by_location[\"ca1\"])\n\nspikes_adn = spikes_by_location[\"adn\"]\n</code></pre> <p>Out:</p> <pre><code>  Index    rate  location      group\n-------  ------  ----------  -------\n      0    7.3   adn               0\n      1    5.73  adn               0\n      2    8.12  adn               0\n      3    6.68  adn               0\n      4   10.77  adn               0\n      5   11     adn               0\n      6   16.52  adn               0\n  Index    rate  location      group\n-------  ------  ----------  -------\n      7    2.2   ca1               1\n      8    2.02  ca1               1\n      9    1.07  ca1               1\n     10    3.92  ca1               1\n     11    3.31  ca1               1\n     12    1.09  ca1               1\n     13    1.28  ca1               1\n     14    1.32  ca1               1\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_quick_start/#correlograms","title":"Correlograms","text":"<p>A classical question with head-direction cells is how pairs stay coordinated across brain states i.e. wake vs sleep (see Peyrache, A., Lacroix, M. M., Petersen, P. C., &amp; Buzs\u00e1ki, G. (2015). Internally organized mechanisms of the head direction sense. Nature neuroscience, 18(4), 569-575.)</p> <p>In this example, this coordination across brain states will be evaluated with cross-correlograms of pairs of neurons. We can call the function <code>compute_crosscorrelogram</code> during both sleep and wake epochs.</p> <pre><code>cc_wake = nap.compute_crosscorrelogram(\n    group=spikes_adn,\n    binsize=20,  # ms\n    windowsize=4000,  # ms\n    ep=epochs[\"wake\"],\n    norm=True,\n    time_units=\"ms\",\n)\n\ncc_sleep = nap.compute_crosscorrelogram(\n    group=spikes_adn,\n    binsize=5,  # ms\n    windowsize=400,  # ms\n    ep=epochs[\"sleep\"],\n    norm=True,\n    time_units=\"ms\",\n)\n</code></pre> <p>From the previous figure, we can see that neurons 0 and 1 fires for opposite directions during wake. Therefore we expect their cross-correlograms to show a trough around 0 time lag, meaning those two neurons do not fire spikes together. A similar trough during sleep for the same pair thus indicates a persistence of their coordination even if the animal is not moving its head. mkdocs_gallery_thumbnail_number = 3</p> <pre><code>xtwake = cc_wake.index.values\nxtsleep = cc_sleep.index.values\n\nplt.figure(figsize=(15, 5))\nplt.subplot(131, projection=\"polar\")\nplt.plot(tuning_curves[[0, 1]])  # The tuning curves of the pair [0,1]\nplt.subplot(132)\nplt.fill_between(\n    xtwake, np.zeros_like(xtwake), cc_wake[(0, 1)].values, color=\"darkgray\"\n)\nplt.title(\"wake\")\nplt.xlabel(\"Time (ms)\")\nplt.ylabel(\"CC\")\nplt.subplot(133)\nplt.fill_between(\n    xtsleep, np.zeros_like(xtsleep), cc_sleep[(0, 1)].values, color=\"lightgrey\"\n)\nplt.title(\"sleep\")\nplt.xlabel(\"Time (ms)\")\nplt.ylabel(\"CC\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"generated/gallery/tutorial_pynapple_quick_start/#decoding","title":"Decoding","text":"<p>This last analysis shows how to use the pynapple's decoding function.</p> <p>The previous result indicates a persistent coordination of head-direction cells during sleep. Therefore it is possible to decode a virtual head-direction signal even if the animal is not moving its head. This example uses the function <code>decode_1d</code> which implements bayesian decoding (see : Zhang, K., Ginzburg, I., McNaughton, B. L., &amp; Sejnowski, T. J. (1998). Interpreting neuronal population activity by reconstruction: unified framework with application to hippocampal place cells. Journal of neurophysiology, 79(2), 1017-1044.)</p> <p>First we can validate the decoding function with the real position of the head of the animal during wake.</p> <pre><code>tuning_curves_adn = nap.compute_1d_tuning_curves(\n    spikes_adn, head_direction, nb_bins=61, minmax=(0, 2 * np.pi)\n)\n\ndecoded, proba_angle = nap.decode_1d(\n    tuning_curves=tuning_curves_adn,\n    group=spikes_adn,\n    ep=epochs[\"wake\"],\n    bin_size=0.3,  # second\n    feature=head_direction,\n)\nprint(decoded)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  -------\n600.15      2.11156\n600.45      2.11156\n600.75      2.31757\n601.05      2.00856\n601.35      2.11156\n...\n1198.65     4.58364\n1198.95     4.27463\n1199.25     4.58364\n1199.55     4.58364\n1199.85     3.86261\ndtype: float64, shape: (2000,)\n</code></pre> <p>We can plot the decoded head-direction along with the true head-direction.</p> <pre><code>plt.figure(figsize=(20, 5))\nplt.plot(head_direction.as_units(\"s\"), label=\"True\")\nplt.plot(decoded.as_units(\"s\"), label=\"Decoded\")\nplt.legend()\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Head-direction (rad)\")\nplt.show()\n</code></pre> <p></p>"},{"location":"generated/gallery/tutorial_pynapple_quick_start/#raster","title":"Raster","text":"<p>Finally we can decode activity during sleep and overlay spiking activity of ADN neurons as a raster plot (in this case only during the first 4 seconds). Pynapple return as well the probability of being in a particular state. We can display it next to the spike train.</p> <p>First let's decode during sleep with a bin size of 40 ms.</p> <pre><code>decoded_sleep, proba_angle_Sleep = nap.decode_1d(\n    tuning_curves=tuning_curves_adn,\n    group=spikes_adn,\n    ep=epochs[\"sleep\"],\n    bin_size=0.04,  # second\n    feature=head_direction,\n)\n</code></pre> <p>Here we are gonna chain the TsGroup function <code>set_info</code> and the function <code>to_tsd</code> to flatten the TsGroup and quickly assign to each spikes a corresponding value found in the metadata table. Any columns of the metadata table can be assigned to timestamps in a TsGroup.</p> <p>Here the value assign to the spikes comes from the preferred firing direction of the neurons. The following line is a quick way to sort the neurons based on their preferred firing direction</p> <pre><code>order = np.argsort(np.argmax(tuning_curves_adn.values, 0))\nprint(order)\n</code></pre> <p>Out:</p> <pre><code>[0 4 2 6 1 3 5]\n</code></pre> <p>Assigning order as a metadata of TsGroup</p> <pre><code>spikes_adn.set_info(order=order)\nprint(spikes_adn)\n</code></pre> <p>Out:</p> <pre><code>  Index    rate  location      group    order\n-------  ------  ----------  -------  -------\n      0    7.3   adn               0        0\n      1    5.73  adn               0        4\n      2    8.12  adn               0        2\n      3    6.68  adn               0        6\n      4   10.77  adn               0        1\n      5   11     adn               0        3\n      6   16.52  adn               0        5\n</code></pre> <p>\"Flattening\" the TsGroup to a Tsd based on <code>order</code>. It's then very easy to call plot on <code>tsd_adn</code> to display the raster</p> <pre><code>tsd_adn = spikes_adn.to_tsd(\"order\")\nprint(tsd_adn)\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --\n0.00845      0\n0.03265      0\n0.07745      6\n0.1323       0\n0.14045      5\n...\n1199.9065    5\n1199.91745   5\n1199.94065   5\n1199.95035   5\n1199.96795   5\ndtype: float64, shape: (79349,)\n</code></pre> <p>Plotting everything</p> <pre><code>subep = nap.IntervalSet(start=0, end=10, time_units=\"s\")\n\nplt.figure(figsize=(19, 10))\nplt.subplot(211)\nplt.plot(tsd_adn.restrict(subep), \"|\", markersize=20)\nplt.xlim(subep.start[0], subep.end[0])\nplt.ylabel(\"Order\")\nplt.title(\"Decoding during sleep\")\nplt.subplot(212)\np = proba_angle_Sleep.restrict(subep)\nplt.imshow(p.values.T, aspect=\"auto\", origin=\"lower\", cmap=\"viridis\")\nplt.title(\"Probability\")\nplt.xticks([0, p.shape[0] - 1], subep.values[0])\nplt.yticks([0, p.shape[1]], [\"0\", \"360\"])\nplt.legend()\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Head-direction (deg)\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Out:</p> <pre><code>No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\nNo artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n</code></pre> <p>Total running time of the script: ( 0 minutes  6.402 seconds)</p> <p> Download Python source code: tutorial_pynapple_quick_start.py</p> <p> Download Jupyter notebook: tutorial_pynapple_quick_start.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"reference/","title":"Modules","text":"<ul> <li>core<ul> <li>interval_set</li> <li>time_index</li> <li>time_series</li> <li>time_units</li> <li>ts_group</li> </ul> </li> <li>io<ul> <li>cnmfe</li> <li>folder</li> <li>interface_npz</li> <li>interface_nwb</li> <li>loader</li> <li>misc</li> <li>neurosuite</li> <li>phy</li> <li>suite2p</li> </ul> </li> <li>process<ul> <li>correlograms</li> <li>decoding</li> <li>perievent</li> <li>randomize</li> <li>tuning_curves</li> </ul> </li> </ul>"},{"location":"reference/core/","title":"Core","text":"<ul> <li>interval_set</li> <li>time_index</li> <li>time_series</li> <li>time_units</li> <li>ts_group</li> </ul>"},{"location":"reference/core/interval_set/","title":"Interval set","text":""},{"location":"reference/core/interval_set/#pynapple.core.interval_set","title":"pynapple.core.interval_set","text":""},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet","title":"IntervalSet","text":"<p>             Bases: <code>DataFrame</code></p> <p>A subclass of pandas.DataFrame representing a (irregular) set of time intervals in elapsed time, with relative operations</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>class IntervalSet(pd.DataFrame):\n    # class IntervalSet():\n    \"\"\"\n    A subclass of pandas.DataFrame representing a (irregular) set of time intervals in elapsed time, with relative operations\n    \"\"\"\n\n    def __init__(self, start, end=None, time_units=\"s\", **kwargs):\n        \"\"\"\n        IntervalSet initializer\n\n        If start and end and not aligned, meaning that \\n\n        1. len(start) != len(end)\n        2. end[i] &gt; start[i]\n        3. start[i+1] &gt; end[i]\n        4. start and end are not sorted,\n\n        IntervalSet will try to \"fix\" the data by eliminating some of the start and end data point\n\n        Parameters\n        ----------\n        start : numpy.ndarray or number or pandas.DataFrame\n            Beginning of intervals\n        end : numpy.ndarray or number, optional\n            Ends of intervals\n        time_units : str, optional\n            Time unit of the intervals ('us', 'ms', 's' [default])\n        **kwargs\n            Additional parameters passed ot pandas.DataFrame\n\n        Returns\n        -------\n        IntervalSet\n            _\n\n        Raises\n        ------\n        RuntimeError\n            Description\n        ValueError\n            If a pandas.DataFrame is passed, it should contains\n            a column 'start' and a column 'end'.\n\n        \"\"\"\n\n        if end is None:\n            df = pd.DataFrame(start)\n            if \"start\" not in df.columns or \"end\" not in df.columns:\n                raise ValueError(\"wrong columns name\")\n            start = df[\"start\"].values.astype(np.float64)\n            end = df[\"end\"].values.astype(np.float64)\n\n            start = TsIndex.sort_timestamps(\n                TsIndex.format_timestamps(start.ravel(), time_units)\n            )\n            end = TsIndex.sort_timestamps(\n                TsIndex.format_timestamps(end.ravel(), time_units)\n            )\n\n            data, to_warn = jitfix_iset(start, end)\n            if np.any(to_warn):\n                msg = \"\\n\".join(all_warnings[to_warn])\n                warnings.warn(msg, stacklevel=2)\n            super().__init__(data=data, columns=(\"start\", \"end\"), **kwargs)\n            self.r_cache = None\n            self._metadata = [\"nap_class\"]\n            self.nap_class = self.__class__.__name__\n            return\n\n        start = np.array(start).astype(np.float64)\n        end = np.array(end).astype(np.float64)\n\n        start = TsIndex.format_timestamps(np.array(start).ravel(), time_units)\n        end = TsIndex.format_timestamps(np.array(end).ravel(), time_units)\n\n        if len(start) != len(end):\n            raise RuntimeError(\"Starts end ends are not of the same length\")\n\n        if not (np.diff(start) &gt; 0).all():\n            warnings.warn(\"start is not sorted.\", stacklevel=2)\n            start = np.sort(start)\n\n        if not (np.diff(end) &gt; 0).all():\n            warnings.warn(\"end is not sorted.\", stacklevel=2)\n            end = np.sort(end)\n\n        data, to_warn = jitfix_iset(start, end)\n\n        if np.any(to_warn):\n            msg = \"\\n\".join(all_warnings[to_warn])\n            warnings.warn(msg, stacklevel=2)\n\n        super().__init__(data=data, columns=(\"start\", \"end\"), **kwargs)\n        self.r_cache = None\n        # self._metadata = [\"nap_class\"]\n        self.nap_class = self.__class__.__name__\n\n    def __repr__(self):\n        return self.as_units(\"s\").__repr__()\n\n    def __str__(self):\n        return self.__repr__()\n\n    def time_span(self):\n        \"\"\"\n        Time span of the interval set.\n\n        Returns\n        -------\n        out: IntervalSet\n            an IntervalSet with a single interval encompassing the whole IntervalSet\n        \"\"\"\n        s = self[\"start\"][0]\n        e = self[\"end\"].iloc[-1]\n        return IntervalSet(s, e)\n\n    def tot_length(self, time_units=\"s\"):\n        \"\"\"\n        Total elapsed time in the set.\n\n        Parameters\n        ----------\n        time_units : None, optional\n            The time units to return the result in ('us', 'ms', 's' [default])\n\n        Returns\n        -------\n        out: float\n            _\n        \"\"\"\n        tot_l = (self[\"end\"] - self[\"start\"]).sum()\n        return TsIndex.return_timestamps(np.array([tot_l]), time_units)[0]\n\n    def intersect(self, a):\n        \"\"\"\n        set intersection of IntervalSet\n\n        Parameters\n        ----------\n        a : IntervalSet\n            the IntervalSet to intersect self with\n\n        Returns\n        -------\n        out: IntervalSet\n            _\n        \"\"\"\n        start1 = self.values[:, 0]\n        end1 = self.values[:, 1]\n        start2 = a.values[:, 0]\n        end2 = a.values[:, 1]\n        s, e = jitintersect(start1, end1, start2, end2)\n        return IntervalSet(s, e)\n\n    def union(self, a):\n        \"\"\"\n        set union of IntervalSet\n\n        Parameters\n        ----------\n        a : IntervalSet\n            the IntervalSet to union self with\n\n        Returns\n        -------\n        out: IntervalSet\n            _\n        \"\"\"\n        start1 = self.values[:, 0]\n        end1 = self.values[:, 1]\n        start2 = a.values[:, 0]\n        end2 = a.values[:, 1]\n        s, e = jitunion(start1, end1, start2, end2)\n        return IntervalSet(s, e)\n\n    def set_diff(self, a):\n        \"\"\"\n        set difference of IntervalSet\n\n        Parameters\n        ----------\n        a : IntervalSet\n            the IntervalSet to set-substract from self\n\n        Returns\n        -------\n        out: IntervalSet\n            _\n        \"\"\"\n        start1 = self.values[:, 0]\n        end1 = self.values[:, 1]\n        start2 = a.values[:, 0]\n        end2 = a.values[:, 1]\n        s, e = jitdiff(start1, end1, start2, end2)\n        return IntervalSet(s, e)\n\n    def in_interval(self, tsd):\n        \"\"\"\n        finds out in which element of the interval set each point in a time series fits.\n\n        NaNs for those that don't fit an interval\n\n        Parameters\n        ----------\n        tsd : Tsd\n            The tsd to be binned\n\n        Returns\n        -------\n        out: numpy.ndarray\n            an array with the interval index labels for each time stamp (NaN) for timestamps not in IntervalSet\n        \"\"\"\n        times = tsd.index\n        starts = self.values[:, 0]\n        ends = self.values[:, 1]\n\n        return jitin_interval(times, starts, ends)\n\n    def drop_short_intervals(self, threshold, time_units=\"s\"):\n        \"\"\"\n        Drops the short intervals in the interval set.\n\n        Parameters\n        ----------\n        threshold : numeric\n            Time threshold for \"short\" intervals\n        time_units : None, optional\n            The time units for the treshold ('us', 'ms', 's' [default])\n\n        Returns\n        -------\n        out: IntervalSet\n            A copied IntervalSet with the dropped intervals\n        \"\"\"\n        threshold = TsIndex.format_timestamps(\n            np.array([threshold], dtype=np.float64), time_units\n        )[0]\n        return self.loc[(self[\"end\"] - self[\"start\"]) &gt; threshold].reset_index(\n            drop=True\n        )\n\n    def drop_long_intervals(self, threshold, time_units=\"s\"):\n        \"\"\"\n        Drops the long intervals in the interval set.\n\n        Parameters\n        ----------\n        threshold : numeric\n            Time threshold for \"long\" intervals\n        time_units : None, optional\n            The time units for the treshold ('us', 'ms', 's' [default])\n\n        Returns\n        -------\n        out: IntervalSet\n            A copied IntervalSet with the dropped intervals\n        \"\"\"\n        threshold = TsIndex.format_timestamps(\n            np.array([threshold], dtype=np.float64), time_units\n        )[0]\n        return self.loc[(self[\"end\"] - self[\"start\"]) &lt; threshold].reset_index(\n            drop=True\n        )\n\n    def as_units(self, units=\"s\"):\n        \"\"\"\n        returns a DataFrame with time expressed in the desired unit\n\n        Parameters\n        ----------\n        units : None, optional\n            'us', 'ms', or 's' [default]\n\n        Returns\n        -------\n        out: pandas.DataFrame\n            DataFrame with adjusted times\n        \"\"\"\n\n        data = self.values.copy()\n        data = TsIndex.return_timestamps(data, units)\n        if units == \"us\":\n            data = data.astype(np.int64)\n\n        df = pd.DataFrame(index=self.index.values, data=data, columns=self.columns)\n\n        return df\n\n    def merge_close_intervals(self, threshold, time_units=\"s\"):\n        \"\"\"\n        Merges intervals that are very close.\n\n        Parameters\n        ----------\n        threshold : numeric\n            time threshold for the closeness of the intervals\n        time_units : None, optional\n            time units for the threshold ('us', 'ms', 's' [default])\n\n        Returns\n        -------\n        out: IntervalSet\n            a copied IntervalSet with merged intervals\n\n        \"\"\"\n        if len(self) == 0:\n            return IntervalSet(start=[], end=[])\n\n        threshold = TsIndex.format_timestamps(\n            np.array((threshold,), dtype=np.float64).ravel(), time_units\n        )[0]\n        start = self[\"start\"].values\n        end = self[\"end\"].values\n        tojoin = (start[1:] - end[0:-1]) &gt; threshold\n        start = np.hstack((start[0], start[1:][tojoin]))\n        end = np.hstack((end[0:-1][tojoin], end[-1]))\n\n        return IntervalSet(start=start, end=end)\n\n    def get_intervals_center(self, alpha=0.5):\n        \"\"\"\n        Returns by default the centers of each intervals.\n\n        It is possible to bias the midpoint by changing the alpha parameter between [0, 1]\n        For each epoch:\n        t = start + (end-start)*alpha\n\n        Parameters\n        ----------\n        alpha : float, optional\n            The midpoint within each interval.\n\n        Returns\n        -------\n        Ts\n            Timestamps object\n        \"\"\"\n        time_series = importlib.import_module(\".time_series\", \"pynapple.core\")\n        starts = self.values[:, 0]\n        ends = self.values[:, 1]\n\n        if not isinstance(alpha, float):\n            raise RuntimeError(\"Parameter alpha should be float type\")\n\n        alpha = np.clip(alpha, 0, 1)\n        t = starts + (ends - starts) * alpha\n        return time_series.Ts(t=t, time_support=self)\n\n    def save(self, filename):\n        \"\"\"\n        Save IntervalSet object in npz format. The file will contain the starts and ends.\n\n        The main purpose of this function is to save small/medium sized IntervalSet\n        objects. For example, you determined some epochs for one session that you want to save\n        to avoid recomputing them.\n\n        You can load the object with numpy.load. Keys are 'start', 'end' and 'type'.\n        See the example below.\n\n        Parameters\n        ----------\n        filename : str\n            The filename\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; ep = nap.IntervalSet(start=[0, 10, 20], end=[5, 12, 33])\n        &gt;&gt;&gt; ep.save(\"my_ep.npz\")\n\n        Here I can retrieve my data with numpy directly:\n\n        &gt;&gt;&gt; file = np.load(\"my_ep.npz\")\n        &gt;&gt;&gt; print(list(file.keys()))\n        ['start', 'end', 'type']\n        &gt;&gt;&gt; print(file['start'])\n        [0. 10. 20.]\n\n        It is then easy to recreate the IntervalSet object.\n        &gt;&gt;&gt; nap.IntervalSet(file['start'], file['end'])\n           start   end\n        0    0.0   5.0\n        1   10.0  12.0\n        2   20.0  33.0\n\n        Raises\n        ------\n        RuntimeError\n            If filename is not str, path does not exist or filename is a directory.\n        \"\"\"\n        if not isinstance(filename, str):\n            raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n        if os.path.isdir(filename):\n            raise RuntimeError(\n                \"Invalid filename input. {} is directory.\".format(filename)\n            )\n\n        if not filename.lower().endswith(\".npz\"):\n            filename = filename + \".npz\"\n\n        dirname = os.path.dirname(filename)\n\n        if len(dirname) and not os.path.exists(dirname):\n            raise RuntimeError(\n                \"Path {} does not exist.\".format(os.path.dirname(filename))\n            )\n\n        np.savez(\n            filename,\n            start=self.start.values,\n            end=self.end.values,\n            type=np.array([\"IntervalSet\"], dtype=np.str_),\n        )\n\n        return\n\n    @property\n    def _constructor(self):\n        return IntervalSet\n\n    @property\n    def starts(self):\n        \"\"\"Return the starts of the IntervalSet as a Ts object\n\n        Returns\n        -------\n        Ts\n            The starts of the IntervalSet\n        \"\"\"\n        time_series = importlib.import_module(\".time_series\", \"pynapple.core\")\n        return time_series.Ts(t=self.values[:, 0], time_support=self)\n\n    @property\n    def ends(self):\n        \"\"\"Return the ends of the IntervalSet as a Ts object\n\n        Returns\n        -------\n        Ts\n            The ends of the IntervalSet\n        \"\"\"\n        time_series = importlib.import_module(\".time_series\", \"pynapple.core\")\n        return time_series.Ts(t=self.values[:, 1], time_support=self)\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.starts","title":"starts  <code>property</code>","text":"<pre><code>starts\n</code></pre> <p>Return the starts of the IntervalSet as a Ts object</p> <p>Returns:</p> Type Description <code>Ts</code> <p>The starts of the IntervalSet</p>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.ends","title":"ends  <code>property</code>","text":"<pre><code>ends\n</code></pre> <p>Return the ends of the IntervalSet as a Ts object</p> <p>Returns:</p> Type Description <code>Ts</code> <p>The ends of the IntervalSet</p>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.__init__","title":"__init__","text":"<pre><code>__init__(start, end=None, time_units='s', **kwargs)\n</code></pre> <p>IntervalSet initializer</p> <p>If start and end and not aligned, meaning that </p> <ol> <li>len(start) != len(end)</li> <li>end[i] &gt; start[i]</li> <li>start[i+1] &gt; end[i]</li> <li>start and end are not sorted,</li> </ol> <p>IntervalSet will try to \"fix\" the data by eliminating some of the start and end data point</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>ndarray or number or DataFrame</code> <p>Beginning of intervals</p> required <code>end</code> <code>ndarray or number</code> <p>Ends of intervals</p> <code>None</code> <code>time_units</code> <code>str</code> <p>Time unit of the intervals ('us', 'ms', 's' [default])</p> <code>'s'</code> <code>**kwargs</code> <p>Additional parameters passed ot pandas.DataFrame</p> <code>{}</code> <p>Returns:</p> Type Description <code>IntervalSet</code> <p>_</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Description</p> <code>ValueError</code> <p>If a pandas.DataFrame is passed, it should contains a column 'start' and a column 'end'.</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def __init__(self, start, end=None, time_units=\"s\", **kwargs):\n    \"\"\"\n    IntervalSet initializer\n\n    If start and end and not aligned, meaning that \\n\n    1. len(start) != len(end)\n    2. end[i] &gt; start[i]\n    3. start[i+1] &gt; end[i]\n    4. start and end are not sorted,\n\n    IntervalSet will try to \"fix\" the data by eliminating some of the start and end data point\n\n    Parameters\n    ----------\n    start : numpy.ndarray or number or pandas.DataFrame\n        Beginning of intervals\n    end : numpy.ndarray or number, optional\n        Ends of intervals\n    time_units : str, optional\n        Time unit of the intervals ('us', 'ms', 's' [default])\n    **kwargs\n        Additional parameters passed ot pandas.DataFrame\n\n    Returns\n    -------\n    IntervalSet\n        _\n\n    Raises\n    ------\n    RuntimeError\n        Description\n    ValueError\n        If a pandas.DataFrame is passed, it should contains\n        a column 'start' and a column 'end'.\n\n    \"\"\"\n\n    if end is None:\n        df = pd.DataFrame(start)\n        if \"start\" not in df.columns or \"end\" not in df.columns:\n            raise ValueError(\"wrong columns name\")\n        start = df[\"start\"].values.astype(np.float64)\n        end = df[\"end\"].values.astype(np.float64)\n\n        start = TsIndex.sort_timestamps(\n            TsIndex.format_timestamps(start.ravel(), time_units)\n        )\n        end = TsIndex.sort_timestamps(\n            TsIndex.format_timestamps(end.ravel(), time_units)\n        )\n\n        data, to_warn = jitfix_iset(start, end)\n        if np.any(to_warn):\n            msg = \"\\n\".join(all_warnings[to_warn])\n            warnings.warn(msg, stacklevel=2)\n        super().__init__(data=data, columns=(\"start\", \"end\"), **kwargs)\n        self.r_cache = None\n        self._metadata = [\"nap_class\"]\n        self.nap_class = self.__class__.__name__\n        return\n\n    start = np.array(start).astype(np.float64)\n    end = np.array(end).astype(np.float64)\n\n    start = TsIndex.format_timestamps(np.array(start).ravel(), time_units)\n    end = TsIndex.format_timestamps(np.array(end).ravel(), time_units)\n\n    if len(start) != len(end):\n        raise RuntimeError(\"Starts end ends are not of the same length\")\n\n    if not (np.diff(start) &gt; 0).all():\n        warnings.warn(\"start is not sorted.\", stacklevel=2)\n        start = np.sort(start)\n\n    if not (np.diff(end) &gt; 0).all():\n        warnings.warn(\"end is not sorted.\", stacklevel=2)\n        end = np.sort(end)\n\n    data, to_warn = jitfix_iset(start, end)\n\n    if np.any(to_warn):\n        msg = \"\\n\".join(all_warnings[to_warn])\n        warnings.warn(msg, stacklevel=2)\n\n    super().__init__(data=data, columns=(\"start\", \"end\"), **kwargs)\n    self.r_cache = None\n    # self._metadata = [\"nap_class\"]\n    self.nap_class = self.__class__.__name__\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.time_span","title":"time_span","text":"<pre><code>time_span()\n</code></pre> <p>Time span of the interval set.</p> <p>Returns:</p> Name Type Description <code>out</code> <code>IntervalSet</code> <p>an IntervalSet with a single interval encompassing the whole IntervalSet</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def time_span(self):\n    \"\"\"\n    Time span of the interval set.\n\n    Returns\n    -------\n    out: IntervalSet\n        an IntervalSet with a single interval encompassing the whole IntervalSet\n    \"\"\"\n    s = self[\"start\"][0]\n    e = self[\"end\"].iloc[-1]\n    return IntervalSet(s, e)\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.tot_length","title":"tot_length","text":"<pre><code>tot_length(time_units='s')\n</code></pre> <p>Total elapsed time in the set.</p> <p>Parameters:</p> Name Type Description Default <code>time_units</code> <code>None</code> <p>The time units to return the result in ('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float</code> <p>_</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def tot_length(self, time_units=\"s\"):\n    \"\"\"\n    Total elapsed time in the set.\n\n    Parameters\n    ----------\n    time_units : None, optional\n        The time units to return the result in ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: float\n        _\n    \"\"\"\n    tot_l = (self[\"end\"] - self[\"start\"]).sum()\n    return TsIndex.return_timestamps(np.array([tot_l]), time_units)[0]\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.intersect","title":"intersect","text":"<pre><code>intersect(a)\n</code></pre> <p>set intersection of IntervalSet</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>IntervalSet</code> <p>the IntervalSet to intersect self with</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>IntervalSet</code> <p>_</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def intersect(self, a):\n    \"\"\"\n    set intersection of IntervalSet\n\n    Parameters\n    ----------\n    a : IntervalSet\n        the IntervalSet to intersect self with\n\n    Returns\n    -------\n    out: IntervalSet\n        _\n    \"\"\"\n    start1 = self.values[:, 0]\n    end1 = self.values[:, 1]\n    start2 = a.values[:, 0]\n    end2 = a.values[:, 1]\n    s, e = jitintersect(start1, end1, start2, end2)\n    return IntervalSet(s, e)\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.union","title":"union","text":"<pre><code>union(a)\n</code></pre> <p>set union of IntervalSet</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>IntervalSet</code> <p>the IntervalSet to union self with</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>IntervalSet</code> <p>_</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def union(self, a):\n    \"\"\"\n    set union of IntervalSet\n\n    Parameters\n    ----------\n    a : IntervalSet\n        the IntervalSet to union self with\n\n    Returns\n    -------\n    out: IntervalSet\n        _\n    \"\"\"\n    start1 = self.values[:, 0]\n    end1 = self.values[:, 1]\n    start2 = a.values[:, 0]\n    end2 = a.values[:, 1]\n    s, e = jitunion(start1, end1, start2, end2)\n    return IntervalSet(s, e)\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.set_diff","title":"set_diff","text":"<pre><code>set_diff(a)\n</code></pre> <p>set difference of IntervalSet</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>IntervalSet</code> <p>the IntervalSet to set-substract from self</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>IntervalSet</code> <p>_</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def set_diff(self, a):\n    \"\"\"\n    set difference of IntervalSet\n\n    Parameters\n    ----------\n    a : IntervalSet\n        the IntervalSet to set-substract from self\n\n    Returns\n    -------\n    out: IntervalSet\n        _\n    \"\"\"\n    start1 = self.values[:, 0]\n    end1 = self.values[:, 1]\n    start2 = a.values[:, 0]\n    end2 = a.values[:, 1]\n    s, e = jitdiff(start1, end1, start2, end2)\n    return IntervalSet(s, e)\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.in_interval","title":"in_interval","text":"<pre><code>in_interval(tsd)\n</code></pre> <p>finds out in which element of the interval set each point in a time series fits.</p> <p>NaNs for those that don't fit an interval</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>Tsd</code> <p>The tsd to be binned</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>an array with the interval index labels for each time stamp (NaN) for timestamps not in IntervalSet</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def in_interval(self, tsd):\n    \"\"\"\n    finds out in which element of the interval set each point in a time series fits.\n\n    NaNs for those that don't fit an interval\n\n    Parameters\n    ----------\n    tsd : Tsd\n        The tsd to be binned\n\n    Returns\n    -------\n    out: numpy.ndarray\n        an array with the interval index labels for each time stamp (NaN) for timestamps not in IntervalSet\n    \"\"\"\n    times = tsd.index\n    starts = self.values[:, 0]\n    ends = self.values[:, 1]\n\n    return jitin_interval(times, starts, ends)\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.drop_short_intervals","title":"drop_short_intervals","text":"<pre><code>drop_short_intervals(threshold, time_units='s')\n</code></pre> <p>Drops the short intervals in the interval set.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>numeric</code> <p>Time threshold for \"short\" intervals</p> required <code>time_units</code> <code>None</code> <p>The time units for the treshold ('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>IntervalSet</code> <p>A copied IntervalSet with the dropped intervals</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def drop_short_intervals(self, threshold, time_units=\"s\"):\n    \"\"\"\n    Drops the short intervals in the interval set.\n\n    Parameters\n    ----------\n    threshold : numeric\n        Time threshold for \"short\" intervals\n    time_units : None, optional\n        The time units for the treshold ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: IntervalSet\n        A copied IntervalSet with the dropped intervals\n    \"\"\"\n    threshold = TsIndex.format_timestamps(\n        np.array([threshold], dtype=np.float64), time_units\n    )[0]\n    return self.loc[(self[\"end\"] - self[\"start\"]) &gt; threshold].reset_index(\n        drop=True\n    )\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.drop_long_intervals","title":"drop_long_intervals","text":"<pre><code>drop_long_intervals(threshold, time_units='s')\n</code></pre> <p>Drops the long intervals in the interval set.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>numeric</code> <p>Time threshold for \"long\" intervals</p> required <code>time_units</code> <code>None</code> <p>The time units for the treshold ('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>IntervalSet</code> <p>A copied IntervalSet with the dropped intervals</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def drop_long_intervals(self, threshold, time_units=\"s\"):\n    \"\"\"\n    Drops the long intervals in the interval set.\n\n    Parameters\n    ----------\n    threshold : numeric\n        Time threshold for \"long\" intervals\n    time_units : None, optional\n        The time units for the treshold ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: IntervalSet\n        A copied IntervalSet with the dropped intervals\n    \"\"\"\n    threshold = TsIndex.format_timestamps(\n        np.array([threshold], dtype=np.float64), time_units\n    )[0]\n    return self.loc[(self[\"end\"] - self[\"start\"]) &lt; threshold].reset_index(\n        drop=True\n    )\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.as_units","title":"as_units","text":"<pre><code>as_units(units='s')\n</code></pre> <p>returns a DataFrame with time expressed in the desired unit</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>None</code> <p>'us', 'ms', or 's' [default]</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>DataFrame</code> <p>DataFrame with adjusted times</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def as_units(self, units=\"s\"):\n    \"\"\"\n    returns a DataFrame with time expressed in the desired unit\n\n    Parameters\n    ----------\n    units : None, optional\n        'us', 'ms', or 's' [default]\n\n    Returns\n    -------\n    out: pandas.DataFrame\n        DataFrame with adjusted times\n    \"\"\"\n\n    data = self.values.copy()\n    data = TsIndex.return_timestamps(data, units)\n    if units == \"us\":\n        data = data.astype(np.int64)\n\n    df = pd.DataFrame(index=self.index.values, data=data, columns=self.columns)\n\n    return df\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.merge_close_intervals","title":"merge_close_intervals","text":"<pre><code>merge_close_intervals(threshold, time_units='s')\n</code></pre> <p>Merges intervals that are very close.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>numeric</code> <p>time threshold for the closeness of the intervals</p> required <code>time_units</code> <code>None</code> <p>time units for the threshold ('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>IntervalSet</code> <p>a copied IntervalSet with merged intervals</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def merge_close_intervals(self, threshold, time_units=\"s\"):\n    \"\"\"\n    Merges intervals that are very close.\n\n    Parameters\n    ----------\n    threshold : numeric\n        time threshold for the closeness of the intervals\n    time_units : None, optional\n        time units for the threshold ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: IntervalSet\n        a copied IntervalSet with merged intervals\n\n    \"\"\"\n    if len(self) == 0:\n        return IntervalSet(start=[], end=[])\n\n    threshold = TsIndex.format_timestamps(\n        np.array((threshold,), dtype=np.float64).ravel(), time_units\n    )[0]\n    start = self[\"start\"].values\n    end = self[\"end\"].values\n    tojoin = (start[1:] - end[0:-1]) &gt; threshold\n    start = np.hstack((start[0], start[1:][tojoin]))\n    end = np.hstack((end[0:-1][tojoin], end[-1]))\n\n    return IntervalSet(start=start, end=end)\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.get_intervals_center","title":"get_intervals_center","text":"<pre><code>get_intervals_center(alpha=0.5)\n</code></pre> <p>Returns by default the centers of each intervals.</p> <p>It is possible to bias the midpoint by changing the alpha parameter between [0, 1] For each epoch: t = start + (end-start)*alpha</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>The midpoint within each interval.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Ts</code> <p>Timestamps object</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def get_intervals_center(self, alpha=0.5):\n    \"\"\"\n    Returns by default the centers of each intervals.\n\n    It is possible to bias the midpoint by changing the alpha parameter between [0, 1]\n    For each epoch:\n    t = start + (end-start)*alpha\n\n    Parameters\n    ----------\n    alpha : float, optional\n        The midpoint within each interval.\n\n    Returns\n    -------\n    Ts\n        Timestamps object\n    \"\"\"\n    time_series = importlib.import_module(\".time_series\", \"pynapple.core\")\n    starts = self.values[:, 0]\n    ends = self.values[:, 1]\n\n    if not isinstance(alpha, float):\n        raise RuntimeError(\"Parameter alpha should be float type\")\n\n    alpha = np.clip(alpha, 0, 1)\n    t = starts + (ends - starts) * alpha\n    return time_series.Ts(t=t, time_support=self)\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.IntervalSet.save","title":"save","text":"<pre><code>save(filename)\n</code></pre> <p>Save IntervalSet object in npz format. The file will contain the starts and ends.</p> <p>The main purpose of this function is to save small/medium sized IntervalSet objects. For example, you determined some epochs for one session that you want to save to avoid recomputing them.</p> <p>You can load the object with numpy.load. Keys are 'start', 'end' and 'type'. See the example below.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; ep = nap.IntervalSet(start=[0, 10, 20], end=[5, 12, 33])\n&gt;&gt;&gt; ep.save(\"my_ep.npz\")\n</code></pre> <p>Here I can retrieve my data with numpy directly:</p> <pre><code>&gt;&gt;&gt; file = np.load(\"my_ep.npz\")\n&gt;&gt;&gt; print(list(file.keys()))\n['start', 'end', 'type']\n&gt;&gt;&gt; print(file['start'])\n[0. 10. 20.]\n</code></pre> <p>It is then easy to recreate the IntervalSet object.</p> <pre><code>&gt;&gt;&gt; nap.IntervalSet(file['start'], file['end'])\n   start   end\n0    0.0   5.0\n1   10.0  12.0\n2   20.0  33.0\n</code></pre> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If filename is not str, path does not exist or filename is a directory.</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>def save(self, filename):\n    \"\"\"\n    Save IntervalSet object in npz format. The file will contain the starts and ends.\n\n    The main purpose of this function is to save small/medium sized IntervalSet\n    objects. For example, you determined some epochs for one session that you want to save\n    to avoid recomputing them.\n\n    You can load the object with numpy.load. Keys are 'start', 'end' and 'type'.\n    See the example below.\n\n    Parameters\n    ----------\n    filename : str\n        The filename\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; ep = nap.IntervalSet(start=[0, 10, 20], end=[5, 12, 33])\n    &gt;&gt;&gt; ep.save(\"my_ep.npz\")\n\n    Here I can retrieve my data with numpy directly:\n\n    &gt;&gt;&gt; file = np.load(\"my_ep.npz\")\n    &gt;&gt;&gt; print(list(file.keys()))\n    ['start', 'end', 'type']\n    &gt;&gt;&gt; print(file['start'])\n    [0. 10. 20.]\n\n    It is then easy to recreate the IntervalSet object.\n    &gt;&gt;&gt; nap.IntervalSet(file['start'], file['end'])\n       start   end\n    0    0.0   5.0\n    1   10.0  12.0\n    2   20.0  33.0\n\n    Raises\n    ------\n    RuntimeError\n        If filename is not str, path does not exist or filename is a directory.\n    \"\"\"\n    if not isinstance(filename, str):\n        raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n    if os.path.isdir(filename):\n        raise RuntimeError(\n            \"Invalid filename input. {} is directory.\".format(filename)\n        )\n\n    if not filename.lower().endswith(\".npz\"):\n        filename = filename + \".npz\"\n\n    dirname = os.path.dirname(filename)\n\n    if len(dirname) and not os.path.exists(dirname):\n        raise RuntimeError(\n            \"Path {} does not exist.\".format(os.path.dirname(filename))\n        )\n\n    np.savez(\n        filename,\n        start=self.start.values,\n        end=self.end.values,\n        type=np.array([\"IntervalSet\"], dtype=np.str_),\n    )\n\n    return\n</code></pre>"},{"location":"reference/core/interval_set/#pynapple.core.interval_set.jitfix_iset","title":"jitfix_iset","text":"<pre><code>jitfix_iset(start, end)\n</code></pre> <p>0 - &gt; \"Some starts and ends are equal. Removing 1 microsecond!\", 1 - &gt; \"Some ends precede the relative start. Dropping them!\", 2 - &gt; \"Some starts precede the previous end. Joining them!\", 3 - &gt; \"Some epochs have no duration\"</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>ndarray</code> <p>Description</p> required <code>end</code> <code>ndarray</code> <p>Description</p> required <p>Returns:</p> Type Description <code>TYPE</code> <p>Description</p> Source code in <code>pynapple/core/interval_set.py</code> <pre><code>@jit(nopython=True)\ndef jitfix_iset(start, end):\n    \"\"\"\n    0 - &gt; \"Some starts and ends are equal. Removing 1 microsecond!\",\n    1 - &gt; \"Some ends precede the relative start. Dropping them!\",\n    2 - &gt; \"Some starts precede the previous end. Joining them!\",\n    3 - &gt; \"Some epochs have no duration\"\n\n    Parameters\n    ----------\n    start : numpy.ndarray\n        Description\n    end : numpy.ndarray\n        Description\n\n    Returns\n    -------\n    TYPE\n        Description\n    \"\"\"\n    to_warn = np.zeros(4, dtype=np.bool_)\n\n    m = start.shape[0]\n\n    data = np.zeros((m, 2), dtype=np.float64)\n\n    i = 0\n    ct = 0\n\n    while i &lt; m:\n        newstart = start[i]\n        newend = end[i]\n\n        while i &lt; m:\n            if end[i] == start[i]:\n                to_warn[3] = True\n                i += 1\n            else:\n                newstart = start[i]\n                newend = end[i]\n                break\n\n        while i &lt; m:\n            if end[i] &lt; start[i]:\n                to_warn[1] = True\n                i += 1\n            else:\n                newstart = start[i]\n                newend = end[i]\n                break\n\n        while i &lt; m - 1:\n            if start[i + 1] &lt; end[i]:\n                to_warn[2] = True\n                i += 1\n                newend = max(end[i - 1], end[i])\n            else:\n                break\n\n        if i &lt; m - 1:\n            if newend == start[i + 1]:\n                to_warn[0] = True\n                newend -= 1.0e-6\n\n        data[ct, 0] = newstart\n        data[ct, 1] = newend\n\n        ct += 1\n        i += 1\n\n    data = data[0:ct]\n\n    return (data, to_warn)\n</code></pre>"},{"location":"reference/core/time_index/","title":"Time index","text":""},{"location":"reference/core/time_index/#pynapple.core.time_index","title":"pynapple.core.time_index","text":"<p>Similar to pd.Index, TsIndex holds the timestamps associated with the data of a time series. This class deals with conversion between different time units for all pynapple objects as well as making sure that timestamps are property sorted before initializing any objects.       - <code>us</code>: microseconds     - <code>ms</code>: milliseconds     - <code>s</code>: seconds  (overall default)</p>"},{"location":"reference/core/time_index/#pynapple.core.time_index.TsIndex","title":"TsIndex","text":"<p>             Bases: <code>ndarray</code></p> <p>Holder for timestamps. Similar to pandas.Index. Subclass numpy.ndarray</p> Source code in <code>pynapple/core/time_index.py</code> <pre><code>class TsIndex(np.ndarray):\n    \"\"\"\n    Holder for timestamps. Similar to pandas.Index. Subclass numpy.ndarray\n    \"\"\"\n\n    @staticmethod\n    def format_timestamps(t, units=\"s\"):\n        \"\"\"\n        Converts time index in pynapple in a default format\n\n        Parameters\n        ----------\n        t : numpy.ndarray\n            a vector of times\n        units\n            the units in which times are given\n\n        Returns\n        -------\n        t : np.ndarray\n            times in standard pynapple format\n\n        Raises\n        ------\n        ValueError\n            Description\n        \"\"\"\n        if units == \"s\":\n            t = np.around(t, 9)\n        elif units == \"ms\":\n            t = np.around(t / 1.0e3, 9)\n        elif units == \"us\":\n            t = np.around(t / 1.0e6, 9)\n        else:\n            raise ValueError(\"unrecognized time units type\")\n\n        return t\n\n    @staticmethod\n    def return_timestamps(t, units=\"s\"):\n        \"\"\"\n        Converts time index in pynapple in a particular format\n\n        Parameters\n        ----------\n        t : numpy.ndarray\n            a vector (or scalar) of times\n        units\n            the units in which times are given\n\n        Returns\n        -------\n        t : numpy.ndarray\n            times in standard pynapple format\n\n        Raises\n        ------\n        ValueError\n            IF units is not in ['s', 'ms', 'us']\n        \"\"\"\n        if units == \"s\":\n            t = np.around(t, 9)\n        elif units == \"ms\":\n            t = np.around(t * 1.0e3, 9)\n        elif units == \"us\":\n            t = np.around(t * 1.0e6, 9)\n        else:\n            raise ValueError(\"unrecognized time units type\")\n\n        return t\n\n    @staticmethod\n    def sort_timestamps(t, give_warning=True):\n        \"\"\"\n        Raise warning if timestamps are not sorted\n\n        Parameters\n        ----------\n        t : numpy.ndarray\n            a vector of times\n        give_warning : bool, optional\n            If timestamps are not sorted\n\n        Returns\n        -------\n        numpy.ndarray\n            Description\n        \"\"\"\n        if not (np.diff(t) &gt;= 0).all():\n            if give_warning:\n                warn(\"timestamps are not sorted\", UserWarning)\n            t = np.sort(t)\n        return t\n\n    def __new__(cls, t, time_units=\"s\"):\n        t = t.astype(np.float64).flatten()\n        t = TsIndex.format_timestamps(t, time_units)\n        t = TsIndex.sort_timestamps(t)\n        obj = np.asarray(t).view(cls)\n        return obj\n\n    @property\n    def values(self):\n        \"\"\"Returns the index as a ndarray\n\n        Returns\n        -------\n        numpy.ndarray\n            The timestamps in seconds\n        \"\"\"\n        return np.asarray(self)\n\n    def __setitem__(self, *args, **kwargs):\n        raise RuntimeError(\"TsIndex object is not mutable.\")\n\n    def to_numpy(self):\n        \"\"\"Return the index as a ndarray. Useful for matplotlib.\n\n        Returns\n        -------\n        numpy.ndarray\n            The timestamps in seconds\n        \"\"\"\n        return self.values\n\n    def in_units(self, time_units=\"s\"):\n        \"\"\"Return the index as a ndarray in the desired units\n\n        Returns\n        -------\n        numpy.ndarray\n            The timestamps in seconds\n        \"\"\"\n        return TsIndex.return_timestamps(self.values, time_units)\n</code></pre>"},{"location":"reference/core/time_index/#pynapple.core.time_index.TsIndex.values","title":"values  <code>property</code>","text":"<pre><code>values\n</code></pre> <p>Returns the index as a ndarray</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The timestamps in seconds</p>"},{"location":"reference/core/time_index/#pynapple.core.time_index.TsIndex.format_timestamps","title":"format_timestamps  <code>staticmethod</code>","text":"<pre><code>format_timestamps(t, units='s')\n</code></pre> <p>Converts time index in pynapple in a default format</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>a vector of times</p> required <code>units</code> <p>the units in which times are given</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>times in standard pynapple format</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Description</p> Source code in <code>pynapple/core/time_index.py</code> <pre><code>@staticmethod\ndef format_timestamps(t, units=\"s\"):\n    \"\"\"\n    Converts time index in pynapple in a default format\n\n    Parameters\n    ----------\n    t : numpy.ndarray\n        a vector of times\n    units\n        the units in which times are given\n\n    Returns\n    -------\n    t : np.ndarray\n        times in standard pynapple format\n\n    Raises\n    ------\n    ValueError\n        Description\n    \"\"\"\n    if units == \"s\":\n        t = np.around(t, 9)\n    elif units == \"ms\":\n        t = np.around(t / 1.0e3, 9)\n    elif units == \"us\":\n        t = np.around(t / 1.0e6, 9)\n    else:\n        raise ValueError(\"unrecognized time units type\")\n\n    return t\n</code></pre>"},{"location":"reference/core/time_index/#pynapple.core.time_index.TsIndex.return_timestamps","title":"return_timestamps  <code>staticmethod</code>","text":"<pre><code>return_timestamps(t, units='s')\n</code></pre> <p>Converts time index in pynapple in a particular format</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>a vector (or scalar) of times</p> required <code>units</code> <p>the units in which times are given</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>t</code> <code>ndarray</code> <p>times in standard pynapple format</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>IF units is not in ['s', 'ms', 'us']</p> Source code in <code>pynapple/core/time_index.py</code> <pre><code>@staticmethod\ndef return_timestamps(t, units=\"s\"):\n    \"\"\"\n    Converts time index in pynapple in a particular format\n\n    Parameters\n    ----------\n    t : numpy.ndarray\n        a vector (or scalar) of times\n    units\n        the units in which times are given\n\n    Returns\n    -------\n    t : numpy.ndarray\n        times in standard pynapple format\n\n    Raises\n    ------\n    ValueError\n        IF units is not in ['s', 'ms', 'us']\n    \"\"\"\n    if units == \"s\":\n        t = np.around(t, 9)\n    elif units == \"ms\":\n        t = np.around(t * 1.0e3, 9)\n    elif units == \"us\":\n        t = np.around(t * 1.0e6, 9)\n    else:\n        raise ValueError(\"unrecognized time units type\")\n\n    return t\n</code></pre>"},{"location":"reference/core/time_index/#pynapple.core.time_index.TsIndex.sort_timestamps","title":"sort_timestamps  <code>staticmethod</code>","text":"<pre><code>sort_timestamps(t, give_warning=True)\n</code></pre> <p>Raise warning if timestamps are not sorted</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>a vector of times</p> required <code>give_warning</code> <code>bool</code> <p>If timestamps are not sorted</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Description</p> Source code in <code>pynapple/core/time_index.py</code> <pre><code>@staticmethod\ndef sort_timestamps(t, give_warning=True):\n    \"\"\"\n    Raise warning if timestamps are not sorted\n\n    Parameters\n    ----------\n    t : numpy.ndarray\n        a vector of times\n    give_warning : bool, optional\n        If timestamps are not sorted\n\n    Returns\n    -------\n    numpy.ndarray\n        Description\n    \"\"\"\n    if not (np.diff(t) &gt;= 0).all():\n        if give_warning:\n            warn(\"timestamps are not sorted\", UserWarning)\n        t = np.sort(t)\n    return t\n</code></pre>"},{"location":"reference/core/time_index/#pynapple.core.time_index.TsIndex.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy()\n</code></pre> <p>Return the index as a ndarray. Useful for matplotlib.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The timestamps in seconds</p> Source code in <code>pynapple/core/time_index.py</code> <pre><code>def to_numpy(self):\n    \"\"\"Return the index as a ndarray. Useful for matplotlib.\n\n    Returns\n    -------\n    numpy.ndarray\n        The timestamps in seconds\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_index/#pynapple.core.time_index.TsIndex.in_units","title":"in_units","text":"<pre><code>in_units(time_units='s')\n</code></pre> <p>Return the index as a ndarray in the desired units</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The timestamps in seconds</p> Source code in <code>pynapple/core/time_index.py</code> <pre><code>def in_units(self, time_units=\"s\"):\n    \"\"\"Return the index as a ndarray in the desired units\n\n    Returns\n    -------\n    numpy.ndarray\n        The timestamps in seconds\n    \"\"\"\n    return TsIndex.return_timestamps(self.values, time_units)\n</code></pre>"},{"location":"reference/core/time_series/","title":"Time series","text":""},{"location":"reference/core/time_series/#pynapple.core.time_series","title":"pynapple.core.time_series","text":""},{"location":"reference/core/time_series/#pynapple.core.time_series--pynapple-time-series","title":"Pynapple time series","text":"<p>Pynapple time series are containers specialized for neurophysiological time series.</p> <p>They provides standardized time representation, plus various functions for manipulating times series with identical sampling frequency.</p> <p>Multiple time series object are avaible depending on the shape of the data.</p> <ul> <li><code>TsdTensor</code> : for data with of more than 2 dimensions, typically movies.</li> <li><code>TsdFrame</code> : for column-based data. It can be easily converted to a pandas.DataFrame. Columns can be labelled and selected similar to pandas.</li> <li><code>Tsd</code> : One-dimensional time series. It can be converted to a pandas.Series.</li> <li><code>Ts</code> : For timestamps data only.</li> </ul> <p>Most of the same functions are available through all classes. Objects behaves like numpy.ndarray. Slicing can be done the same way for example  <code>tsd[0:10]</code> returns the first 10 rows. Similarly, you can call any numpy functions like <code>np.mean(tsd, 1)</code>.</p>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor","title":"TsdTensor","text":"<p>             Bases: <code>NDArrayOperatorsMixin</code>, <code>_AbstractTsd</code></p> <p>TsdTensor</p> <p>Attributes:</p> Name Type Description <code>rate</code> <code>float</code> <p>Frequency of the time series (Hz) computed over the time support</p> <code>time_support</code> <code>IntervalSet</code> <p>The time support of the time series</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>class TsdTensor(NDArrayOperatorsMixin, _AbstractTsd):\n    \"\"\"\n    TsdTensor\n\n    Attributes\n    ----------\n    rate : float\n        Frequency of the time series (Hz) computed over the time support\n    time_support : IntervalSet\n        The time support of the time series\n    \"\"\"\n\n    def __init__(self, t, d, time_units=\"s\", time_support=None, **kwargs):\n        \"\"\"\n        TsdTensor initializer\n\n        Parameters\n        ----------\n        t : numpy.ndarray\n            the time index t\n        d : numpy.ndarray\n            The data\n        time_units : str, optional\n            The time units in which times are specified ('us', 'ms', 's' [default]).\n        time_support : IntervalSet, optional\n            The time support of the TsdFrame object\n        \"\"\"\n        if isinstance(t, np.ndarray) and d is None:\n            raise RuntimeError(\"Missing argument d when initializing TsdTensor\")\n\n        if isinstance(t, (list, tuple)):\n            t = np.array(t)\n        if isinstance(d, (list, tuple)):\n            d = np.array(d)\n\n        assert (\n            d.ndim &gt;= 3\n        ), \"Data should have more than 2 dimensions. If ndim &lt; 3, use TsdFrame or Tsd object\"\n\n        if isinstance(t, TsIndex):\n            self.index = t\n        else:\n            # Checking timestamps\n            self.index = TsIndex(t, time_units)\n\n        if len(self.index) != len(d):\n            raise ValueError(\n                \"Length of values \"\n                f\"({len(d)}) \"\n                \"does not match length of index \"\n                f\"({len(self.index)})\"\n            )\n\n        if len(self.index):\n            if isinstance(time_support, IntervalSet):\n                starts = time_support.start.values\n                ends = time_support.end.values\n                t, d = jitrestrict(self.index.values, d, starts, ends)\n                self.index = TsIndex(t)\n                self.values = d\n            else:\n                time_support = IntervalSet(start=self.index[0], end=self.index[-1])\n                self.values = d\n\n            self.time_support = time_support\n            self.rate = self.index.shape[0] / np.sum(\n                time_support.values[:, 1] - time_support.values[:, 0]\n            )\n        else:\n            self.rate = np.NaN\n            self.values = np.empty(0)\n            self.time_support = IntervalSet(start=[], end=[])\n\n        self.nap_class = self.__class__.__name__\n        self.dtype = self.values.dtype\n        self._initialized = True\n\n    def __repr__(self):\n        headers = [\"Time (s)\", \"\"]\n        bottom = \"dtype: {}\".format(self.dtype) + \", shape: {}\".format(self.shape)\n\n        if len(self):\n\n            def create_str(array):\n                if array.ndim == 1:\n                    if len(array) &gt; 2:\n                        return (\n                            \"[\"\n                            + array[0].__repr__()\n                            + \" ... \"\n                            + array[-1].__repr__()\n                            + \"]\"\n                        )\n                    elif len(array) == 2:\n                        return (\n                            \"[\" + array[0].__repr__() + \",\" + array[1].__repr__() + \"]\"\n                        )\n                    elif len(array) == 1:\n                        return \"[\" + array[0].__repr__() + \"]\"\n                    else:\n                        return \"[]\"\n                else:\n                    return \"[\" + create_str(array[0]) + \" ...]\"\n\n            _str_ = []\n            if self.shape[0] &lt; 100:\n                for i, array in zip(self.index, self.values):\n                    _str_.append([i.__repr__(), create_str(array)])\n            else:\n                for i, array in zip(self.index[0:5], self.values[0:5]):\n                    _str_.append([i.__repr__(), create_str(array)])\n                _str_.append([\"...\", \"\"])\n                for i, array in zip(\n                    self.index[-5:],\n                    self.values[self.values.shape[0] - 5 : self.values.shape[0]],\n                ):\n                    _str_.append([i.__repr__(), create_str(array)])\n\n            return tabulate(_str_, headers=headers, colalign=(\"left\",)) + \"\\n\" + bottom\n\n        else:\n            return tabulate([], headers=headers) + \"\\n\" + bottom\n\n    def save(self, filename):\n        \"\"\"\n        Save TsdTensor object in npz format. The file will contain the timestamps, the\n        data and the time support.\n\n        The main purpose of this function is to save small/medium sized time series\n        objects. For example, you extracted several channels from your recording and\n        filtered them. You can save the filtered channels as a npz to avoid\n        reprocessing it.\n\n        You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end', 'type'\n        and 'columns' for columns names.\n\n        Parameters\n        ----------\n        filename : str\n            The filename\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tsdtensor = nap.TsdTensor(t=np.array([0., 1.]), d = np.zeros((2,3,4)))\n        &gt;&gt;&gt; tsdtensor.save(\"my_path/my_tsdtensor.npz\")\n\n        Here I can retrieve my data with numpy directly:\n\n        &gt;&gt;&gt; file = np.load(\"my_path/my_tsdtensor.npz\")\n        &gt;&gt;&gt; print(list(file.keys()))\n        ['t', 'd', 'start', 'end', ''type']\n        &gt;&gt;&gt; print(file['t'])\n        [0. 1.]\n\n        It is then easy to recreate the TsdTensor object.\n        &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n        &gt;&gt;&gt; nap.TsdTensor(t=file['t'], d=file['d'], time_support=time_support)\n        Time (s)\n        0.0       [[[0.0 ...]]]\n        1.0       [[[0.0 ...]]]\n\n\n        Raises\n        ------\n        RuntimeError\n            If filename is not str, path does not exist or filename is a directory.\n        \"\"\"\n        if not isinstance(filename, str):\n            raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n        if os.path.isdir(filename):\n            raise RuntimeError(\n                \"Invalid filename input. {} is directory.\".format(filename)\n            )\n\n        if not filename.lower().endswith(\".npz\"):\n            filename = filename + \".npz\"\n\n        dirname = os.path.dirname(filename)\n\n        if len(dirname) and not os.path.exists(dirname):\n            raise RuntimeError(\n                \"Path {} does not exist.\".format(os.path.dirname(filename))\n            )\n\n        np.savez(\n            filename,\n            t=self.index.values,\n            d=self.values,\n            start=self.time_support.start.values,\n            end=self.time_support.end.values,\n            type=np.array([self.nap_class], dtype=np.str_),\n        )\n\n        return\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Object is immutable</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def __setattr__(self, name, value):\n    \"\"\"Object is immutable\"\"\"\n    if self._initialized:\n        raise RuntimeError(\n            \"Changing directly attributes is not permitted for {}.\".format(\n                self.nap_class\n            )\n        )\n    else:\n        object.__setattr__(self, name, value)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.times","title":"times","text":"<pre><code>times(units='s')\n</code></pre> <p>The time index of the object, returned as np.double in the desired time units.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>the time indexes</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def times(self, units=\"s\"):\n    \"\"\"\n    The time index of the object, returned as np.double in the desired time units.\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.ndarray\n        the time indexes\n    \"\"\"\n    return self.index.in_units(units)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.as_array","title":"as_array","text":"<pre><code>as_array()\n</code></pre> <p>Return the data as a numpy.ndarray</p> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_array(self):\n    \"\"\"\n    Return the data as a numpy.ndarray\n\n    Returns\n    -------\n    out: numpy.ndarray\n        _\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.data","title":"data","text":"<pre><code>data()\n</code></pre> <p>Return the data as a numpy.ndarray</p> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def data(self):\n    \"\"\"\n    Return the data as a numpy.ndarray\n\n    Returns\n    -------\n    out: numpy.ndarray\n        _\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy()\n</code></pre> <p>Return the data as a numpy.ndarray. Mostly useful for matplotlib plotting when calling <code>plot(tsd)</code></p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def to_numpy(self):\n    \"\"\"\n    Return the data as a numpy.ndarray. Mostly useful for matplotlib plotting when calling `plot(tsd)`\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.start_time","title":"start_time","text":"<pre><code>start_time(units='s')\n</code></pre> <p>The first time index in the time series object</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float64</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def start_time(self, units=\"s\"):\n    \"\"\"\n    The first time index in the time series object\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.float64\n        _\n    \"\"\"\n    if len(self.index):\n        return self.times(units=units)[0]\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.end_time","title":"end_time","text":"<pre><code>end_time(units='s')\n</code></pre> <p>The last time index in the time series object</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float64</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def end_time(self, units=\"s\"):\n    \"\"\"\n    The last time index in the time series object\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.float64\n        _\n    \"\"\"\n    if len(self.index):\n        return self.times(units=units)[-1]\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.value_from","title":"value_from","text":"<pre><code>value_from(data, ep=None)\n</code></pre> <p>Replace the value with the closest value from Tsd/TsdFrame/TsdTensor argument</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Tsd / TsdFrame / TsdTensor</code> <p>The object holding the values to replace.</p> required <code>ep</code> <code>IntervalSet(optional)</code> <p>The IntervalSet object to restrict the operation. If None, the time support of the tsd input object is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd / TsdFrame / TsdTensor</code> <p>Object with the new values</p> <p>Examples:</p> <p>In this example, the ts object will receive the closest values in time from tsd.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100))) # random times\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,1000), d=np.random.rand(1000), time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 500, time_units = 's')\n</code></pre> <p>The variable ts is a time series object containing only nan. The tsd object containing the values, for example the tracking data, and the epoch to restrict the operation.</p> <pre><code>&gt;&gt;&gt; newts = ts.value_from(tsd, ep)\n</code></pre> <p>newts is the same size as ts restrict to ep.</p> <pre><code>&gt;&gt;&gt; print(len(ts.restrict(ep)), len(newts))\n    52 52\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def value_from(self, data, ep=None):\n    \"\"\"\n    Replace the value with the closest value from Tsd/TsdFrame/TsdTensor argument\n\n    Parameters\n    ----------\n    data : Tsd/TsdFrame/TsdTensor\n        The object holding the values to replace.\n    ep : IntervalSet (optional)\n        The IntervalSet object to restrict the operation.\n        If None, the time support of the tsd input object is used.\n\n    Returns\n    -------\n    out : Tsd/TsdFrame/TsdTensor\n        Object with the new values\n\n    Examples\n    --------\n    In this example, the ts object will receive the closest values in time from tsd.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100))) # random times\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,1000), d=np.random.rand(1000), time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 500, time_units = 's')\n\n    The variable ts is a time series object containing only nan.\n    The tsd object containing the values, for example the tracking data, and the epoch to restrict the operation.\n\n    &gt;&gt;&gt; newts = ts.value_from(tsd, ep)\n\n    newts is the same size as ts restrict to ep.\n\n    &gt;&gt;&gt; print(len(ts.restrict(ep)), len(newts))\n        52 52\n    \"\"\"\n    if not isinstance(data, (TsdTensor, TsdFrame, Tsd)):\n        raise RuntimeError(\n            \"The time series to align to should be Tsd/TsdFrame/TsdTensor.\"\n        )\n\n    if ep is None:\n        ep = data.time_support\n    time_array = self.index.values\n    time_target_array = data.index.values\n    data_target_array = data.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if data_target_array.ndim == 1:\n        t, d, ns, ne = jitvaluefrom(\n            time_array, time_target_array, data_target_array, starts, ends\n        )\n    else:\n        t, d, ns, ne = jitvaluefromtensor(\n            time_array, time_target_array, data_target_array, starts, ends\n        )\n\n    time_support = IntervalSet(start=ns, end=ne)\n\n    if isinstance(data, TsdFrame):\n        return TsdFrame(t=t, d=d, time_support=time_support, columns=data.columns)\n    else:\n        return data.__class__(t, d, time_support=time_support)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.count","title":"count","text":"<pre><code>count(*args, **kwargs)\n</code></pre> <p>Count occurences of events within bin_size or within a set of bins defined as an IntervalSet. You can call this function in multiple ways :</p> <ol> <li> <p>tsd.count(bin_size=1, time_units = 'ms') -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.</p> </li> <li> <p>tsd.count(1, ep=my_epochs) -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.</p> </li> <li> <p>tsd.count(ep=my_bins) -&gt; Count occurent of events within each epoch of the intervalSet object my_bins</p> </li> <li> <p>tsd.count() -&gt; Count occurent of events within each epoch of the time support.</p> </li> </ol> <p>bin_size should be seconds unless specified. If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>None or float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> required <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd</code> <p>A Tsd object indexed by the center of the bins.</p> <p>Examples:</p> <p>This example shows how to count events within bins of 0.1 second.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; bincount = ts.count(0.1)\n</code></pre> <p>An epoch can be specified:</p> <pre><code>&gt;&gt;&gt; ep = nap.IntervalSet(start = 100, end = 800, time_units = 's')\n&gt;&gt;&gt; bincount = ts.count(0.1, ep=ep)\n</code></pre> <p>And bincount automatically inherit ep as time support:</p> <pre><code>&gt;&gt;&gt; bincount.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0  100.0  800.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def count(self, *args, **kwargs):\n    \"\"\"\n    Count occurences of events within bin_size or within a set of bins defined as an IntervalSet.\n    You can call this function in multiple ways :\n\n    1. *tsd.count(bin_size=1, time_units = 'ms')*\n    -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.\n\n    2. *tsd.count(1, ep=my_epochs)*\n    -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.\n\n    3. *tsd.count(ep=my_bins)*\n    -&gt; Count occurent of events within each epoch of the intervalSet object my_bins\n\n    4. *tsd.count()*\n    -&gt; Count occurent of events within each epoch of the time support.\n\n    bin_size should be seconds unless specified.\n    If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.\n\n    Parameters\n    ----------\n    bin_size : None or float, optional\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: Tsd\n        A Tsd object indexed by the center of the bins.\n\n    Examples\n    --------\n    This example shows how to count events within bins of 0.1 second.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; bincount = ts.count(0.1)\n\n    An epoch can be specified:\n\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 100, end = 800, time_units = 's')\n    &gt;&gt;&gt; bincount = ts.count(0.1, ep=ep)\n\n    And bincount automatically inherit ep as time support:\n\n    &gt;&gt;&gt; bincount.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0  100.0  800.0\n    \"\"\"\n    bin_size = None\n    if \"bin_size\" in kwargs:\n        bin_size = kwargs[\"bin_size\"]\n        if isinstance(bin_size, int):\n            bin_size = float(bin_size)\n        if not isinstance(bin_size, float):\n            raise ValueError(\"bin_size argument should be float.\")\n    else:\n        for a in args:\n            if isinstance(a, (float, int)):\n                bin_size = float(a)\n\n    time_units = \"s\"\n    if \"time_units\" in kwargs:\n        time_units = kwargs[\"time_units\"]\n        if not isinstance(time_units, str):\n            raise ValueError(\"time_units argument should be 's', 'ms' or 'us'.\")\n    else:\n        for a in args:\n            if isinstance(a, str) and a in [\"s\", \"ms\", \"us\"]:\n                time_units = a\n\n    ep = self.time_support\n    if \"ep\" in kwargs:\n        ep = kwargs[\"ep\"]\n        if not isinstance(ep, IntervalSet):\n            raise ValueError(\"ep argument should be IntervalSet\")\n    else:\n        for a in args:\n            if isinstance(a, IntervalSet):\n                ep = a\n\n    time_array = self.index.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if isinstance(bin_size, (float, int)):\n        bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n        t, d = jitcount(time_array, starts, ends, bin_size)\n    else:\n        _, d = jittsrestrict_with_count(time_array, starts, ends)\n        t = starts + (ends - starts) / 2\n\n    return Tsd(t=t, d=d, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.restrict","title":"restrict","text":"<pre><code>restrict(iset)\n</code></pre> <p>Restricts a time series object to a set of time intervals delimited by an IntervalSet object</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>the IntervalSet object</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>(Ts, Tsd, TsdFrame or TsdTensor)</code> <p>Tsd object restricted to ep</p> <p>Examples:</p> <p>The Ts object is restrict to the intervals defined by ep.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=500, time_units='s')\n&gt;&gt;&gt; newts = ts.restrict(ep)\n</code></pre> <p>The time support of newts automatically inherit the epochs defined by ep.</p> <pre><code>&gt;&gt;&gt; newts.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0    0.0  500.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def restrict(self, iset):\n    \"\"\"\n    Restricts a time series object to a set of time intervals delimited by an IntervalSet object\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        the IntervalSet object\n\n    Returns\n    -------\n    out: Ts, Tsd, TsdFrame or TsdTensor\n        Tsd object restricted to ep\n\n    Examples\n    --------\n    The Ts object is restrict to the intervals defined by ep.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=500, time_units='s')\n    &gt;&gt;&gt; newts = ts.restrict(ep)\n\n    The time support of newts automatically inherit the epochs defined by ep.\n\n    &gt;&gt;&gt; newts.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0    0.0  500.0\n\n    \"\"\"\n    assert isinstance(iset, IntervalSet), \"Argument should be IntervalSet\"\n\n    time_array = self.index.values\n    starts = iset.start.values\n    ends = iset.end.values\n\n    if isinstance(self.values, np.ndarray):\n        data_array = self.values\n        t, d = jitrestrict(time_array, data_array, starts, ends)\n\n        if hasattr(self, \"columns\"):\n            return TsdFrame(t=t, d=d, time_support=iset, columns=self.columns)\n        else:\n            return self.__class__(t=t, d=d, time_support=iset)\n    else:\n        t = jittsrestrict(time_array, starts, ends)\n        return Ts(t, time_support=iset)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.bin_average","title":"bin_average","text":"<pre><code>bin_average(bin_size, ep=None, time_units='s')\n</code></pre> <p>Bin the data by averaging points within bin_size bin_size should be seconds unless specified. If no epochs is passed, the data will be binned based on the time support.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> <code>None</code> <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>(Tsd, TsdFrame, TsdTensor)</code> <p>A Tsd object indexed by the center of the bins and holding the averaged data points.</p> <p>Examples:</p> <p>This example shows how to bin data within bins of 0.1 second.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n&gt;&gt;&gt; bintsd = tsd.bin_average(0.1)\n</code></pre> <p>An epoch can be specified:</p> <pre><code>&gt;&gt;&gt; ep = nap.IntervalSet(start = 10, end = 80, time_units = 's')\n&gt;&gt;&gt; bintsd = tsd.bin_average(0.1, ep=ep)\n</code></pre> <p>And bintsd automatically inherit ep as time support:</p> <pre><code>&gt;&gt;&gt; bintsd.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0  10.0     80.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def bin_average(self, bin_size, ep=None, time_units=\"s\"):\n    \"\"\"\n    Bin the data by averaging points within bin_size\n    bin_size should be seconds unless specified.\n    If no epochs is passed, the data will be binned based on the time support.\n\n    Parameters\n    ----------\n    bin_size : float\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: Tsd, TsdFrame, TsdTensor\n        A Tsd object indexed by the center of the bins and holding the averaged data points.\n\n    Examples\n    --------\n    This example shows how to bin data within bins of 0.1 second.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n    &gt;&gt;&gt; bintsd = tsd.bin_average(0.1)\n\n    An epoch can be specified:\n\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 10, end = 80, time_units = 's')\n    &gt;&gt;&gt; bintsd = tsd.bin_average(0.1, ep=ep)\n\n    And bintsd automatically inherit ep as time support:\n\n    &gt;&gt;&gt; bintsd.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0  10.0     80.0\n    \"\"\"\n    if not isinstance(ep, IntervalSet):\n        ep = self.time_support\n\n    bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n\n    time_array = self.index.values\n    data_array = self.values\n    starts = ep.start.values\n    ends = ep.end.values\n    if data_array.ndim &gt; 1:\n        t, d = jitbin_array(time_array, data_array, starts, ends, bin_size)\n    else:\n        t, d = jitbin(time_array, data_array, starts, ends, bin_size)\n\n    if d.ndim == 1:\n        return Tsd(t=t, d=d, time_support=ep)\n    elif d.ndim == 2:\n        kwargs = {}\n        if hasattr(self, \"columns\"):\n            kwargs[\"columns\"] = self.columns\n        return TsdFrame(t=t, d=d, time_support=ep, **kwargs)\n    else:\n        return TsdTensor(t=t, d=d, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Copy the data, index and time support</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def copy(self):\n    \"\"\"Copy the data, index and time support\"\"\"\n    return self.__class__(\n        t=self.index.copy(), d=self.values.copy(), time_support=self.time_support\n    )\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.find_support","title":"find_support","text":"<pre><code>find_support(min_gap, time_units='s')\n</code></pre> <p>find the smallest (to a min_gap resolution) IntervalSet containing all the times in the Tsd</p> <p>Parameters:</p> Name Type Description Default <code>min_gap</code> <code>float or int</code> <p>minimal interval between timestamps</p> required <code>time_units</code> <code>str</code> <p>Time units of min gap</p> <code>'s'</code> <p>Returns:</p> Type Description <code>IntervalSet</code> <p>Description</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def find_support(self, min_gap, time_units=\"s\"):\n    \"\"\"\n    find the smallest (to a min_gap resolution) IntervalSet containing all the times in the Tsd\n\n    Parameters\n    ----------\n    min_gap : float or int\n        minimal interval between timestamps\n    time_units : str, optional\n        Time units of min gap\n\n    Returns\n    -------\n    IntervalSet\n        Description\n    \"\"\"\n    assert isinstance(min_gap, Number), \"min_gap should be a float or int\"\n    min_gap = TsIndex.format_timestamps(np.array([min_gap]), time_units)[0]\n    time_array = self.index.values\n\n    starts = [time_array[0]]\n    ends = []\n    for i in range(len(time_array) - 1):\n        if (time_array[i + 1] - time_array[i]) &gt; min_gap:\n            ends.append(time_array[i] + 1e-6)\n            starts.append(time_array[i + 1])\n\n    ends.append(time_array[-1] + 1e-6)\n\n    return IntervalSet(start=starts, end=ends)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.get","title":"get","text":"<pre><code>get(start, end=None, time_units='s')\n</code></pre> <p>Slice the time series from start to end such that all the timestamps satisfy start&lt;=t&lt;=end. If end is None, only the timepoint closest to start is returned.</p> <p>By default, the time support doesn't change. If you want to change the time support, use the restrict function.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float or int</code> <p>The start</p> required <code>end</code> <code>float or int</code> <p>The end</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def get(self, start, end=None, time_units=\"s\"):\n    \"\"\"Slice the time series from start to end such that all the timestamps satisfy start&lt;=t&lt;=end.\n    If end is None, only the timepoint closest to start is returned.\n\n    By default, the time support doesn't change. If you want to change the time support, use the restrict function.\n\n    Parameters\n    ----------\n    start : float or int\n        The start\n    end : float or int\n        The end\n    \"\"\"\n    assert isinstance(start, Number), \"start should be a float or int\"\n    time_array = self.index.values\n\n    if end is None:\n        start = TsIndex.format_timestamps(np.array([start]), time_units)[0]\n        idx = int(np.searchsorted(time_array, start))\n        if idx == 0:\n            return self[idx]\n        elif idx &gt;= self.shape[0]:\n            return self[-1]\n        else:\n            if start - time_array[idx - 1] &lt; time_array[idx] - start:\n                return self[idx - 1]\n            else:\n                return self[idx]\n    else:\n        assert isinstance(end, Number), \"end should be a float or int\"\n        assert start &lt; end, \"Start should not precede end\"\n        start, end = TsIndex.format_timestamps(np.array([start, end]), time_units)\n        idx_start = np.searchsorted(time_array, start)\n        idx_end = np.searchsorted(time_array, end, side=\"right\")\n        return self[idx_start:idx_end]\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.dropna","title":"dropna","text":"<pre><code>dropna(update_time_support=True)\n</code></pre> <p>Drop every rows containing NaNs. By default, the time support is updated to start and end around the time points that are non NaNs. To change this behavior, you can set update_time_support=False.</p> <p>Parameters:</p> Name Type Description Default <code>update_time_support</code> <code>bool</code> <code>True</code> <p>Returns:</p> Type Description <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The time series without the NaNs</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def dropna(self, update_time_support=True):\n    \"\"\"Drop every rows containing NaNs. By default, the time support is updated to start and end around the time points that are non NaNs.\n    To change this behavior, you can set update_time_support=False.\n\n    Parameters\n    ----------\n    update_time_support : bool, optional\n\n    Returns\n    -------\n    Tsd, TsdFrame or TsdTensor\n        The time series without the NaNs\n    \"\"\"\n    index_nan = np.any(np.isnan(self.values), axis=tuple(range(1, self.ndim)))\n    if np.all(index_nan):  # In case it's only NaNs\n        return self.__class__(\n            t=np.array([]), d=np.empty(tuple([0] + [d for d in self.shape[1:]]))\n        )\n\n    elif np.any(index_nan):\n        if update_time_support:\n            time_array = self.index.values\n            starts, ends = jitremove_nan(time_array, index_nan)\n\n            to_fix = starts == ends\n            if np.any(to_fix):\n                ends[\n                    to_fix\n                ] += 1e-6  # adding 1 millisecond in case of a single point\n\n            ep = IntervalSet(starts, ends)\n\n            return self.__class__(\n                t=time_array[~index_nan], d=self.values[~index_nan], time_support=ep\n            )\n\n        else:\n            return self[~index_nan]\n\n    else:\n        return self\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.convolve","title":"convolve","text":"<pre><code>convolve(array, ep=None, trim='both')\n</code></pre> <p>Return the discrete linear convolution of the time series with a one dimensional sequence.</p> <p>A parameter ep can control the epochs for which the convolution will apply. Otherwise the convolution is made over the time support.</p> <p>This function assume a constant sampling rate of the time series.</p> <p>The only mode supported is full. The returned object is trimmed to match the size of the original object. The parameter trim controls which side the trimming operates. Default is 'both'.</p> <p>See the numpy documentation here : https://numpy.org/doc/stable/reference/generated/numpy.convolve.html</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>One dimensional input array</p> required <code>ep</code> <code>None</code> <p>The epochs to apply the convolution</p> <code>None</code> <code>trim</code> <code>str</code> <p>The side on which to trim the output of the convolution ('left', 'right', 'both' [default])</p> <code>'both'</code> <p>Returns:</p> Type Description <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The convolved time series</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def convolve(self, array, ep=None, trim=\"both\"):\n    \"\"\"Return the discrete linear convolution of the time series with a one dimensional sequence.\n\n    A parameter ep can control the epochs for which the convolution will apply. Otherwise the convolution is made over the time support.\n\n    This function assume a constant sampling rate of the time series.\n\n    The only mode supported is full. The returned object is trimmed to match the size of the original object. The parameter trim controls which side the trimming operates. Default is 'both'.\n\n    See the numpy documentation here : https://numpy.org/doc/stable/reference/generated/numpy.convolve.html\n\n    Parameters\n    ----------\n    array : np.ndarray\n        One dimensional input array\n    ep : None, optional\n        The epochs to apply the convolution\n    trim : str, optional\n        The side on which to trim the output of the convolution ('left', 'right', 'both' [default])\n\n    Returns\n    -------\n    Tsd, TsdFrame or TsdTensor\n        The convolved time series\n    \"\"\"\n    assert isinstance(array, np.ndarray), \"Input should be a 1-d numpy array.\"\n    assert array.ndim == 1, \"Input should be a one dimensional array.\"\n    assert trim in [\n        \"both\",\n        \"left\",\n        \"right\",\n    ], \"Unknow argument. trim should be 'both', 'left' or 'right'.\"\n\n    if ep is None:\n        ep = self.time_support\n\n    time_array = self.index.values\n    data_array = self.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if data_array.ndim == 1:\n        new_data_array = np.zeros(data_array.shape)\n        k = array.shape[0]\n        for s, e in zip(starts, ends):\n            idx_s = np.searchsorted(time_array, s)\n            idx_e = np.searchsorted(time_array, e, side=\"right\")\n\n            t = idx_e - idx_s\n            if trim == \"left\":\n                cut = (k - 1, t + k - 1)\n            elif trim == \"right\":\n                cut = (0, t)\n            else:\n                cut = ((1 - k % 2) + (k - 1) // 2, t + k - 1 - ((k - 1) // 2))\n            # scipy is actually faster for Tsd\n            new_data_array[idx_s:idx_e] = signal.convolve(\n                data_array[idx_s:idx_e], array\n            )[cut[0] : cut[1]]\n\n        return self.__class__(t=time_array, d=new_data_array, time_support=ep)\n    else:\n        new_data_array = np.zeros(data_array.shape)\n        for s, e in zip(starts, ends):\n            idx_s = np.searchsorted(time_array, s)\n            idx_e = np.searchsorted(time_array, e, side=\"right\")\n            new_data_array[idx_s:idx_e] = pjitconvolve(\n                data_array[idx_s:idx_e], array, trim=trim\n            )\n\n        return self.__class__(t=time_array, d=new_data_array, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.smooth","title":"smooth","text":"<pre><code>smooth(std, size)\n</code></pre> <p>Smooth a time series with a gaussian kernel. std is the standard deviation and size is the number of point of the window.</p> <p>See the scipy documentation : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.gaussian.html</p> <p>Parameters:</p> Name Type Description Default <code>std</code> <code>int</code> <p>Standard deviation</p> required <code>size</code> <code>int</code> <p>Description</p> required <p>Returns:</p> Type Description <code>(Tsd, TsdFrame, TsdTensor)</code> <p>Time series convolved with a gaussian kernel</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def smooth(self, std, size):\n    \"\"\"Smooth a time series with a gaussian kernel. std is the standard deviation and size is the number of point of the window.\n\n    See the scipy documentation : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.gaussian.html\n\n    Parameters\n    ----------\n    std : int\n        Standard deviation\n    size : int\n        Description\n\n    Returns\n    -------\n    Tsd, TsdFrame, TsdTensor\n        Time series convolved with a gaussian kernel\n    \"\"\"\n    assert isinstance(std, int), \"std should be type int\"\n    assert isinstance(size, int), \"size should be type int\"\n    window = signal.windows.gaussian(size, std=std)\n    window = window / window.sum()\n    return self.convolve(window)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.interpolate","title":"interpolate","text":"<pre><code>interpolate(ts, ep=None, left=None, right=None)\n</code></pre> <p>Wrapper of the numpy linear interpolation method. See https://numpy.org/doc/stable/reference/generated/numpy.interp.html for an explanation of the parameters. The argument ts should be Ts, Tsd, TsdFrame, TsdTensor to ensure interpolating from sorted timestamps in the right unit,</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>(Ts, Tsd or TsdFrame)</code> <p>The object holding the timestamps</p> required <code>ep</code> <code>IntervalSet</code> <p>The epochs to use to interpolate. If None, the time support of Tsd is used.</p> <code>None</code> <code>left</code> <code>None</code> <p>Value to return for ts &lt; tsd[0], default is tsd[0].</p> <code>None</code> <code>right</code> <code>None</code> <p>Value to return for ts &gt; tsd[-1], default is tsd[-1].</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def interpolate(self, ts, ep=None, left=None, right=None):\n    \"\"\"Wrapper of the numpy linear interpolation method. See https://numpy.org/doc/stable/reference/generated/numpy.interp.html for an explanation of the parameters.\n    The argument ts should be Ts, Tsd, TsdFrame, TsdTensor to ensure interpolating from sorted timestamps in the right unit,\n\n    Parameters\n    ----------\n    ts : Ts, Tsd or TsdFrame\n        The object holding the timestamps\n    ep : IntervalSet, optional\n        The epochs to use to interpolate. If None, the time support of Tsd is used.\n    left : None, optional\n        Value to return for ts &lt; tsd[0], default is tsd[0].\n    right : None, optional\n        Value to return for ts &gt; tsd[-1], default is tsd[-1].\n    \"\"\"\n    if not isinstance(ts, (Ts, Tsd, TsdFrame, TsdTensor)):\n        raise RuntimeError(\n            \"First argument should be an instance of Ts, Tsd or TsdFrame\"\n        )\n\n    if not isinstance(ep, IntervalSet):\n        ep = self.time_support\n\n    new_t = ts.restrict(ep).index\n\n    new_shape = (\n        len(new_t) if self.values.ndim == 1 else (len(new_t),) + self.shape[1:]\n    )\n    new_d = np.full(new_shape, np.nan)\n\n    start = 0\n    for i in range(len(ep)):\n        t = ts.get(ep.loc[i, \"start\"], ep.loc[i, \"end\"])\n        tmp = self.get(ep.loc[i, \"start\"], ep.loc[i, \"end\"])\n\n        if len(t) and len(tmp):\n            if self.values.ndim == 1:\n                new_d[start : start + len(t)] = np.interp(\n                    t.index.values,\n                    tmp.index.values,\n                    tmp.values,\n                    left=left,\n                    right=right,\n                )\n            else:\n                interpolated_values = np.apply_along_axis(\n                    lambda row: np.interp(\n                        t.index.values,\n                        tmp.index.values,\n                        row,\n                        left=left,\n                        right=right,\n                    ),\n                    0,\n                    tmp.values,\n                )\n                new_d[start : start + len(t), ...] = interpolated_values\n\n        start += len(t)\n    kwargs_dict = dict(time_support=ep)\n    if hasattr(self, \"columns\"):\n        kwargs_dict[\"columns\"] = self.columns\n    return self.__class__(t=new_t, d=new_d, **kwargs_dict)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.__init__","title":"__init__","text":"<pre><code>__init__(t, d, time_units='s', time_support=None, **kwargs)\n</code></pre> <p>TsdTensor initializer</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>the time index t</p> required <code>d</code> <code>ndarray</code> <p>The data</p> required <code>time_units</code> <code>str</code> <p>The time units in which times are specified ('us', 'ms', 's' [default]).</p> <code>'s'</code> <code>time_support</code> <code>IntervalSet</code> <p>The time support of the TsdFrame object</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def __init__(self, t, d, time_units=\"s\", time_support=None, **kwargs):\n    \"\"\"\n    TsdTensor initializer\n\n    Parameters\n    ----------\n    t : numpy.ndarray\n        the time index t\n    d : numpy.ndarray\n        The data\n    time_units : str, optional\n        The time units in which times are specified ('us', 'ms', 's' [default]).\n    time_support : IntervalSet, optional\n        The time support of the TsdFrame object\n    \"\"\"\n    if isinstance(t, np.ndarray) and d is None:\n        raise RuntimeError(\"Missing argument d when initializing TsdTensor\")\n\n    if isinstance(t, (list, tuple)):\n        t = np.array(t)\n    if isinstance(d, (list, tuple)):\n        d = np.array(d)\n\n    assert (\n        d.ndim &gt;= 3\n    ), \"Data should have more than 2 dimensions. If ndim &lt; 3, use TsdFrame or Tsd object\"\n\n    if isinstance(t, TsIndex):\n        self.index = t\n    else:\n        # Checking timestamps\n        self.index = TsIndex(t, time_units)\n\n    if len(self.index) != len(d):\n        raise ValueError(\n            \"Length of values \"\n            f\"({len(d)}) \"\n            \"does not match length of index \"\n            f\"({len(self.index)})\"\n        )\n\n    if len(self.index):\n        if isinstance(time_support, IntervalSet):\n            starts = time_support.start.values\n            ends = time_support.end.values\n            t, d = jitrestrict(self.index.values, d, starts, ends)\n            self.index = TsIndex(t)\n            self.values = d\n        else:\n            time_support = IntervalSet(start=self.index[0], end=self.index[-1])\n            self.values = d\n\n        self.time_support = time_support\n        self.rate = self.index.shape[0] / np.sum(\n            time_support.values[:, 1] - time_support.values[:, 0]\n        )\n    else:\n        self.rate = np.NaN\n        self.values = np.empty(0)\n        self.time_support = IntervalSet(start=[], end=[])\n\n    self.nap_class = self.__class__.__name__\n    self.dtype = self.values.dtype\n    self._initialized = True\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdTensor.save","title":"save","text":"<pre><code>save(filename)\n</code></pre> <p>Save TsdTensor object in npz format. The file will contain the timestamps, the data and the time support.</p> <p>The main purpose of this function is to save small/medium sized time series objects. For example, you extracted several channels from your recording and filtered them. You can save the filtered channels as a npz to avoid reprocessing it.</p> <p>You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end', 'type' and 'columns' for columns names.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsdtensor = nap.TsdTensor(t=np.array([0., 1.]), d = np.zeros((2,3,4)))\n&gt;&gt;&gt; tsdtensor.save(\"my_path/my_tsdtensor.npz\")\n</code></pre> <p>Here I can retrieve my data with numpy directly:</p> <pre><code>&gt;&gt;&gt; file = np.load(\"my_path/my_tsdtensor.npz\")\n&gt;&gt;&gt; print(list(file.keys()))\n['t', 'd', 'start', 'end', ''type']\n&gt;&gt;&gt; print(file['t'])\n[0. 1.]\n</code></pre> <p>It is then easy to recreate the TsdTensor object.</p> <pre><code>&gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n&gt;&gt;&gt; nap.TsdTensor(t=file['t'], d=file['d'], time_support=time_support)\nTime (s)\n0.0       [[[0.0 ...]]]\n1.0       [[[0.0 ...]]]\n</code></pre> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If filename is not str, path does not exist or filename is a directory.</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def save(self, filename):\n    \"\"\"\n    Save TsdTensor object in npz format. The file will contain the timestamps, the\n    data and the time support.\n\n    The main purpose of this function is to save small/medium sized time series\n    objects. For example, you extracted several channels from your recording and\n    filtered them. You can save the filtered channels as a npz to avoid\n    reprocessing it.\n\n    You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end', 'type'\n    and 'columns' for columns names.\n\n    Parameters\n    ----------\n    filename : str\n        The filename\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsdtensor = nap.TsdTensor(t=np.array([0., 1.]), d = np.zeros((2,3,4)))\n    &gt;&gt;&gt; tsdtensor.save(\"my_path/my_tsdtensor.npz\")\n\n    Here I can retrieve my data with numpy directly:\n\n    &gt;&gt;&gt; file = np.load(\"my_path/my_tsdtensor.npz\")\n    &gt;&gt;&gt; print(list(file.keys()))\n    ['t', 'd', 'start', 'end', ''type']\n    &gt;&gt;&gt; print(file['t'])\n    [0. 1.]\n\n    It is then easy to recreate the TsdTensor object.\n    &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n    &gt;&gt;&gt; nap.TsdTensor(t=file['t'], d=file['d'], time_support=time_support)\n    Time (s)\n    0.0       [[[0.0 ...]]]\n    1.0       [[[0.0 ...]]]\n\n\n    Raises\n    ------\n    RuntimeError\n        If filename is not str, path does not exist or filename is a directory.\n    \"\"\"\n    if not isinstance(filename, str):\n        raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n    if os.path.isdir(filename):\n        raise RuntimeError(\n            \"Invalid filename input. {} is directory.\".format(filename)\n        )\n\n    if not filename.lower().endswith(\".npz\"):\n        filename = filename + \".npz\"\n\n    dirname = os.path.dirname(filename)\n\n    if len(dirname) and not os.path.exists(dirname):\n        raise RuntimeError(\n            \"Path {} does not exist.\".format(os.path.dirname(filename))\n        )\n\n    np.savez(\n        filename,\n        t=self.index.values,\n        d=self.values,\n        start=self.time_support.start.values,\n        end=self.time_support.end.values,\n        type=np.array([self.nap_class], dtype=np.str_),\n    )\n\n    return\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame","title":"TsdFrame","text":"<p>             Bases: <code>NDArrayOperatorsMixin</code>, <code>_AbstractTsd</code></p> <p>TsdFrame</p> <p>Attributes:</p> Name Type Description <code>rate</code> <code>float</code> <p>Frequency of the time series (Hz) computed over the time support</p> <code>time_support</code> <code>IntervalSet</code> <p>The time support of the time series</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>class TsdFrame(NDArrayOperatorsMixin, _AbstractTsd):\n    \"\"\"\n    TsdFrame\n\n    Attributes\n    ----------\n    rate : float\n        Frequency of the time series (Hz) computed over the time support\n    time_support : IntervalSet\n        The time support of the time series\n    \"\"\"\n\n    def __init__(self, t, d=None, time_units=\"s\", time_support=None, columns=None):\n        \"\"\"\n        TsdFrame initializer\n        A pandas.DataFrame can be passed directly\n\n        Parameters\n        ----------\n        t : numpy.ndarray or pandas.DataFrame\n            the time index t,  or a pandas.DataFrame (if d is None)\n        d : numpy.ndarray\n            The data\n        time_units : str, optional\n            The time units in which times are specified ('us', 'ms', 's' [default]).\n        time_support : IntervalSet, optional\n            The time support of the TsdFrame object\n        columns : iterables\n            Column names\n        \"\"\"\n        if isinstance(t, np.ndarray) and d is None:\n            raise RuntimeError(\"Missing argument d when initializing TsdFrame\")\n\n        c = columns\n\n        if isinstance(t, pd.DataFrame):\n            d = t.values\n            c = t.columns.values\n            t = t.index.values\n\n        if isinstance(t, (list, tuple)):\n            t = np.array(t)\n        if isinstance(d, (list, tuple)):\n            d = np.array(d)\n\n        assert d.ndim &lt;= 2, \"Data should be 1 or 2 dimensional\"\n\n        if d.ndim == 1:\n            d = d[:, np.newaxis]\n\n        if isinstance(t, TsIndex):\n            self.index = t\n        else:\n            # Checking timestamps\n            self.index = TsIndex(t, time_units)\n\n        if len(self.index) != len(d):\n            raise ValueError(\n                \"Length of values \"\n                f\"({len(d)}) \"\n                \"does not match length of index \"\n                f\"({len(self.index)})\"\n            )\n\n        if c is None or len(c) != d.shape[1]:\n            c = np.arange(d.shape[1], dtype=\"int\")\n\n        if len(self.index):\n            if isinstance(time_support, IntervalSet):\n                starts = time_support.start.values\n                ends = time_support.end.values\n                t, d = jitrestrict(self.index.values, d, starts, ends)\n                self.index = TsIndex(t)\n                self.values = d\n            else:\n                time_support = IntervalSet(start=self.index[0], end=self.index[-1])\n                self.values = d\n\n            self.time_support = time_support\n            self.rate = self.index.shape[0] / np.sum(\n                time_support.values[:, 1] - time_support.values[:, 0]\n            )\n        else:\n            self.rate = np.NaN\n            self.values = np.empty(0)\n            self.time_support = IntervalSet(start=[], end=[])\n\n        self.columns = pd.Index(c)\n        self.nap_class = self.__class__.__name__\n        self.dtype = self.values.dtype\n        self._initialized = True\n\n    @property\n    def loc(self):\n        return _TsdFrameSliceHelper(self)\n\n    def __repr__(self):\n        headers = [\"Time (s)\"] + [str(k) for k in self.columns]\n        bottom = \"dtype: {}\".format(self.dtype) + \", shape: {}\".format(self.shape)\n\n        max_cols = 5\n        try:\n            max_cols = os.get_terminal_size()[0] // 16\n        except Exception:\n            import shutil\n\n            max_cols = shutil.get_terminal_size().columns // 16\n        else:\n            pass\n\n        if self.shape[1] &gt; max_cols:\n            headers = headers[0 : max_cols + 1] + [\"...\"]\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            if len(self):\n                table = []\n                end = [\"...\"] if self.shape[1] &gt; max_cols else []\n                if len(self) &gt; 51:\n                    for i, array in zip(self.index[0:5], self.values[0:5, 0:max_cols]):\n                        table.append([i] + [k for k in array] + end)\n                    table.append([\"...\"])\n                    for i, array in zip(\n                        self.index[-5:],\n                        self.values[\n                            self.values.shape[0] - 5 : self.values.shape[0], 0:max_cols\n                        ],\n                    ):\n                        table.append([i] + [k for k in array] + end)\n                    return tabulate(table, headers=headers) + \"\\n\" + bottom\n                else:\n                    for i, array in zip(self.index, self.values[:, 0:max_cols]):\n                        table.append([i] + [k for k in array] + end)\n                    return tabulate(table, headers=headers) + \"\\n\" + bottom\n            else:\n                return tabulate([], headers=headers) + \"\\n\" + bottom\n\n    def __getitem__(self, key, *args, **kwargs):\n        if (\n            isinstance(key, str)\n            or hasattr(key, \"__iter__\")\n            and all([isinstance(k, str) for k in key])\n        ):\n            return self.loc[key]\n        else:\n            return super().__getitem__(key, *args, **kwargs)\n\n    def __setitem__(self, key, value):\n        try:\n            if isinstance(key, str):\n                new_key = self.columns.get_indexer([key])\n                self.values.__setitem__((slice(None, None, None), new_key[0]), value)\n            elif hasattr(key, \"__iter__\") and all([isinstance(k, str) for k in key]):\n                new_key = self.columns.get_indexer(key)\n                self.values.__setitem__((slice(None, None, None), new_key), value)\n            else:\n                self.values.__setitem__(key, value)\n        except IndexError:\n            raise IndexError\n\n    def as_dataframe(self):\n        \"\"\"\n        Convert the TsdFrame object to a pandas.DataFrame object.\n\n        Returns\n        -------\n        out: pandas.DataFrame\n            _\n        \"\"\"\n        return pd.DataFrame(\n            index=self.index.values, data=self.values, columns=self.columns\n        )\n\n    def as_units(self, units=\"s\"):\n        \"\"\"\n        Returns a DataFrame with time expressed in the desired unit.\n\n        Parameters\n        ----------\n        units : str, optional\n            ('us', 'ms', 's' [default])\n\n        Returns\n        -------\n        pandas.DataFrame\n            the series object with adjusted times\n        \"\"\"\n        t = self.index.in_units(units)\n        if units == \"us\":\n            t = t.astype(np.int64)\n\n        df = pd.DataFrame(index=t, data=self.values)\n        df.index.name = \"Time (\" + str(units) + \")\"\n        df.columns = self.columns.copy()\n        return df\n\n    def save(self, filename):\n        \"\"\"\n        Save TsdFrame object in npz format. The file will contain the timestamps, the\n        data and the time support.\n\n        The main purpose of this function is to save small/medium sized time series\n        objects. For example, you extracted several channels from your recording and\n        filtered them. You can save the filtered channels as a npz to avoid\n        reprocessing it.\n\n        You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end', 'type'\n        and 'columns' for columns names.\n\n        Parameters\n        ----------\n        filename : str\n            The filename\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tsdframe = nap.TsdFrame(t=np.array([0., 1.]), d = np.array([[2, 3],[4,5]]), columns=['a', 'b'])\n        &gt;&gt;&gt; tsdframe.save(\"my_path/my_tsdframe.npz\")\n\n        Here I can retrieve my data with numpy directly:\n\n        &gt;&gt;&gt; file = np.load(\"my_path/my_tsdframe.npz\")\n        &gt;&gt;&gt; print(list(file.keys()))\n        ['t', 'd', 'start', 'end', 'columns', 'type']\n        &gt;&gt;&gt; print(file['t'])\n        [0. 1.]\n\n        It is then easy to recreate the Tsd object.\n        &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n        &gt;&gt;&gt; nap.TsdFrame(t=file['t'], d=file['d'], time_support=time_support, columns=file['columns'])\n                  a  b\n        Time (s)\n        0.0       2  3\n        1.0       4  5\n\n\n        Raises\n        ------\n        RuntimeError\n            If filename is not str, path does not exist or filename is a directory.\n        \"\"\"\n        if not isinstance(filename, str):\n            raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n        if os.path.isdir(filename):\n            raise RuntimeError(\n                \"Invalid filename input. {} is directory.\".format(filename)\n            )\n\n        if not filename.lower().endswith(\".npz\"):\n            filename = filename + \".npz\"\n\n        dirname = os.path.dirname(filename)\n\n        if len(dirname) and not os.path.exists(dirname):\n            raise RuntimeError(\n                \"Path {} does not exist.\".format(os.path.dirname(filename))\n            )\n\n        cols_name = self.columns\n        if cols_name.dtype == np.dtype(\"O\"):\n            cols_name = cols_name.astype(str)\n\n        np.savez(\n            filename,\n            t=self.index.values,\n            d=self.values,\n            start=self.time_support.start.values,\n            end=self.time_support.end.values,\n            columns=cols_name,\n            type=np.array([\"TsdFrame\"], dtype=np.str_),\n        )\n\n        return\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Object is immutable</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def __setattr__(self, name, value):\n    \"\"\"Object is immutable\"\"\"\n    if self._initialized:\n        raise RuntimeError(\n            \"Changing directly attributes is not permitted for {}.\".format(\n                self.nap_class\n            )\n        )\n    else:\n        object.__setattr__(self, name, value)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.times","title":"times","text":"<pre><code>times(units='s')\n</code></pre> <p>The time index of the object, returned as np.double in the desired time units.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>the time indexes</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def times(self, units=\"s\"):\n    \"\"\"\n    The time index of the object, returned as np.double in the desired time units.\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.ndarray\n        the time indexes\n    \"\"\"\n    return self.index.in_units(units)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.as_array","title":"as_array","text":"<pre><code>as_array()\n</code></pre> <p>Return the data as a numpy.ndarray</p> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_array(self):\n    \"\"\"\n    Return the data as a numpy.ndarray\n\n    Returns\n    -------\n    out: numpy.ndarray\n        _\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.data","title":"data","text":"<pre><code>data()\n</code></pre> <p>Return the data as a numpy.ndarray</p> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def data(self):\n    \"\"\"\n    Return the data as a numpy.ndarray\n\n    Returns\n    -------\n    out: numpy.ndarray\n        _\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy()\n</code></pre> <p>Return the data as a numpy.ndarray. Mostly useful for matplotlib plotting when calling <code>plot(tsd)</code></p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def to_numpy(self):\n    \"\"\"\n    Return the data as a numpy.ndarray. Mostly useful for matplotlib plotting when calling `plot(tsd)`\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.start_time","title":"start_time","text":"<pre><code>start_time(units='s')\n</code></pre> <p>The first time index in the time series object</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float64</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def start_time(self, units=\"s\"):\n    \"\"\"\n    The first time index in the time series object\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.float64\n        _\n    \"\"\"\n    if len(self.index):\n        return self.times(units=units)[0]\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.end_time","title":"end_time","text":"<pre><code>end_time(units='s')\n</code></pre> <p>The last time index in the time series object</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float64</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def end_time(self, units=\"s\"):\n    \"\"\"\n    The last time index in the time series object\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.float64\n        _\n    \"\"\"\n    if len(self.index):\n        return self.times(units=units)[-1]\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.value_from","title":"value_from","text":"<pre><code>value_from(data, ep=None)\n</code></pre> <p>Replace the value with the closest value from Tsd/TsdFrame/TsdTensor argument</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Tsd / TsdFrame / TsdTensor</code> <p>The object holding the values to replace.</p> required <code>ep</code> <code>IntervalSet(optional)</code> <p>The IntervalSet object to restrict the operation. If None, the time support of the tsd input object is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd / TsdFrame / TsdTensor</code> <p>Object with the new values</p> <p>Examples:</p> <p>In this example, the ts object will receive the closest values in time from tsd.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100))) # random times\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,1000), d=np.random.rand(1000), time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 500, time_units = 's')\n</code></pre> <p>The variable ts is a time series object containing only nan. The tsd object containing the values, for example the tracking data, and the epoch to restrict the operation.</p> <pre><code>&gt;&gt;&gt; newts = ts.value_from(tsd, ep)\n</code></pre> <p>newts is the same size as ts restrict to ep.</p> <pre><code>&gt;&gt;&gt; print(len(ts.restrict(ep)), len(newts))\n    52 52\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def value_from(self, data, ep=None):\n    \"\"\"\n    Replace the value with the closest value from Tsd/TsdFrame/TsdTensor argument\n\n    Parameters\n    ----------\n    data : Tsd/TsdFrame/TsdTensor\n        The object holding the values to replace.\n    ep : IntervalSet (optional)\n        The IntervalSet object to restrict the operation.\n        If None, the time support of the tsd input object is used.\n\n    Returns\n    -------\n    out : Tsd/TsdFrame/TsdTensor\n        Object with the new values\n\n    Examples\n    --------\n    In this example, the ts object will receive the closest values in time from tsd.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100))) # random times\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,1000), d=np.random.rand(1000), time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 500, time_units = 's')\n\n    The variable ts is a time series object containing only nan.\n    The tsd object containing the values, for example the tracking data, and the epoch to restrict the operation.\n\n    &gt;&gt;&gt; newts = ts.value_from(tsd, ep)\n\n    newts is the same size as ts restrict to ep.\n\n    &gt;&gt;&gt; print(len(ts.restrict(ep)), len(newts))\n        52 52\n    \"\"\"\n    if not isinstance(data, (TsdTensor, TsdFrame, Tsd)):\n        raise RuntimeError(\n            \"The time series to align to should be Tsd/TsdFrame/TsdTensor.\"\n        )\n\n    if ep is None:\n        ep = data.time_support\n    time_array = self.index.values\n    time_target_array = data.index.values\n    data_target_array = data.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if data_target_array.ndim == 1:\n        t, d, ns, ne = jitvaluefrom(\n            time_array, time_target_array, data_target_array, starts, ends\n        )\n    else:\n        t, d, ns, ne = jitvaluefromtensor(\n            time_array, time_target_array, data_target_array, starts, ends\n        )\n\n    time_support = IntervalSet(start=ns, end=ne)\n\n    if isinstance(data, TsdFrame):\n        return TsdFrame(t=t, d=d, time_support=time_support, columns=data.columns)\n    else:\n        return data.__class__(t, d, time_support=time_support)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.count","title":"count","text":"<pre><code>count(*args, **kwargs)\n</code></pre> <p>Count occurences of events within bin_size or within a set of bins defined as an IntervalSet. You can call this function in multiple ways :</p> <ol> <li> <p>tsd.count(bin_size=1, time_units = 'ms') -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.</p> </li> <li> <p>tsd.count(1, ep=my_epochs) -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.</p> </li> <li> <p>tsd.count(ep=my_bins) -&gt; Count occurent of events within each epoch of the intervalSet object my_bins</p> </li> <li> <p>tsd.count() -&gt; Count occurent of events within each epoch of the time support.</p> </li> </ol> <p>bin_size should be seconds unless specified. If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>None or float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> required <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd</code> <p>A Tsd object indexed by the center of the bins.</p> <p>Examples:</p> <p>This example shows how to count events within bins of 0.1 second.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; bincount = ts.count(0.1)\n</code></pre> <p>An epoch can be specified:</p> <pre><code>&gt;&gt;&gt; ep = nap.IntervalSet(start = 100, end = 800, time_units = 's')\n&gt;&gt;&gt; bincount = ts.count(0.1, ep=ep)\n</code></pre> <p>And bincount automatically inherit ep as time support:</p> <pre><code>&gt;&gt;&gt; bincount.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0  100.0  800.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def count(self, *args, **kwargs):\n    \"\"\"\n    Count occurences of events within bin_size or within a set of bins defined as an IntervalSet.\n    You can call this function in multiple ways :\n\n    1. *tsd.count(bin_size=1, time_units = 'ms')*\n    -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.\n\n    2. *tsd.count(1, ep=my_epochs)*\n    -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.\n\n    3. *tsd.count(ep=my_bins)*\n    -&gt; Count occurent of events within each epoch of the intervalSet object my_bins\n\n    4. *tsd.count()*\n    -&gt; Count occurent of events within each epoch of the time support.\n\n    bin_size should be seconds unless specified.\n    If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.\n\n    Parameters\n    ----------\n    bin_size : None or float, optional\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: Tsd\n        A Tsd object indexed by the center of the bins.\n\n    Examples\n    --------\n    This example shows how to count events within bins of 0.1 second.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; bincount = ts.count(0.1)\n\n    An epoch can be specified:\n\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 100, end = 800, time_units = 's')\n    &gt;&gt;&gt; bincount = ts.count(0.1, ep=ep)\n\n    And bincount automatically inherit ep as time support:\n\n    &gt;&gt;&gt; bincount.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0  100.0  800.0\n    \"\"\"\n    bin_size = None\n    if \"bin_size\" in kwargs:\n        bin_size = kwargs[\"bin_size\"]\n        if isinstance(bin_size, int):\n            bin_size = float(bin_size)\n        if not isinstance(bin_size, float):\n            raise ValueError(\"bin_size argument should be float.\")\n    else:\n        for a in args:\n            if isinstance(a, (float, int)):\n                bin_size = float(a)\n\n    time_units = \"s\"\n    if \"time_units\" in kwargs:\n        time_units = kwargs[\"time_units\"]\n        if not isinstance(time_units, str):\n            raise ValueError(\"time_units argument should be 's', 'ms' or 'us'.\")\n    else:\n        for a in args:\n            if isinstance(a, str) and a in [\"s\", \"ms\", \"us\"]:\n                time_units = a\n\n    ep = self.time_support\n    if \"ep\" in kwargs:\n        ep = kwargs[\"ep\"]\n        if not isinstance(ep, IntervalSet):\n            raise ValueError(\"ep argument should be IntervalSet\")\n    else:\n        for a in args:\n            if isinstance(a, IntervalSet):\n                ep = a\n\n    time_array = self.index.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if isinstance(bin_size, (float, int)):\n        bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n        t, d = jitcount(time_array, starts, ends, bin_size)\n    else:\n        _, d = jittsrestrict_with_count(time_array, starts, ends)\n        t = starts + (ends - starts) / 2\n\n    return Tsd(t=t, d=d, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.restrict","title":"restrict","text":"<pre><code>restrict(iset)\n</code></pre> <p>Restricts a time series object to a set of time intervals delimited by an IntervalSet object</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>the IntervalSet object</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>(Ts, Tsd, TsdFrame or TsdTensor)</code> <p>Tsd object restricted to ep</p> <p>Examples:</p> <p>The Ts object is restrict to the intervals defined by ep.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=500, time_units='s')\n&gt;&gt;&gt; newts = ts.restrict(ep)\n</code></pre> <p>The time support of newts automatically inherit the epochs defined by ep.</p> <pre><code>&gt;&gt;&gt; newts.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0    0.0  500.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def restrict(self, iset):\n    \"\"\"\n    Restricts a time series object to a set of time intervals delimited by an IntervalSet object\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        the IntervalSet object\n\n    Returns\n    -------\n    out: Ts, Tsd, TsdFrame or TsdTensor\n        Tsd object restricted to ep\n\n    Examples\n    --------\n    The Ts object is restrict to the intervals defined by ep.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=500, time_units='s')\n    &gt;&gt;&gt; newts = ts.restrict(ep)\n\n    The time support of newts automatically inherit the epochs defined by ep.\n\n    &gt;&gt;&gt; newts.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0    0.0  500.0\n\n    \"\"\"\n    assert isinstance(iset, IntervalSet), \"Argument should be IntervalSet\"\n\n    time_array = self.index.values\n    starts = iset.start.values\n    ends = iset.end.values\n\n    if isinstance(self.values, np.ndarray):\n        data_array = self.values\n        t, d = jitrestrict(time_array, data_array, starts, ends)\n\n        if hasattr(self, \"columns\"):\n            return TsdFrame(t=t, d=d, time_support=iset, columns=self.columns)\n        else:\n            return self.__class__(t=t, d=d, time_support=iset)\n    else:\n        t = jittsrestrict(time_array, starts, ends)\n        return Ts(t, time_support=iset)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.bin_average","title":"bin_average","text":"<pre><code>bin_average(bin_size, ep=None, time_units='s')\n</code></pre> <p>Bin the data by averaging points within bin_size bin_size should be seconds unless specified. If no epochs is passed, the data will be binned based on the time support.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> <code>None</code> <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>(Tsd, TsdFrame, TsdTensor)</code> <p>A Tsd object indexed by the center of the bins and holding the averaged data points.</p> <p>Examples:</p> <p>This example shows how to bin data within bins of 0.1 second.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n&gt;&gt;&gt; bintsd = tsd.bin_average(0.1)\n</code></pre> <p>An epoch can be specified:</p> <pre><code>&gt;&gt;&gt; ep = nap.IntervalSet(start = 10, end = 80, time_units = 's')\n&gt;&gt;&gt; bintsd = tsd.bin_average(0.1, ep=ep)\n</code></pre> <p>And bintsd automatically inherit ep as time support:</p> <pre><code>&gt;&gt;&gt; bintsd.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0  10.0     80.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def bin_average(self, bin_size, ep=None, time_units=\"s\"):\n    \"\"\"\n    Bin the data by averaging points within bin_size\n    bin_size should be seconds unless specified.\n    If no epochs is passed, the data will be binned based on the time support.\n\n    Parameters\n    ----------\n    bin_size : float\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: Tsd, TsdFrame, TsdTensor\n        A Tsd object indexed by the center of the bins and holding the averaged data points.\n\n    Examples\n    --------\n    This example shows how to bin data within bins of 0.1 second.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n    &gt;&gt;&gt; bintsd = tsd.bin_average(0.1)\n\n    An epoch can be specified:\n\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 10, end = 80, time_units = 's')\n    &gt;&gt;&gt; bintsd = tsd.bin_average(0.1, ep=ep)\n\n    And bintsd automatically inherit ep as time support:\n\n    &gt;&gt;&gt; bintsd.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0  10.0     80.0\n    \"\"\"\n    if not isinstance(ep, IntervalSet):\n        ep = self.time_support\n\n    bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n\n    time_array = self.index.values\n    data_array = self.values\n    starts = ep.start.values\n    ends = ep.end.values\n    if data_array.ndim &gt; 1:\n        t, d = jitbin_array(time_array, data_array, starts, ends, bin_size)\n    else:\n        t, d = jitbin(time_array, data_array, starts, ends, bin_size)\n\n    if d.ndim == 1:\n        return Tsd(t=t, d=d, time_support=ep)\n    elif d.ndim == 2:\n        kwargs = {}\n        if hasattr(self, \"columns\"):\n            kwargs[\"columns\"] = self.columns\n        return TsdFrame(t=t, d=d, time_support=ep, **kwargs)\n    else:\n        return TsdTensor(t=t, d=d, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Copy the data, index and time support</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def copy(self):\n    \"\"\"Copy the data, index and time support\"\"\"\n    return self.__class__(\n        t=self.index.copy(), d=self.values.copy(), time_support=self.time_support\n    )\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.find_support","title":"find_support","text":"<pre><code>find_support(min_gap, time_units='s')\n</code></pre> <p>find the smallest (to a min_gap resolution) IntervalSet containing all the times in the Tsd</p> <p>Parameters:</p> Name Type Description Default <code>min_gap</code> <code>float or int</code> <p>minimal interval between timestamps</p> required <code>time_units</code> <code>str</code> <p>Time units of min gap</p> <code>'s'</code> <p>Returns:</p> Type Description <code>IntervalSet</code> <p>Description</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def find_support(self, min_gap, time_units=\"s\"):\n    \"\"\"\n    find the smallest (to a min_gap resolution) IntervalSet containing all the times in the Tsd\n\n    Parameters\n    ----------\n    min_gap : float or int\n        minimal interval between timestamps\n    time_units : str, optional\n        Time units of min gap\n\n    Returns\n    -------\n    IntervalSet\n        Description\n    \"\"\"\n    assert isinstance(min_gap, Number), \"min_gap should be a float or int\"\n    min_gap = TsIndex.format_timestamps(np.array([min_gap]), time_units)[0]\n    time_array = self.index.values\n\n    starts = [time_array[0]]\n    ends = []\n    for i in range(len(time_array) - 1):\n        if (time_array[i + 1] - time_array[i]) &gt; min_gap:\n            ends.append(time_array[i] + 1e-6)\n            starts.append(time_array[i + 1])\n\n    ends.append(time_array[-1] + 1e-6)\n\n    return IntervalSet(start=starts, end=ends)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.get","title":"get","text":"<pre><code>get(start, end=None, time_units='s')\n</code></pre> <p>Slice the time series from start to end such that all the timestamps satisfy start&lt;=t&lt;=end. If end is None, only the timepoint closest to start is returned.</p> <p>By default, the time support doesn't change. If you want to change the time support, use the restrict function.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float or int</code> <p>The start</p> required <code>end</code> <code>float or int</code> <p>The end</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def get(self, start, end=None, time_units=\"s\"):\n    \"\"\"Slice the time series from start to end such that all the timestamps satisfy start&lt;=t&lt;=end.\n    If end is None, only the timepoint closest to start is returned.\n\n    By default, the time support doesn't change. If you want to change the time support, use the restrict function.\n\n    Parameters\n    ----------\n    start : float or int\n        The start\n    end : float or int\n        The end\n    \"\"\"\n    assert isinstance(start, Number), \"start should be a float or int\"\n    time_array = self.index.values\n\n    if end is None:\n        start = TsIndex.format_timestamps(np.array([start]), time_units)[0]\n        idx = int(np.searchsorted(time_array, start))\n        if idx == 0:\n            return self[idx]\n        elif idx &gt;= self.shape[0]:\n            return self[-1]\n        else:\n            if start - time_array[idx - 1] &lt; time_array[idx] - start:\n                return self[idx - 1]\n            else:\n                return self[idx]\n    else:\n        assert isinstance(end, Number), \"end should be a float or int\"\n        assert start &lt; end, \"Start should not precede end\"\n        start, end = TsIndex.format_timestamps(np.array([start, end]), time_units)\n        idx_start = np.searchsorted(time_array, start)\n        idx_end = np.searchsorted(time_array, end, side=\"right\")\n        return self[idx_start:idx_end]\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.dropna","title":"dropna","text":"<pre><code>dropna(update_time_support=True)\n</code></pre> <p>Drop every rows containing NaNs. By default, the time support is updated to start and end around the time points that are non NaNs. To change this behavior, you can set update_time_support=False.</p> <p>Parameters:</p> Name Type Description Default <code>update_time_support</code> <code>bool</code> <code>True</code> <p>Returns:</p> Type Description <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The time series without the NaNs</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def dropna(self, update_time_support=True):\n    \"\"\"Drop every rows containing NaNs. By default, the time support is updated to start and end around the time points that are non NaNs.\n    To change this behavior, you can set update_time_support=False.\n\n    Parameters\n    ----------\n    update_time_support : bool, optional\n\n    Returns\n    -------\n    Tsd, TsdFrame or TsdTensor\n        The time series without the NaNs\n    \"\"\"\n    index_nan = np.any(np.isnan(self.values), axis=tuple(range(1, self.ndim)))\n    if np.all(index_nan):  # In case it's only NaNs\n        return self.__class__(\n            t=np.array([]), d=np.empty(tuple([0] + [d for d in self.shape[1:]]))\n        )\n\n    elif np.any(index_nan):\n        if update_time_support:\n            time_array = self.index.values\n            starts, ends = jitremove_nan(time_array, index_nan)\n\n            to_fix = starts == ends\n            if np.any(to_fix):\n                ends[\n                    to_fix\n                ] += 1e-6  # adding 1 millisecond in case of a single point\n\n            ep = IntervalSet(starts, ends)\n\n            return self.__class__(\n                t=time_array[~index_nan], d=self.values[~index_nan], time_support=ep\n            )\n\n        else:\n            return self[~index_nan]\n\n    else:\n        return self\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.convolve","title":"convolve","text":"<pre><code>convolve(array, ep=None, trim='both')\n</code></pre> <p>Return the discrete linear convolution of the time series with a one dimensional sequence.</p> <p>A parameter ep can control the epochs for which the convolution will apply. Otherwise the convolution is made over the time support.</p> <p>This function assume a constant sampling rate of the time series.</p> <p>The only mode supported is full. The returned object is trimmed to match the size of the original object. The parameter trim controls which side the trimming operates. Default is 'both'.</p> <p>See the numpy documentation here : https://numpy.org/doc/stable/reference/generated/numpy.convolve.html</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>One dimensional input array</p> required <code>ep</code> <code>None</code> <p>The epochs to apply the convolution</p> <code>None</code> <code>trim</code> <code>str</code> <p>The side on which to trim the output of the convolution ('left', 'right', 'both' [default])</p> <code>'both'</code> <p>Returns:</p> Type Description <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The convolved time series</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def convolve(self, array, ep=None, trim=\"both\"):\n    \"\"\"Return the discrete linear convolution of the time series with a one dimensional sequence.\n\n    A parameter ep can control the epochs for which the convolution will apply. Otherwise the convolution is made over the time support.\n\n    This function assume a constant sampling rate of the time series.\n\n    The only mode supported is full. The returned object is trimmed to match the size of the original object. The parameter trim controls which side the trimming operates. Default is 'both'.\n\n    See the numpy documentation here : https://numpy.org/doc/stable/reference/generated/numpy.convolve.html\n\n    Parameters\n    ----------\n    array : np.ndarray\n        One dimensional input array\n    ep : None, optional\n        The epochs to apply the convolution\n    trim : str, optional\n        The side on which to trim the output of the convolution ('left', 'right', 'both' [default])\n\n    Returns\n    -------\n    Tsd, TsdFrame or TsdTensor\n        The convolved time series\n    \"\"\"\n    assert isinstance(array, np.ndarray), \"Input should be a 1-d numpy array.\"\n    assert array.ndim == 1, \"Input should be a one dimensional array.\"\n    assert trim in [\n        \"both\",\n        \"left\",\n        \"right\",\n    ], \"Unknow argument. trim should be 'both', 'left' or 'right'.\"\n\n    if ep is None:\n        ep = self.time_support\n\n    time_array = self.index.values\n    data_array = self.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if data_array.ndim == 1:\n        new_data_array = np.zeros(data_array.shape)\n        k = array.shape[0]\n        for s, e in zip(starts, ends):\n            idx_s = np.searchsorted(time_array, s)\n            idx_e = np.searchsorted(time_array, e, side=\"right\")\n\n            t = idx_e - idx_s\n            if trim == \"left\":\n                cut = (k - 1, t + k - 1)\n            elif trim == \"right\":\n                cut = (0, t)\n            else:\n                cut = ((1 - k % 2) + (k - 1) // 2, t + k - 1 - ((k - 1) // 2))\n            # scipy is actually faster for Tsd\n            new_data_array[idx_s:idx_e] = signal.convolve(\n                data_array[idx_s:idx_e], array\n            )[cut[0] : cut[1]]\n\n        return self.__class__(t=time_array, d=new_data_array, time_support=ep)\n    else:\n        new_data_array = np.zeros(data_array.shape)\n        for s, e in zip(starts, ends):\n            idx_s = np.searchsorted(time_array, s)\n            idx_e = np.searchsorted(time_array, e, side=\"right\")\n            new_data_array[idx_s:idx_e] = pjitconvolve(\n                data_array[idx_s:idx_e], array, trim=trim\n            )\n\n        return self.__class__(t=time_array, d=new_data_array, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.smooth","title":"smooth","text":"<pre><code>smooth(std, size)\n</code></pre> <p>Smooth a time series with a gaussian kernel. std is the standard deviation and size is the number of point of the window.</p> <p>See the scipy documentation : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.gaussian.html</p> <p>Parameters:</p> Name Type Description Default <code>std</code> <code>int</code> <p>Standard deviation</p> required <code>size</code> <code>int</code> <p>Description</p> required <p>Returns:</p> Type Description <code>(Tsd, TsdFrame, TsdTensor)</code> <p>Time series convolved with a gaussian kernel</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def smooth(self, std, size):\n    \"\"\"Smooth a time series with a gaussian kernel. std is the standard deviation and size is the number of point of the window.\n\n    See the scipy documentation : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.gaussian.html\n\n    Parameters\n    ----------\n    std : int\n        Standard deviation\n    size : int\n        Description\n\n    Returns\n    -------\n    Tsd, TsdFrame, TsdTensor\n        Time series convolved with a gaussian kernel\n    \"\"\"\n    assert isinstance(std, int), \"std should be type int\"\n    assert isinstance(size, int), \"size should be type int\"\n    window = signal.windows.gaussian(size, std=std)\n    window = window / window.sum()\n    return self.convolve(window)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.interpolate","title":"interpolate","text":"<pre><code>interpolate(ts, ep=None, left=None, right=None)\n</code></pre> <p>Wrapper of the numpy linear interpolation method. See https://numpy.org/doc/stable/reference/generated/numpy.interp.html for an explanation of the parameters. The argument ts should be Ts, Tsd, TsdFrame, TsdTensor to ensure interpolating from sorted timestamps in the right unit,</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>(Ts, Tsd or TsdFrame)</code> <p>The object holding the timestamps</p> required <code>ep</code> <code>IntervalSet</code> <p>The epochs to use to interpolate. If None, the time support of Tsd is used.</p> <code>None</code> <code>left</code> <code>None</code> <p>Value to return for ts &lt; tsd[0], default is tsd[0].</p> <code>None</code> <code>right</code> <code>None</code> <p>Value to return for ts &gt; tsd[-1], default is tsd[-1].</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def interpolate(self, ts, ep=None, left=None, right=None):\n    \"\"\"Wrapper of the numpy linear interpolation method. See https://numpy.org/doc/stable/reference/generated/numpy.interp.html for an explanation of the parameters.\n    The argument ts should be Ts, Tsd, TsdFrame, TsdTensor to ensure interpolating from sorted timestamps in the right unit,\n\n    Parameters\n    ----------\n    ts : Ts, Tsd or TsdFrame\n        The object holding the timestamps\n    ep : IntervalSet, optional\n        The epochs to use to interpolate. If None, the time support of Tsd is used.\n    left : None, optional\n        Value to return for ts &lt; tsd[0], default is tsd[0].\n    right : None, optional\n        Value to return for ts &gt; tsd[-1], default is tsd[-1].\n    \"\"\"\n    if not isinstance(ts, (Ts, Tsd, TsdFrame, TsdTensor)):\n        raise RuntimeError(\n            \"First argument should be an instance of Ts, Tsd or TsdFrame\"\n        )\n\n    if not isinstance(ep, IntervalSet):\n        ep = self.time_support\n\n    new_t = ts.restrict(ep).index\n\n    new_shape = (\n        len(new_t) if self.values.ndim == 1 else (len(new_t),) + self.shape[1:]\n    )\n    new_d = np.full(new_shape, np.nan)\n\n    start = 0\n    for i in range(len(ep)):\n        t = ts.get(ep.loc[i, \"start\"], ep.loc[i, \"end\"])\n        tmp = self.get(ep.loc[i, \"start\"], ep.loc[i, \"end\"])\n\n        if len(t) and len(tmp):\n            if self.values.ndim == 1:\n                new_d[start : start + len(t)] = np.interp(\n                    t.index.values,\n                    tmp.index.values,\n                    tmp.values,\n                    left=left,\n                    right=right,\n                )\n            else:\n                interpolated_values = np.apply_along_axis(\n                    lambda row: np.interp(\n                        t.index.values,\n                        tmp.index.values,\n                        row,\n                        left=left,\n                        right=right,\n                    ),\n                    0,\n                    tmp.values,\n                )\n                new_d[start : start + len(t), ...] = interpolated_values\n\n        start += len(t)\n    kwargs_dict = dict(time_support=ep)\n    if hasattr(self, \"columns\"):\n        kwargs_dict[\"columns\"] = self.columns\n    return self.__class__(t=new_t, d=new_d, **kwargs_dict)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.__init__","title":"__init__","text":"<pre><code>__init__(\n    t,\n    d=None,\n    time_units=\"s\",\n    time_support=None,\n    columns=None,\n)\n</code></pre> <p>TsdFrame initializer A pandas.DataFrame can be passed directly</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray or DataFrame</code> <p>the time index t,  or a pandas.DataFrame (if d is None)</p> required <code>d</code> <code>ndarray</code> <p>The data</p> <code>None</code> <code>time_units</code> <code>str</code> <p>The time units in which times are specified ('us', 'ms', 's' [default]).</p> <code>'s'</code> <code>time_support</code> <code>IntervalSet</code> <p>The time support of the TsdFrame object</p> <code>None</code> <code>columns</code> <code>iterables</code> <p>Column names</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def __init__(self, t, d=None, time_units=\"s\", time_support=None, columns=None):\n    \"\"\"\n    TsdFrame initializer\n    A pandas.DataFrame can be passed directly\n\n    Parameters\n    ----------\n    t : numpy.ndarray or pandas.DataFrame\n        the time index t,  or a pandas.DataFrame (if d is None)\n    d : numpy.ndarray\n        The data\n    time_units : str, optional\n        The time units in which times are specified ('us', 'ms', 's' [default]).\n    time_support : IntervalSet, optional\n        The time support of the TsdFrame object\n    columns : iterables\n        Column names\n    \"\"\"\n    if isinstance(t, np.ndarray) and d is None:\n        raise RuntimeError(\"Missing argument d when initializing TsdFrame\")\n\n    c = columns\n\n    if isinstance(t, pd.DataFrame):\n        d = t.values\n        c = t.columns.values\n        t = t.index.values\n\n    if isinstance(t, (list, tuple)):\n        t = np.array(t)\n    if isinstance(d, (list, tuple)):\n        d = np.array(d)\n\n    assert d.ndim &lt;= 2, \"Data should be 1 or 2 dimensional\"\n\n    if d.ndim == 1:\n        d = d[:, np.newaxis]\n\n    if isinstance(t, TsIndex):\n        self.index = t\n    else:\n        # Checking timestamps\n        self.index = TsIndex(t, time_units)\n\n    if len(self.index) != len(d):\n        raise ValueError(\n            \"Length of values \"\n            f\"({len(d)}) \"\n            \"does not match length of index \"\n            f\"({len(self.index)})\"\n        )\n\n    if c is None or len(c) != d.shape[1]:\n        c = np.arange(d.shape[1], dtype=\"int\")\n\n    if len(self.index):\n        if isinstance(time_support, IntervalSet):\n            starts = time_support.start.values\n            ends = time_support.end.values\n            t, d = jitrestrict(self.index.values, d, starts, ends)\n            self.index = TsIndex(t)\n            self.values = d\n        else:\n            time_support = IntervalSet(start=self.index[0], end=self.index[-1])\n            self.values = d\n\n        self.time_support = time_support\n        self.rate = self.index.shape[0] / np.sum(\n            time_support.values[:, 1] - time_support.values[:, 0]\n        )\n    else:\n        self.rate = np.NaN\n        self.values = np.empty(0)\n        self.time_support = IntervalSet(start=[], end=[])\n\n    self.columns = pd.Index(c)\n    self.nap_class = self.__class__.__name__\n    self.dtype = self.values.dtype\n    self._initialized = True\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.as_dataframe","title":"as_dataframe","text":"<pre><code>as_dataframe()\n</code></pre> <p>Convert the TsdFrame object to a pandas.DataFrame object.</p> <p>Returns:</p> Name Type Description <code>out</code> <code>DataFrame</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_dataframe(self):\n    \"\"\"\n    Convert the TsdFrame object to a pandas.DataFrame object.\n\n    Returns\n    -------\n    out: pandas.DataFrame\n        _\n    \"\"\"\n    return pd.DataFrame(\n        index=self.index.values, data=self.values, columns=self.columns\n    )\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.as_units","title":"as_units","text":"<pre><code>as_units(units='s')\n</code></pre> <p>Returns a DataFrame with time expressed in the desired unit.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>the series object with adjusted times</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_units(self, units=\"s\"):\n    \"\"\"\n    Returns a DataFrame with time expressed in the desired unit.\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    pandas.DataFrame\n        the series object with adjusted times\n    \"\"\"\n    t = self.index.in_units(units)\n    if units == \"us\":\n        t = t.astype(np.int64)\n\n    df = pd.DataFrame(index=t, data=self.values)\n    df.index.name = \"Time (\" + str(units) + \")\"\n    df.columns = self.columns.copy()\n    return df\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.TsdFrame.save","title":"save","text":"<pre><code>save(filename)\n</code></pre> <p>Save TsdFrame object in npz format. The file will contain the timestamps, the data and the time support.</p> <p>The main purpose of this function is to save small/medium sized time series objects. For example, you extracted several channels from your recording and filtered them. You can save the filtered channels as a npz to avoid reprocessing it.</p> <p>You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end', 'type' and 'columns' for columns names.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsdframe = nap.TsdFrame(t=np.array([0., 1.]), d = np.array([[2, 3],[4,5]]), columns=['a', 'b'])\n&gt;&gt;&gt; tsdframe.save(\"my_path/my_tsdframe.npz\")\n</code></pre> <p>Here I can retrieve my data with numpy directly:</p> <pre><code>&gt;&gt;&gt; file = np.load(\"my_path/my_tsdframe.npz\")\n&gt;&gt;&gt; print(list(file.keys()))\n['t', 'd', 'start', 'end', 'columns', 'type']\n&gt;&gt;&gt; print(file['t'])\n[0. 1.]\n</code></pre> <p>It is then easy to recreate the Tsd object.</p> <pre><code>&gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n&gt;&gt;&gt; nap.TsdFrame(t=file['t'], d=file['d'], time_support=time_support, columns=file['columns'])\n          a  b\nTime (s)\n0.0       2  3\n1.0       4  5\n</code></pre> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If filename is not str, path does not exist or filename is a directory.</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def save(self, filename):\n    \"\"\"\n    Save TsdFrame object in npz format. The file will contain the timestamps, the\n    data and the time support.\n\n    The main purpose of this function is to save small/medium sized time series\n    objects. For example, you extracted several channels from your recording and\n    filtered them. You can save the filtered channels as a npz to avoid\n    reprocessing it.\n\n    You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end', 'type'\n    and 'columns' for columns names.\n\n    Parameters\n    ----------\n    filename : str\n        The filename\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsdframe = nap.TsdFrame(t=np.array([0., 1.]), d = np.array([[2, 3],[4,5]]), columns=['a', 'b'])\n    &gt;&gt;&gt; tsdframe.save(\"my_path/my_tsdframe.npz\")\n\n    Here I can retrieve my data with numpy directly:\n\n    &gt;&gt;&gt; file = np.load(\"my_path/my_tsdframe.npz\")\n    &gt;&gt;&gt; print(list(file.keys()))\n    ['t', 'd', 'start', 'end', 'columns', 'type']\n    &gt;&gt;&gt; print(file['t'])\n    [0. 1.]\n\n    It is then easy to recreate the Tsd object.\n    &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n    &gt;&gt;&gt; nap.TsdFrame(t=file['t'], d=file['d'], time_support=time_support, columns=file['columns'])\n              a  b\n    Time (s)\n    0.0       2  3\n    1.0       4  5\n\n\n    Raises\n    ------\n    RuntimeError\n        If filename is not str, path does not exist or filename is a directory.\n    \"\"\"\n    if not isinstance(filename, str):\n        raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n    if os.path.isdir(filename):\n        raise RuntimeError(\n            \"Invalid filename input. {} is directory.\".format(filename)\n        )\n\n    if not filename.lower().endswith(\".npz\"):\n        filename = filename + \".npz\"\n\n    dirname = os.path.dirname(filename)\n\n    if len(dirname) and not os.path.exists(dirname):\n        raise RuntimeError(\n            \"Path {} does not exist.\".format(os.path.dirname(filename))\n        )\n\n    cols_name = self.columns\n    if cols_name.dtype == np.dtype(\"O\"):\n        cols_name = cols_name.astype(str)\n\n    np.savez(\n        filename,\n        t=self.index.values,\n        d=self.values,\n        start=self.time_support.start.values,\n        end=self.time_support.end.values,\n        columns=cols_name,\n        type=np.array([\"TsdFrame\"], dtype=np.str_),\n    )\n\n    return\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd","title":"Tsd","text":"<p>             Bases: <code>NDArrayOperatorsMixin</code>, <code>_AbstractTsd</code></p> <p>A container around numpy.ndarray specialized for neurophysiology time series.</p> <p>Tsd provides standardized time representation, plus various functions for manipulating times series.</p> <p>Attributes:</p> Name Type Description <code>rate</code> <code>float</code> <p>Frequency of the time series (Hz) computed over the time support</p> <code>time_support</code> <code>IntervalSet</code> <p>The time support of the time series</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>class Tsd(NDArrayOperatorsMixin, _AbstractTsd):\n    \"\"\"\n    A container around numpy.ndarray specialized for neurophysiology time series.\n\n    Tsd provides standardized time representation, plus various functions for manipulating times series.\n\n    Attributes\n    ----------\n    rate : float\n        Frequency of the time series (Hz) computed over the time support\n    time_support : IntervalSet\n        The time support of the time series\n    \"\"\"\n\n    def __init__(self, t, d=None, time_units=\"s\", time_support=None):\n        \"\"\"\n        Tsd Initializer.\n\n        Parameters\n        ----------\n        t : numpy.ndarray or pandas.Series\n            An object transformable in a time series, or a pandas.Series equivalent (if d is None)\n        d : numpy.ndarray, optional\n            The data of the time series\n        time_units : str, optional\n            The time units in which times are specified ('us', 'ms', 's' [default])\n        time_support : IntervalSet, optional\n            The time support of the tsd object\n        \"\"\"\n        if isinstance(t, np.ndarray) and d is None:\n            raise RuntimeError(\"Missing argument d when initializing Tsd\")\n\n        if isinstance(t, pd.Series):\n            d = t.values\n            t = t.index.values\n\n        if isinstance(t, (list, tuple)):\n            t = np.array(t)\n        if isinstance(d, (list, tuple)):\n            d = np.array(d)\n\n        assert d.ndim == 1, \"Data should be 1 dimension\"\n\n        if isinstance(t, TsIndex):\n            self.index = t\n        else:\n            # Checking timestamps\n            self.index = TsIndex(t, time_units)\n\n        if len(self.index) != len(d):\n            raise ValueError(\n                \"Length of values \"\n                f\"({len(d)}) \"\n                \"does not match length of index \"\n                f\"({len(self.index)})\"\n            )\n\n        if len(self.index):\n            if isinstance(time_support, IntervalSet):\n                starts = time_support.start.values\n                ends = time_support.end.values\n                t, d = jitrestrict(self.index.values, d, starts, ends)\n                self.index = TsIndex(t)\n                self.values = d\n            else:\n                time_support = IntervalSet(start=self.index[0], end=self.index[-1])\n                self.values = d\n\n            self.time_support = time_support\n            self.rate = self.index.shape[0] / np.sum(\n                time_support.values[:, 1] - time_support.values[:, 0]\n            )\n        else:\n            self.rate = np.NaN\n            self.values = np.empty(0)\n            self.time_support = IntervalSet(start=[], end=[])\n\n        self.nap_class = self.__class__.__name__\n        self.dtype = self.values.dtype\n        self._initialized = True\n\n    def __repr__(self):\n        headers = [\"Time (s)\", \"\"]\n        bottom = \"dtype: {}\".format(self.dtype) + \", shape: {}\".format(self.shape)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            if len(self):\n                if len(self) &lt; 51:\n                    return (\n                        tabulate(\n                            np.vstack((self.index, self.values)).T,\n                            headers=headers,\n                            colalign=(\"left\",),\n                        )\n                        + \"\\n\"\n                        + bottom\n                    )\n                else:\n                    table = []\n                    for i, v in zip(self.index[0:5], self.values[0:5]):\n                        table.append([i, v])\n                    table.append([\"...\"])\n                    for i, v in zip(\n                        self.index[-5:],\n                        self.values[self.values.shape[0] - 5 : self.values.shape[0]],\n                    ):\n                        table.append([i, v])\n\n                    return (\n                        tabulate(table, headers=headers, colalign=(\"left\",))\n                        + \"\\n\"\n                        + bottom\n                    )\n            else:\n                return tabulate([], headers=headers) + \"\\n\" + bottom\n\n    def as_series(self):\n        \"\"\"\n        Convert the Ts/Tsd object to a pandas.Series object.\n\n        Returns\n        -------\n        out: pandas.Series\n            _\n        \"\"\"\n        return pd.Series(\n            index=self.index.values, data=self.values, copy=True, dtype=\"float64\"\n        )\n\n    def as_units(self, units=\"s\"):\n        \"\"\"\n        Returns a pandas Series with time expressed in the desired unit.\n\n        Parameters\n        ----------\n        units : str, optional\n            ('us', 'ms', 's' [default])\n\n        Returns\n        -------\n        pandas.Series\n            the series object with adjusted times\n        \"\"\"\n        ss = self.as_series()\n        t = self.index.in_units(units)\n        if units == \"us\":\n            t = t.astype(np.int64)\n        ss.index = t\n        ss.index.name = \"Time (\" + str(units) + \")\"\n        return ss\n\n    def threshold(self, thr, method=\"above\"):\n        \"\"\"\n        Apply a threshold function to the tsd to return a new tsd\n        with the time support being the epochs above/below/&gt;=/&lt;= the threshold\n\n        Parameters\n        ----------\n        thr : float\n            The threshold value\n        method : str, optional\n            The threshold method (above/below/aboveequal/belowequal)\n\n        Returns\n        -------\n        out: Tsd\n            All the time points below/ above/greater than equal to/less than equal to the threshold\n\n        Raises\n        ------\n        ValueError\n            Raise an error if method is not 'below' or 'above'\n        RuntimeError\n            Raise an error if thr is too high/low and no epochs is found.\n\n        Examples\n        --------\n        This example finds all epoch above 0.5 within the tsd object.\n\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n        &gt;&gt;&gt; newtsd = tsd.threshold(0.5)\n\n        The epochs with the times above/below the threshold can be accessed through the time support:\n\n        &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.arange(100), time_units='s')\n        &gt;&gt;&gt; tsd.threshold(50).time_support\n        &gt;&gt;&gt;    start   end\n        &gt;&gt;&gt; 0   50.5  99.0\n\n        \"\"\"\n        time_array = self.index.values\n        data_array = self.values\n        starts = self.time_support.start.values\n        ends = self.time_support.end.values\n        if method not in [\"above\", \"below\", \"aboveequal\", \"belowequal\"]:\n            raise ValueError(\n                \"Method {} for thresholding is not accepted.\".format(method)\n            )\n\n        t, d, ns, ne = jitthreshold(time_array, data_array, starts, ends, thr, method)\n        time_support = IntervalSet(start=ns, end=ne)\n        return Tsd(t=t, d=d, time_support=time_support)\n\n    def to_tsgroup(self):\n        \"\"\"\n        Convert Tsd to a TsGroup by grouping timestamps with the same values.\n        By default, the values are converted to integers.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tsd = nap.Tsd(t = np.array([0, 1, 2, 3]), d = np.array([0, 2, 0, 1]))\n        Time (s)\n        0.0    0\n        1.0    2\n        2.0    0\n        3.0    1\n        dtype: int64\n\n        &gt;&gt;&gt; tsd.to_tsgroup()\n        Index    rate\n        -------  ------\n            0    0.67\n            1    0.33\n            2    0.33\n\n        The reverse operation can be done with the TsGroup.to_tsd function :\n\n        &gt;&gt;&gt; tsgroup.to_tsd()\n        Time (s)\n        0.0    0.0\n        1.0    2.0\n        2.0    0.0\n        3.0    1.0\n        dtype: float64\n\n        Returns\n        -------\n        TsGroup\n            Grouped timestamps\n\n        \"\"\"\n        ts_group = importlib.import_module(\".ts_group\", \"pynapple.core\")\n        t = self.index.values\n        d = self.values.astype(\"int\")\n        idx = np.unique(d)\n\n        group = {}\n        for k in idx:\n            group[k] = Ts(t=t[d == k], time_support=self.time_support)\n\n        return ts_group.TsGroup(group, time_support=self.time_support)\n\n    def save(self, filename):\n        \"\"\"\n        Save Tsd object in npz format. The file will contain the timestamps, the\n        data and the time support.\n\n        The main purpose of this function is to save small/medium sized time series\n        objects. For example, you extracted one channel from your recording and\n        filtered it. You can save the filtered channel as a npz to avoid\n        reprocessing it.\n\n        You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end' and 'type'.\n        See the example below.\n\n        Parameters\n        ----------\n        filename : str\n            The filename\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tsd = nap.Tsd(t=np.array([0., 1.]), d = np.array([2, 3]))\n        &gt;&gt;&gt; tsd.save(\"my_path/my_tsd.npz\")\n\n        Here I can retrieve my data with numpy directly:\n\n        &gt;&gt;&gt; file = np.load(\"my_path/my_tsd.npz\")\n        &gt;&gt;&gt; print(list(file.keys()))\n        ['t', 'd', 'start', 'end', 'type']\n        &gt;&gt;&gt; print(file['t'])\n        [0. 1.]\n\n        It is then easy to recreate the Tsd object.\n        &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n        &gt;&gt;&gt; nap.Tsd(t=file['t'], d=file['d'], time_support=time_support)\n        Time (s)\n        0.0    2\n        1.0    3\n        dtype: int64\n\n        Raises\n        ------\n        RuntimeError\n            If filename is not str, path does not exist or filename is a directory.\n        \"\"\"\n        if not isinstance(filename, str):\n            raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n        if os.path.isdir(filename):\n            raise RuntimeError(\n                \"Invalid filename input. {} is directory.\".format(filename)\n            )\n\n        if not filename.lower().endswith(\".npz\"):\n            filename = filename + \".npz\"\n\n        dirname = os.path.dirname(filename)\n\n        if len(dirname) and not os.path.exists(dirname):\n            raise RuntimeError(\n                \"Path {} does not exist.\".format(os.path.dirname(filename))\n            )\n\n        np.savez(\n            filename,\n            t=self.index.values,\n            d=self.values,\n            start=self.time_support.start.values,\n            end=self.time_support.end.values,\n            type=np.array([self.nap_class], dtype=np.str_),\n        )\n\n        return\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Object is immutable</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def __setattr__(self, name, value):\n    \"\"\"Object is immutable\"\"\"\n    if self._initialized:\n        raise RuntimeError(\n            \"Changing directly attributes is not permitted for {}.\".format(\n                self.nap_class\n            )\n        )\n    else:\n        object.__setattr__(self, name, value)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.times","title":"times","text":"<pre><code>times(units='s')\n</code></pre> <p>The time index of the object, returned as np.double in the desired time units.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>the time indexes</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def times(self, units=\"s\"):\n    \"\"\"\n    The time index of the object, returned as np.double in the desired time units.\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.ndarray\n        the time indexes\n    \"\"\"\n    return self.index.in_units(units)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.as_array","title":"as_array","text":"<pre><code>as_array()\n</code></pre> <p>Return the data as a numpy.ndarray</p> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_array(self):\n    \"\"\"\n    Return the data as a numpy.ndarray\n\n    Returns\n    -------\n    out: numpy.ndarray\n        _\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.data","title":"data","text":"<pre><code>data()\n</code></pre> <p>Return the data as a numpy.ndarray</p> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def data(self):\n    \"\"\"\n    Return the data as a numpy.ndarray\n\n    Returns\n    -------\n    out: numpy.ndarray\n        _\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy()\n</code></pre> <p>Return the data as a numpy.ndarray. Mostly useful for matplotlib plotting when calling <code>plot(tsd)</code></p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def to_numpy(self):\n    \"\"\"\n    Return the data as a numpy.ndarray. Mostly useful for matplotlib plotting when calling `plot(tsd)`\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.start_time","title":"start_time","text":"<pre><code>start_time(units='s')\n</code></pre> <p>The first time index in the time series object</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float64</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def start_time(self, units=\"s\"):\n    \"\"\"\n    The first time index in the time series object\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.float64\n        _\n    \"\"\"\n    if len(self.index):\n        return self.times(units=units)[0]\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.end_time","title":"end_time","text":"<pre><code>end_time(units='s')\n</code></pre> <p>The last time index in the time series object</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float64</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def end_time(self, units=\"s\"):\n    \"\"\"\n    The last time index in the time series object\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.float64\n        _\n    \"\"\"\n    if len(self.index):\n        return self.times(units=units)[-1]\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.value_from","title":"value_from","text":"<pre><code>value_from(data, ep=None)\n</code></pre> <p>Replace the value with the closest value from Tsd/TsdFrame/TsdTensor argument</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Tsd / TsdFrame / TsdTensor</code> <p>The object holding the values to replace.</p> required <code>ep</code> <code>IntervalSet(optional)</code> <p>The IntervalSet object to restrict the operation. If None, the time support of the tsd input object is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd / TsdFrame / TsdTensor</code> <p>Object with the new values</p> <p>Examples:</p> <p>In this example, the ts object will receive the closest values in time from tsd.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100))) # random times\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,1000), d=np.random.rand(1000), time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 500, time_units = 's')\n</code></pre> <p>The variable ts is a time series object containing only nan. The tsd object containing the values, for example the tracking data, and the epoch to restrict the operation.</p> <pre><code>&gt;&gt;&gt; newts = ts.value_from(tsd, ep)\n</code></pre> <p>newts is the same size as ts restrict to ep.</p> <pre><code>&gt;&gt;&gt; print(len(ts.restrict(ep)), len(newts))\n    52 52\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def value_from(self, data, ep=None):\n    \"\"\"\n    Replace the value with the closest value from Tsd/TsdFrame/TsdTensor argument\n\n    Parameters\n    ----------\n    data : Tsd/TsdFrame/TsdTensor\n        The object holding the values to replace.\n    ep : IntervalSet (optional)\n        The IntervalSet object to restrict the operation.\n        If None, the time support of the tsd input object is used.\n\n    Returns\n    -------\n    out : Tsd/TsdFrame/TsdTensor\n        Object with the new values\n\n    Examples\n    --------\n    In this example, the ts object will receive the closest values in time from tsd.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100))) # random times\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,1000), d=np.random.rand(1000), time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 500, time_units = 's')\n\n    The variable ts is a time series object containing only nan.\n    The tsd object containing the values, for example the tracking data, and the epoch to restrict the operation.\n\n    &gt;&gt;&gt; newts = ts.value_from(tsd, ep)\n\n    newts is the same size as ts restrict to ep.\n\n    &gt;&gt;&gt; print(len(ts.restrict(ep)), len(newts))\n        52 52\n    \"\"\"\n    if not isinstance(data, (TsdTensor, TsdFrame, Tsd)):\n        raise RuntimeError(\n            \"The time series to align to should be Tsd/TsdFrame/TsdTensor.\"\n        )\n\n    if ep is None:\n        ep = data.time_support\n    time_array = self.index.values\n    time_target_array = data.index.values\n    data_target_array = data.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if data_target_array.ndim == 1:\n        t, d, ns, ne = jitvaluefrom(\n            time_array, time_target_array, data_target_array, starts, ends\n        )\n    else:\n        t, d, ns, ne = jitvaluefromtensor(\n            time_array, time_target_array, data_target_array, starts, ends\n        )\n\n    time_support = IntervalSet(start=ns, end=ne)\n\n    if isinstance(data, TsdFrame):\n        return TsdFrame(t=t, d=d, time_support=time_support, columns=data.columns)\n    else:\n        return data.__class__(t, d, time_support=time_support)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.count","title":"count","text":"<pre><code>count(*args, **kwargs)\n</code></pre> <p>Count occurences of events within bin_size or within a set of bins defined as an IntervalSet. You can call this function in multiple ways :</p> <ol> <li> <p>tsd.count(bin_size=1, time_units = 'ms') -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.</p> </li> <li> <p>tsd.count(1, ep=my_epochs) -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.</p> </li> <li> <p>tsd.count(ep=my_bins) -&gt; Count occurent of events within each epoch of the intervalSet object my_bins</p> </li> <li> <p>tsd.count() -&gt; Count occurent of events within each epoch of the time support.</p> </li> </ol> <p>bin_size should be seconds unless specified. If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>None or float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> required <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd</code> <p>A Tsd object indexed by the center of the bins.</p> <p>Examples:</p> <p>This example shows how to count events within bins of 0.1 second.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; bincount = ts.count(0.1)\n</code></pre> <p>An epoch can be specified:</p> <pre><code>&gt;&gt;&gt; ep = nap.IntervalSet(start = 100, end = 800, time_units = 's')\n&gt;&gt;&gt; bincount = ts.count(0.1, ep=ep)\n</code></pre> <p>And bincount automatically inherit ep as time support:</p> <pre><code>&gt;&gt;&gt; bincount.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0  100.0  800.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def count(self, *args, **kwargs):\n    \"\"\"\n    Count occurences of events within bin_size or within a set of bins defined as an IntervalSet.\n    You can call this function in multiple ways :\n\n    1. *tsd.count(bin_size=1, time_units = 'ms')*\n    -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.\n\n    2. *tsd.count(1, ep=my_epochs)*\n    -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.\n\n    3. *tsd.count(ep=my_bins)*\n    -&gt; Count occurent of events within each epoch of the intervalSet object my_bins\n\n    4. *tsd.count()*\n    -&gt; Count occurent of events within each epoch of the time support.\n\n    bin_size should be seconds unless specified.\n    If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.\n\n    Parameters\n    ----------\n    bin_size : None or float, optional\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: Tsd\n        A Tsd object indexed by the center of the bins.\n\n    Examples\n    --------\n    This example shows how to count events within bins of 0.1 second.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; bincount = ts.count(0.1)\n\n    An epoch can be specified:\n\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 100, end = 800, time_units = 's')\n    &gt;&gt;&gt; bincount = ts.count(0.1, ep=ep)\n\n    And bincount automatically inherit ep as time support:\n\n    &gt;&gt;&gt; bincount.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0  100.0  800.0\n    \"\"\"\n    bin_size = None\n    if \"bin_size\" in kwargs:\n        bin_size = kwargs[\"bin_size\"]\n        if isinstance(bin_size, int):\n            bin_size = float(bin_size)\n        if not isinstance(bin_size, float):\n            raise ValueError(\"bin_size argument should be float.\")\n    else:\n        for a in args:\n            if isinstance(a, (float, int)):\n                bin_size = float(a)\n\n    time_units = \"s\"\n    if \"time_units\" in kwargs:\n        time_units = kwargs[\"time_units\"]\n        if not isinstance(time_units, str):\n            raise ValueError(\"time_units argument should be 's', 'ms' or 'us'.\")\n    else:\n        for a in args:\n            if isinstance(a, str) and a in [\"s\", \"ms\", \"us\"]:\n                time_units = a\n\n    ep = self.time_support\n    if \"ep\" in kwargs:\n        ep = kwargs[\"ep\"]\n        if not isinstance(ep, IntervalSet):\n            raise ValueError(\"ep argument should be IntervalSet\")\n    else:\n        for a in args:\n            if isinstance(a, IntervalSet):\n                ep = a\n\n    time_array = self.index.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if isinstance(bin_size, (float, int)):\n        bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n        t, d = jitcount(time_array, starts, ends, bin_size)\n    else:\n        _, d = jittsrestrict_with_count(time_array, starts, ends)\n        t = starts + (ends - starts) / 2\n\n    return Tsd(t=t, d=d, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.restrict","title":"restrict","text":"<pre><code>restrict(iset)\n</code></pre> <p>Restricts a time series object to a set of time intervals delimited by an IntervalSet object</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>the IntervalSet object</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>(Ts, Tsd, TsdFrame or TsdTensor)</code> <p>Tsd object restricted to ep</p> <p>Examples:</p> <p>The Ts object is restrict to the intervals defined by ep.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=500, time_units='s')\n&gt;&gt;&gt; newts = ts.restrict(ep)\n</code></pre> <p>The time support of newts automatically inherit the epochs defined by ep.</p> <pre><code>&gt;&gt;&gt; newts.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0    0.0  500.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def restrict(self, iset):\n    \"\"\"\n    Restricts a time series object to a set of time intervals delimited by an IntervalSet object\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        the IntervalSet object\n\n    Returns\n    -------\n    out: Ts, Tsd, TsdFrame or TsdTensor\n        Tsd object restricted to ep\n\n    Examples\n    --------\n    The Ts object is restrict to the intervals defined by ep.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=500, time_units='s')\n    &gt;&gt;&gt; newts = ts.restrict(ep)\n\n    The time support of newts automatically inherit the epochs defined by ep.\n\n    &gt;&gt;&gt; newts.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0    0.0  500.0\n\n    \"\"\"\n    assert isinstance(iset, IntervalSet), \"Argument should be IntervalSet\"\n\n    time_array = self.index.values\n    starts = iset.start.values\n    ends = iset.end.values\n\n    if isinstance(self.values, np.ndarray):\n        data_array = self.values\n        t, d = jitrestrict(time_array, data_array, starts, ends)\n\n        if hasattr(self, \"columns\"):\n            return TsdFrame(t=t, d=d, time_support=iset, columns=self.columns)\n        else:\n            return self.__class__(t=t, d=d, time_support=iset)\n    else:\n        t = jittsrestrict(time_array, starts, ends)\n        return Ts(t, time_support=iset)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.bin_average","title":"bin_average","text":"<pre><code>bin_average(bin_size, ep=None, time_units='s')\n</code></pre> <p>Bin the data by averaging points within bin_size bin_size should be seconds unless specified. If no epochs is passed, the data will be binned based on the time support.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> <code>None</code> <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>(Tsd, TsdFrame, TsdTensor)</code> <p>A Tsd object indexed by the center of the bins and holding the averaged data points.</p> <p>Examples:</p> <p>This example shows how to bin data within bins of 0.1 second.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n&gt;&gt;&gt; bintsd = tsd.bin_average(0.1)\n</code></pre> <p>An epoch can be specified:</p> <pre><code>&gt;&gt;&gt; ep = nap.IntervalSet(start = 10, end = 80, time_units = 's')\n&gt;&gt;&gt; bintsd = tsd.bin_average(0.1, ep=ep)\n</code></pre> <p>And bintsd automatically inherit ep as time support:</p> <pre><code>&gt;&gt;&gt; bintsd.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0  10.0     80.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def bin_average(self, bin_size, ep=None, time_units=\"s\"):\n    \"\"\"\n    Bin the data by averaging points within bin_size\n    bin_size should be seconds unless specified.\n    If no epochs is passed, the data will be binned based on the time support.\n\n    Parameters\n    ----------\n    bin_size : float\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: Tsd, TsdFrame, TsdTensor\n        A Tsd object indexed by the center of the bins and holding the averaged data points.\n\n    Examples\n    --------\n    This example shows how to bin data within bins of 0.1 second.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n    &gt;&gt;&gt; bintsd = tsd.bin_average(0.1)\n\n    An epoch can be specified:\n\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 10, end = 80, time_units = 's')\n    &gt;&gt;&gt; bintsd = tsd.bin_average(0.1, ep=ep)\n\n    And bintsd automatically inherit ep as time support:\n\n    &gt;&gt;&gt; bintsd.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0  10.0     80.0\n    \"\"\"\n    if not isinstance(ep, IntervalSet):\n        ep = self.time_support\n\n    bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n\n    time_array = self.index.values\n    data_array = self.values\n    starts = ep.start.values\n    ends = ep.end.values\n    if data_array.ndim &gt; 1:\n        t, d = jitbin_array(time_array, data_array, starts, ends, bin_size)\n    else:\n        t, d = jitbin(time_array, data_array, starts, ends, bin_size)\n\n    if d.ndim == 1:\n        return Tsd(t=t, d=d, time_support=ep)\n    elif d.ndim == 2:\n        kwargs = {}\n        if hasattr(self, \"columns\"):\n            kwargs[\"columns\"] = self.columns\n        return TsdFrame(t=t, d=d, time_support=ep, **kwargs)\n    else:\n        return TsdTensor(t=t, d=d, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Copy the data, index and time support</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def copy(self):\n    \"\"\"Copy the data, index and time support\"\"\"\n    return self.__class__(\n        t=self.index.copy(), d=self.values.copy(), time_support=self.time_support\n    )\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.find_support","title":"find_support","text":"<pre><code>find_support(min_gap, time_units='s')\n</code></pre> <p>find the smallest (to a min_gap resolution) IntervalSet containing all the times in the Tsd</p> <p>Parameters:</p> Name Type Description Default <code>min_gap</code> <code>float or int</code> <p>minimal interval between timestamps</p> required <code>time_units</code> <code>str</code> <p>Time units of min gap</p> <code>'s'</code> <p>Returns:</p> Type Description <code>IntervalSet</code> <p>Description</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def find_support(self, min_gap, time_units=\"s\"):\n    \"\"\"\n    find the smallest (to a min_gap resolution) IntervalSet containing all the times in the Tsd\n\n    Parameters\n    ----------\n    min_gap : float or int\n        minimal interval between timestamps\n    time_units : str, optional\n        Time units of min gap\n\n    Returns\n    -------\n    IntervalSet\n        Description\n    \"\"\"\n    assert isinstance(min_gap, Number), \"min_gap should be a float or int\"\n    min_gap = TsIndex.format_timestamps(np.array([min_gap]), time_units)[0]\n    time_array = self.index.values\n\n    starts = [time_array[0]]\n    ends = []\n    for i in range(len(time_array) - 1):\n        if (time_array[i + 1] - time_array[i]) &gt; min_gap:\n            ends.append(time_array[i] + 1e-6)\n            starts.append(time_array[i + 1])\n\n    ends.append(time_array[-1] + 1e-6)\n\n    return IntervalSet(start=starts, end=ends)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.get","title":"get","text":"<pre><code>get(start, end=None, time_units='s')\n</code></pre> <p>Slice the time series from start to end such that all the timestamps satisfy start&lt;=t&lt;=end. If end is None, only the timepoint closest to start is returned.</p> <p>By default, the time support doesn't change. If you want to change the time support, use the restrict function.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float or int</code> <p>The start</p> required <code>end</code> <code>float or int</code> <p>The end</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def get(self, start, end=None, time_units=\"s\"):\n    \"\"\"Slice the time series from start to end such that all the timestamps satisfy start&lt;=t&lt;=end.\n    If end is None, only the timepoint closest to start is returned.\n\n    By default, the time support doesn't change. If you want to change the time support, use the restrict function.\n\n    Parameters\n    ----------\n    start : float or int\n        The start\n    end : float or int\n        The end\n    \"\"\"\n    assert isinstance(start, Number), \"start should be a float or int\"\n    time_array = self.index.values\n\n    if end is None:\n        start = TsIndex.format_timestamps(np.array([start]), time_units)[0]\n        idx = int(np.searchsorted(time_array, start))\n        if idx == 0:\n            return self[idx]\n        elif idx &gt;= self.shape[0]:\n            return self[-1]\n        else:\n            if start - time_array[idx - 1] &lt; time_array[idx] - start:\n                return self[idx - 1]\n            else:\n                return self[idx]\n    else:\n        assert isinstance(end, Number), \"end should be a float or int\"\n        assert start &lt; end, \"Start should not precede end\"\n        start, end = TsIndex.format_timestamps(np.array([start, end]), time_units)\n        idx_start = np.searchsorted(time_array, start)\n        idx_end = np.searchsorted(time_array, end, side=\"right\")\n        return self[idx_start:idx_end]\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.dropna","title":"dropna","text":"<pre><code>dropna(update_time_support=True)\n</code></pre> <p>Drop every rows containing NaNs. By default, the time support is updated to start and end around the time points that are non NaNs. To change this behavior, you can set update_time_support=False.</p> <p>Parameters:</p> Name Type Description Default <code>update_time_support</code> <code>bool</code> <code>True</code> <p>Returns:</p> Type Description <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The time series without the NaNs</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def dropna(self, update_time_support=True):\n    \"\"\"Drop every rows containing NaNs. By default, the time support is updated to start and end around the time points that are non NaNs.\n    To change this behavior, you can set update_time_support=False.\n\n    Parameters\n    ----------\n    update_time_support : bool, optional\n\n    Returns\n    -------\n    Tsd, TsdFrame or TsdTensor\n        The time series without the NaNs\n    \"\"\"\n    index_nan = np.any(np.isnan(self.values), axis=tuple(range(1, self.ndim)))\n    if np.all(index_nan):  # In case it's only NaNs\n        return self.__class__(\n            t=np.array([]), d=np.empty(tuple([0] + [d for d in self.shape[1:]]))\n        )\n\n    elif np.any(index_nan):\n        if update_time_support:\n            time_array = self.index.values\n            starts, ends = jitremove_nan(time_array, index_nan)\n\n            to_fix = starts == ends\n            if np.any(to_fix):\n                ends[\n                    to_fix\n                ] += 1e-6  # adding 1 millisecond in case of a single point\n\n            ep = IntervalSet(starts, ends)\n\n            return self.__class__(\n                t=time_array[~index_nan], d=self.values[~index_nan], time_support=ep\n            )\n\n        else:\n            return self[~index_nan]\n\n    else:\n        return self\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.convolve","title":"convolve","text":"<pre><code>convolve(array, ep=None, trim='both')\n</code></pre> <p>Return the discrete linear convolution of the time series with a one dimensional sequence.</p> <p>A parameter ep can control the epochs for which the convolution will apply. Otherwise the convolution is made over the time support.</p> <p>This function assume a constant sampling rate of the time series.</p> <p>The only mode supported is full. The returned object is trimmed to match the size of the original object. The parameter trim controls which side the trimming operates. Default is 'both'.</p> <p>See the numpy documentation here : https://numpy.org/doc/stable/reference/generated/numpy.convolve.html</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>One dimensional input array</p> required <code>ep</code> <code>None</code> <p>The epochs to apply the convolution</p> <code>None</code> <code>trim</code> <code>str</code> <p>The side on which to trim the output of the convolution ('left', 'right', 'both' [default])</p> <code>'both'</code> <p>Returns:</p> Type Description <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The convolved time series</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def convolve(self, array, ep=None, trim=\"both\"):\n    \"\"\"Return the discrete linear convolution of the time series with a one dimensional sequence.\n\n    A parameter ep can control the epochs for which the convolution will apply. Otherwise the convolution is made over the time support.\n\n    This function assume a constant sampling rate of the time series.\n\n    The only mode supported is full. The returned object is trimmed to match the size of the original object. The parameter trim controls which side the trimming operates. Default is 'both'.\n\n    See the numpy documentation here : https://numpy.org/doc/stable/reference/generated/numpy.convolve.html\n\n    Parameters\n    ----------\n    array : np.ndarray\n        One dimensional input array\n    ep : None, optional\n        The epochs to apply the convolution\n    trim : str, optional\n        The side on which to trim the output of the convolution ('left', 'right', 'both' [default])\n\n    Returns\n    -------\n    Tsd, TsdFrame or TsdTensor\n        The convolved time series\n    \"\"\"\n    assert isinstance(array, np.ndarray), \"Input should be a 1-d numpy array.\"\n    assert array.ndim == 1, \"Input should be a one dimensional array.\"\n    assert trim in [\n        \"both\",\n        \"left\",\n        \"right\",\n    ], \"Unknow argument. trim should be 'both', 'left' or 'right'.\"\n\n    if ep is None:\n        ep = self.time_support\n\n    time_array = self.index.values\n    data_array = self.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if data_array.ndim == 1:\n        new_data_array = np.zeros(data_array.shape)\n        k = array.shape[0]\n        for s, e in zip(starts, ends):\n            idx_s = np.searchsorted(time_array, s)\n            idx_e = np.searchsorted(time_array, e, side=\"right\")\n\n            t = idx_e - idx_s\n            if trim == \"left\":\n                cut = (k - 1, t + k - 1)\n            elif trim == \"right\":\n                cut = (0, t)\n            else:\n                cut = ((1 - k % 2) + (k - 1) // 2, t + k - 1 - ((k - 1) // 2))\n            # scipy is actually faster for Tsd\n            new_data_array[idx_s:idx_e] = signal.convolve(\n                data_array[idx_s:idx_e], array\n            )[cut[0] : cut[1]]\n\n        return self.__class__(t=time_array, d=new_data_array, time_support=ep)\n    else:\n        new_data_array = np.zeros(data_array.shape)\n        for s, e in zip(starts, ends):\n            idx_s = np.searchsorted(time_array, s)\n            idx_e = np.searchsorted(time_array, e, side=\"right\")\n            new_data_array[idx_s:idx_e] = pjitconvolve(\n                data_array[idx_s:idx_e], array, trim=trim\n            )\n\n        return self.__class__(t=time_array, d=new_data_array, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.smooth","title":"smooth","text":"<pre><code>smooth(std, size)\n</code></pre> <p>Smooth a time series with a gaussian kernel. std is the standard deviation and size is the number of point of the window.</p> <p>See the scipy documentation : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.gaussian.html</p> <p>Parameters:</p> Name Type Description Default <code>std</code> <code>int</code> <p>Standard deviation</p> required <code>size</code> <code>int</code> <p>Description</p> required <p>Returns:</p> Type Description <code>(Tsd, TsdFrame, TsdTensor)</code> <p>Time series convolved with a gaussian kernel</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def smooth(self, std, size):\n    \"\"\"Smooth a time series with a gaussian kernel. std is the standard deviation and size is the number of point of the window.\n\n    See the scipy documentation : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.gaussian.html\n\n    Parameters\n    ----------\n    std : int\n        Standard deviation\n    size : int\n        Description\n\n    Returns\n    -------\n    Tsd, TsdFrame, TsdTensor\n        Time series convolved with a gaussian kernel\n    \"\"\"\n    assert isinstance(std, int), \"std should be type int\"\n    assert isinstance(size, int), \"size should be type int\"\n    window = signal.windows.gaussian(size, std=std)\n    window = window / window.sum()\n    return self.convolve(window)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.interpolate","title":"interpolate","text":"<pre><code>interpolate(ts, ep=None, left=None, right=None)\n</code></pre> <p>Wrapper of the numpy linear interpolation method. See https://numpy.org/doc/stable/reference/generated/numpy.interp.html for an explanation of the parameters. The argument ts should be Ts, Tsd, TsdFrame, TsdTensor to ensure interpolating from sorted timestamps in the right unit,</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>(Ts, Tsd or TsdFrame)</code> <p>The object holding the timestamps</p> required <code>ep</code> <code>IntervalSet</code> <p>The epochs to use to interpolate. If None, the time support of Tsd is used.</p> <code>None</code> <code>left</code> <code>None</code> <p>Value to return for ts &lt; tsd[0], default is tsd[0].</p> <code>None</code> <code>right</code> <code>None</code> <p>Value to return for ts &gt; tsd[-1], default is tsd[-1].</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def interpolate(self, ts, ep=None, left=None, right=None):\n    \"\"\"Wrapper of the numpy linear interpolation method. See https://numpy.org/doc/stable/reference/generated/numpy.interp.html for an explanation of the parameters.\n    The argument ts should be Ts, Tsd, TsdFrame, TsdTensor to ensure interpolating from sorted timestamps in the right unit,\n\n    Parameters\n    ----------\n    ts : Ts, Tsd or TsdFrame\n        The object holding the timestamps\n    ep : IntervalSet, optional\n        The epochs to use to interpolate. If None, the time support of Tsd is used.\n    left : None, optional\n        Value to return for ts &lt; tsd[0], default is tsd[0].\n    right : None, optional\n        Value to return for ts &gt; tsd[-1], default is tsd[-1].\n    \"\"\"\n    if not isinstance(ts, (Ts, Tsd, TsdFrame, TsdTensor)):\n        raise RuntimeError(\n            \"First argument should be an instance of Ts, Tsd or TsdFrame\"\n        )\n\n    if not isinstance(ep, IntervalSet):\n        ep = self.time_support\n\n    new_t = ts.restrict(ep).index\n\n    new_shape = (\n        len(new_t) if self.values.ndim == 1 else (len(new_t),) + self.shape[1:]\n    )\n    new_d = np.full(new_shape, np.nan)\n\n    start = 0\n    for i in range(len(ep)):\n        t = ts.get(ep.loc[i, \"start\"], ep.loc[i, \"end\"])\n        tmp = self.get(ep.loc[i, \"start\"], ep.loc[i, \"end\"])\n\n        if len(t) and len(tmp):\n            if self.values.ndim == 1:\n                new_d[start : start + len(t)] = np.interp(\n                    t.index.values,\n                    tmp.index.values,\n                    tmp.values,\n                    left=left,\n                    right=right,\n                )\n            else:\n                interpolated_values = np.apply_along_axis(\n                    lambda row: np.interp(\n                        t.index.values,\n                        tmp.index.values,\n                        row,\n                        left=left,\n                        right=right,\n                    ),\n                    0,\n                    tmp.values,\n                )\n                new_d[start : start + len(t), ...] = interpolated_values\n\n        start += len(t)\n    kwargs_dict = dict(time_support=ep)\n    if hasattr(self, \"columns\"):\n        kwargs_dict[\"columns\"] = self.columns\n    return self.__class__(t=new_t, d=new_d, **kwargs_dict)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.__init__","title":"__init__","text":"<pre><code>__init__(t, d=None, time_units='s', time_support=None)\n</code></pre> <p>Tsd Initializer.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray or Series</code> <p>An object transformable in a time series, or a pandas.Series equivalent (if d is None)</p> required <code>d</code> <code>ndarray</code> <p>The data of the time series</p> <code>None</code> <code>time_units</code> <code>str</code> <p>The time units in which times are specified ('us', 'ms', 's' [default])</p> <code>'s'</code> <code>time_support</code> <code>IntervalSet</code> <p>The time support of the tsd object</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def __init__(self, t, d=None, time_units=\"s\", time_support=None):\n    \"\"\"\n    Tsd Initializer.\n\n    Parameters\n    ----------\n    t : numpy.ndarray or pandas.Series\n        An object transformable in a time series, or a pandas.Series equivalent (if d is None)\n    d : numpy.ndarray, optional\n        The data of the time series\n    time_units : str, optional\n        The time units in which times are specified ('us', 'ms', 's' [default])\n    time_support : IntervalSet, optional\n        The time support of the tsd object\n    \"\"\"\n    if isinstance(t, np.ndarray) and d is None:\n        raise RuntimeError(\"Missing argument d when initializing Tsd\")\n\n    if isinstance(t, pd.Series):\n        d = t.values\n        t = t.index.values\n\n    if isinstance(t, (list, tuple)):\n        t = np.array(t)\n    if isinstance(d, (list, tuple)):\n        d = np.array(d)\n\n    assert d.ndim == 1, \"Data should be 1 dimension\"\n\n    if isinstance(t, TsIndex):\n        self.index = t\n    else:\n        # Checking timestamps\n        self.index = TsIndex(t, time_units)\n\n    if len(self.index) != len(d):\n        raise ValueError(\n            \"Length of values \"\n            f\"({len(d)}) \"\n            \"does not match length of index \"\n            f\"({len(self.index)})\"\n        )\n\n    if len(self.index):\n        if isinstance(time_support, IntervalSet):\n            starts = time_support.start.values\n            ends = time_support.end.values\n            t, d = jitrestrict(self.index.values, d, starts, ends)\n            self.index = TsIndex(t)\n            self.values = d\n        else:\n            time_support = IntervalSet(start=self.index[0], end=self.index[-1])\n            self.values = d\n\n        self.time_support = time_support\n        self.rate = self.index.shape[0] / np.sum(\n            time_support.values[:, 1] - time_support.values[:, 0]\n        )\n    else:\n        self.rate = np.NaN\n        self.values = np.empty(0)\n        self.time_support = IntervalSet(start=[], end=[])\n\n    self.nap_class = self.__class__.__name__\n    self.dtype = self.values.dtype\n    self._initialized = True\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.as_series","title":"as_series","text":"<pre><code>as_series()\n</code></pre> <p>Convert the Ts/Tsd object to a pandas.Series object.</p> <p>Returns:</p> Name Type Description <code>out</code> <code>Series</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_series(self):\n    \"\"\"\n    Convert the Ts/Tsd object to a pandas.Series object.\n\n    Returns\n    -------\n    out: pandas.Series\n        _\n    \"\"\"\n    return pd.Series(\n        index=self.index.values, data=self.values, copy=True, dtype=\"float64\"\n    )\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.as_units","title":"as_units","text":"<pre><code>as_units(units='s')\n</code></pre> <p>Returns a pandas Series with time expressed in the desired unit.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Type Description <code>Series</code> <p>the series object with adjusted times</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_units(self, units=\"s\"):\n    \"\"\"\n    Returns a pandas Series with time expressed in the desired unit.\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    pandas.Series\n        the series object with adjusted times\n    \"\"\"\n    ss = self.as_series()\n    t = self.index.in_units(units)\n    if units == \"us\":\n        t = t.astype(np.int64)\n    ss.index = t\n    ss.index.name = \"Time (\" + str(units) + \")\"\n    return ss\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.threshold","title":"threshold","text":"<pre><code>threshold(thr, method='above')\n</code></pre> <p>Apply a threshold function to the tsd to return a new tsd with the time support being the epochs above/below/&gt;=/&lt;= the threshold</p> <p>Parameters:</p> Name Type Description Default <code>thr</code> <code>float</code> <p>The threshold value</p> required <code>method</code> <code>str</code> <p>The threshold method (above/below/aboveequal/belowequal)</p> <code>'above'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd</code> <p>All the time points below/ above/greater than equal to/less than equal to the threshold</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raise an error if method is not 'below' or 'above'</p> <code>RuntimeError</code> <p>Raise an error if thr is too high/low and no epochs is found.</p> <p>Examples:</p> <p>This example finds all epoch above 0.5 within the tsd object.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n&gt;&gt;&gt; newtsd = tsd.threshold(0.5)\n</code></pre> <p>The epochs with the times above/below the threshold can be accessed through the time support:</p> <pre><code>&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.arange(100), time_units='s')\n&gt;&gt;&gt; tsd.threshold(50).time_support\n&gt;&gt;&gt;    start   end\n&gt;&gt;&gt; 0   50.5  99.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def threshold(self, thr, method=\"above\"):\n    \"\"\"\n    Apply a threshold function to the tsd to return a new tsd\n    with the time support being the epochs above/below/&gt;=/&lt;= the threshold\n\n    Parameters\n    ----------\n    thr : float\n        The threshold value\n    method : str, optional\n        The threshold method (above/below/aboveequal/belowequal)\n\n    Returns\n    -------\n    out: Tsd\n        All the time points below/ above/greater than equal to/less than equal to the threshold\n\n    Raises\n    ------\n    ValueError\n        Raise an error if method is not 'below' or 'above'\n    RuntimeError\n        Raise an error if thr is too high/low and no epochs is found.\n\n    Examples\n    --------\n    This example finds all epoch above 0.5 within the tsd object.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n    &gt;&gt;&gt; newtsd = tsd.threshold(0.5)\n\n    The epochs with the times above/below the threshold can be accessed through the time support:\n\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.arange(100), time_units='s')\n    &gt;&gt;&gt; tsd.threshold(50).time_support\n    &gt;&gt;&gt;    start   end\n    &gt;&gt;&gt; 0   50.5  99.0\n\n    \"\"\"\n    time_array = self.index.values\n    data_array = self.values\n    starts = self.time_support.start.values\n    ends = self.time_support.end.values\n    if method not in [\"above\", \"below\", \"aboveequal\", \"belowequal\"]:\n        raise ValueError(\n            \"Method {} for thresholding is not accepted.\".format(method)\n        )\n\n    t, d, ns, ne = jitthreshold(time_array, data_array, starts, ends, thr, method)\n    time_support = IntervalSet(start=ns, end=ne)\n    return Tsd(t=t, d=d, time_support=time_support)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.to_tsgroup","title":"to_tsgroup","text":"<pre><code>to_tsgroup()\n</code></pre> <p>Convert Tsd to a TsGroup by grouping timestamps with the same values. By default, the values are converted to integers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsd = nap.Tsd(t = np.array([0, 1, 2, 3]), d = np.array([0, 2, 0, 1]))\nTime (s)\n0.0    0\n1.0    2\n2.0    0\n3.0    1\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; tsd.to_tsgroup()\nIndex    rate\n-------  ------\n    0    0.67\n    1    0.33\n    2    0.33\n</code></pre> <p>The reverse operation can be done with the TsGroup.to_tsd function :</p> <pre><code>&gt;&gt;&gt; tsgroup.to_tsd()\nTime (s)\n0.0    0.0\n1.0    2.0\n2.0    0.0\n3.0    1.0\ndtype: float64\n</code></pre> <p>Returns:</p> Type Description <code>TsGroup</code> <p>Grouped timestamps</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def to_tsgroup(self):\n    \"\"\"\n    Convert Tsd to a TsGroup by grouping timestamps with the same values.\n    By default, the values are converted to integers.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsd = nap.Tsd(t = np.array([0, 1, 2, 3]), d = np.array([0, 2, 0, 1]))\n    Time (s)\n    0.0    0\n    1.0    2\n    2.0    0\n    3.0    1\n    dtype: int64\n\n    &gt;&gt;&gt; tsd.to_tsgroup()\n    Index    rate\n    -------  ------\n        0    0.67\n        1    0.33\n        2    0.33\n\n    The reverse operation can be done with the TsGroup.to_tsd function :\n\n    &gt;&gt;&gt; tsgroup.to_tsd()\n    Time (s)\n    0.0    0.0\n    1.0    2.0\n    2.0    0.0\n    3.0    1.0\n    dtype: float64\n\n    Returns\n    -------\n    TsGroup\n        Grouped timestamps\n\n    \"\"\"\n    ts_group = importlib.import_module(\".ts_group\", \"pynapple.core\")\n    t = self.index.values\n    d = self.values.astype(\"int\")\n    idx = np.unique(d)\n\n    group = {}\n    for k in idx:\n        group[k] = Ts(t=t[d == k], time_support=self.time_support)\n\n    return ts_group.TsGroup(group, time_support=self.time_support)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Tsd.save","title":"save","text":"<pre><code>save(filename)\n</code></pre> <p>Save Tsd object in npz format. The file will contain the timestamps, the data and the time support.</p> <p>The main purpose of this function is to save small/medium sized time series objects. For example, you extracted one channel from your recording and filtered it. You can save the filtered channel as a npz to avoid reprocessing it.</p> <p>You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end' and 'type'. See the example below.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.array([0., 1.]), d = np.array([2, 3]))\n&gt;&gt;&gt; tsd.save(\"my_path/my_tsd.npz\")\n</code></pre> <p>Here I can retrieve my data with numpy directly:</p> <pre><code>&gt;&gt;&gt; file = np.load(\"my_path/my_tsd.npz\")\n&gt;&gt;&gt; print(list(file.keys()))\n['t', 'd', 'start', 'end', 'type']\n&gt;&gt;&gt; print(file['t'])\n[0. 1.]\n</code></pre> <p>It is then easy to recreate the Tsd object.</p> <pre><code>&gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n&gt;&gt;&gt; nap.Tsd(t=file['t'], d=file['d'], time_support=time_support)\nTime (s)\n0.0    2\n1.0    3\ndtype: int64\n</code></pre> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If filename is not str, path does not exist or filename is a directory.</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def save(self, filename):\n    \"\"\"\n    Save Tsd object in npz format. The file will contain the timestamps, the\n    data and the time support.\n\n    The main purpose of this function is to save small/medium sized time series\n    objects. For example, you extracted one channel from your recording and\n    filtered it. You can save the filtered channel as a npz to avoid\n    reprocessing it.\n\n    You can load the object with numpy.load. Keys are 't', 'd', 'start', 'end' and 'type'.\n    See the example below.\n\n    Parameters\n    ----------\n    filename : str\n        The filename\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.array([0., 1.]), d = np.array([2, 3]))\n    &gt;&gt;&gt; tsd.save(\"my_path/my_tsd.npz\")\n\n    Here I can retrieve my data with numpy directly:\n\n    &gt;&gt;&gt; file = np.load(\"my_path/my_tsd.npz\")\n    &gt;&gt;&gt; print(list(file.keys()))\n    ['t', 'd', 'start', 'end', 'type']\n    &gt;&gt;&gt; print(file['t'])\n    [0. 1.]\n\n    It is then easy to recreate the Tsd object.\n    &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n    &gt;&gt;&gt; nap.Tsd(t=file['t'], d=file['d'], time_support=time_support)\n    Time (s)\n    0.0    2\n    1.0    3\n    dtype: int64\n\n    Raises\n    ------\n    RuntimeError\n        If filename is not str, path does not exist or filename is a directory.\n    \"\"\"\n    if not isinstance(filename, str):\n        raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n    if os.path.isdir(filename):\n        raise RuntimeError(\n            \"Invalid filename input. {} is directory.\".format(filename)\n        )\n\n    if not filename.lower().endswith(\".npz\"):\n        filename = filename + \".npz\"\n\n    dirname = os.path.dirname(filename)\n\n    if len(dirname) and not os.path.exists(dirname):\n        raise RuntimeError(\n            \"Path {} does not exist.\".format(os.path.dirname(filename))\n        )\n\n    np.savez(\n        filename,\n        t=self.index.values,\n        d=self.values,\n        start=self.time_support.start.values,\n        end=self.time_support.end.values,\n        type=np.array([self.nap_class], dtype=np.str_),\n    )\n\n    return\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts","title":"Ts","text":"<p>             Bases: <code>_AbstractTsd</code></p> <p>Timestamps only object for a time series with only time index,</p> <p>Attributes:</p> Name Type Description <code>rate</code> <code>float</code> <p>Frequency of the time series (Hz) computed over the time support</p> <code>time_support</code> <code>IntervalSet</code> <p>The time support of the time series</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>class Ts(_AbstractTsd):\n    \"\"\"\n    Timestamps only object for a time series with only time index,\n\n    Attributes\n    ----------\n    rate : float\n        Frequency of the time series (Hz) computed over the time support\n    time_support : IntervalSet\n        The time support of the time series\n    \"\"\"\n\n    def __init__(self, t, time_units=\"s\", time_support=None):\n        \"\"\"\n        Ts Initializer\n\n        Parameters\n        ----------\n        t : numpy.ndarray or pandas.Series\n            An object transformable in a time series, or a pandas.Series equivalent (if d is None)\n        time_units : str, optional\n            The time units in which times are specified ('us', 'ms', 's' [default])\n        time_support : IntervalSet, optional\n            The time support of the Ts object\n        \"\"\"\n        if isinstance(t, Number):\n            t = np.array([t])\n\n        if isinstance(t, TsIndex):\n            self.index = t\n        else:\n            # Checking timestamps\n            self.index = TsIndex(t, time_units)\n\n        if len(self.index):\n            if isinstance(time_support, IntervalSet):\n                starts = time_support.start.values\n                ends = time_support.end.values\n                t = jittsrestrict(self.index.values, starts, ends)\n                self.index = TsIndex(t)\n            else:\n                time_support = IntervalSet(start=t[0], end=t[-1])\n\n            self.time_support = time_support\n            self.rate = self.index.shape[0] / np.sum(\n                time_support.values[:, 1] - time_support.values[:, 0]\n            )\n        else:\n            self.rate = np.NaN\n            self.time_support = IntervalSet(start=[], end=[])\n\n        self.values = None\n        self.nap_class = self.__class__.__name__\n        self._initialized = True\n\n    def __repr__(self):\n        upper = \"Time (s)\"\n        if len(self) &lt; 100:\n            _str_ = \"\\n\".join([i.__repr__() for i in self.index])\n        else:\n            _str_ = \"\\n\".join(\n                [i.__repr__() for i in self.index[0:5]]\n                + [\"...\"]\n                + [i.__repr__() for i in self.index[-5:]]\n            )\n\n        bottom = \"shape: {}\".format(len(self.index))\n        return \"\\n\".join((upper, _str_, bottom))\n\n    def __getitem__(self, key):\n        if isinstance(key, tuple):\n            index = self.index.__getitem__(key[0])\n        else:\n            index = self.index.__getitem__(key)\n\n        if isinstance(index, Number):\n            index = np.array([index])\n\n        return Ts(t=index, time_support=self.time_support)\n\n    def __setitem__(self, key, value):\n        pass\n\n    def as_series(self):\n        \"\"\"\n        Convert the Ts/Tsd object to a pandas.Series object.\n\n        Returns\n        -------\n        out: pandas.Series\n            _\n        \"\"\"\n        return pd.Series(index=self.index.values, dtype=\"object\")\n\n    def as_units(self, units=\"s\"):\n        \"\"\"\n        Returns a pandas Series with time expressed in the desired unit.\n\n        Parameters\n        ----------\n        units : str, optional\n            ('us', 'ms', 's' [default])\n\n        Returns\n        -------\n        pandas.Series\n            the series object with adjusted times\n        \"\"\"\n        t = self.index.in_units(units)\n        if units == \"us\":\n            t = t.astype(np.int64)\n        ss = pd.Series(index=t, dtype=\"object\")\n        ss.index.name = \"Time (\" + str(units) + \")\"\n        return ss\n\n    def fillna(self, value):\n        \"\"\"\n        Similar to pandas fillna function.\n\n        Parameters\n        ----------\n        value : Number\n            Value for filling\n\n        Returns\n        -------\n        Tsd\n\n\n        \"\"\"\n        assert isinstance(value, Number), \"Only a scalar can be passed to fillna\"\n        d = np.empty(len(self))\n        d.fill(value)\n        return Tsd(t=self.index, d=d, time_support=self.time_support)\n\n    def save(self, filename):\n        \"\"\"\n        Save Ts object in npz format. The file will contain the timestamps and\n        the time support.\n\n        The main purpose of this function is to save small/medium sized timestamps\n        object.\n\n        You can load the object with numpy.load. Keys are 't', 'start' and 'end' and 'type'.\n        See the example below.\n\n        Parameters\n        ----------\n        filename : str\n            The filename\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; ts = nap.Ts(t=np.array([0., 1., 1.5]))\n        &gt;&gt;&gt; ts.save(\"my_path/my_ts.npz\")\n\n        Here I can retrieve my data with numpy directly:\n\n        &gt;&gt;&gt; file = np.load(\"my_path/my_ts.npz\")\n        &gt;&gt;&gt; print(list(file.keys()))\n        ['t', 'start', 'end', 'type']\n        &gt;&gt;&gt; print(file['t'])\n        [0. 1. 1.5]\n\n        It is then easy to recreate the Tsd object.\n        &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n        &gt;&gt;&gt; nap.Ts(t=file['t'], time_support=time_support)\n        Time (s)\n        0.0\n        1.0\n        1.5\n\n\n        Raises\n        ------\n        RuntimeError\n            If filename is not str, path does not exist or filename is a directory.\n        \"\"\"\n        if not isinstance(filename, str):\n            raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n        if os.path.isdir(filename):\n            raise RuntimeError(\n                \"Invalid filename input. {} is directory.\".format(filename)\n            )\n\n        if not filename.lower().endswith(\".npz\"):\n            filename = filename + \".npz\"\n\n        dirname = os.path.dirname(filename)\n\n        if len(dirname) and not os.path.exists(dirname):\n            raise RuntimeError(\n                \"Path {} does not exist.\".format(os.path.dirname(filename))\n            )\n\n        np.savez(\n            filename,\n            t=self.index.values,\n            start=self.time_support.start.values,\n            end=self.time_support.end.values,\n            type=np.array([\"Ts\"], dtype=np.str_),\n        )\n\n        return\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Object is immutable</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def __setattr__(self, name, value):\n    \"\"\"Object is immutable\"\"\"\n    if self._initialized:\n        raise RuntimeError(\n            \"Changing directly attributes is not permitted for {}.\".format(\n                self.nap_class\n            )\n        )\n    else:\n        object.__setattr__(self, name, value)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.times","title":"times","text":"<pre><code>times(units='s')\n</code></pre> <p>The time index of the object, returned as np.double in the desired time units.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>the time indexes</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def times(self, units=\"s\"):\n    \"\"\"\n    The time index of the object, returned as np.double in the desired time units.\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.ndarray\n        the time indexes\n    \"\"\"\n    return self.index.in_units(units)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.as_array","title":"as_array","text":"<pre><code>as_array()\n</code></pre> <p>Return the data as a numpy.ndarray</p> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_array(self):\n    \"\"\"\n    Return the data as a numpy.ndarray\n\n    Returns\n    -------\n    out: numpy.ndarray\n        _\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.data","title":"data","text":"<pre><code>data()\n</code></pre> <p>Return the data as a numpy.ndarray</p> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def data(self):\n    \"\"\"\n    Return the data as a numpy.ndarray\n\n    Returns\n    -------\n    out: numpy.ndarray\n        _\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy()\n</code></pre> <p>Return the data as a numpy.ndarray. Mostly useful for matplotlib plotting when calling <code>plot(tsd)</code></p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def to_numpy(self):\n    \"\"\"\n    Return the data as a numpy.ndarray. Mostly useful for matplotlib plotting when calling `plot(tsd)`\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.start_time","title":"start_time","text":"<pre><code>start_time(units='s')\n</code></pre> <p>The first time index in the time series object</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float64</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def start_time(self, units=\"s\"):\n    \"\"\"\n    The first time index in the time series object\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.float64\n        _\n    \"\"\"\n    if len(self.index):\n        return self.times(units=units)[0]\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.end_time","title":"end_time","text":"<pre><code>end_time(units='s')\n</code></pre> <p>The last time index in the time series object</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float64</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def end_time(self, units=\"s\"):\n    \"\"\"\n    The last time index in the time series object\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: numpy.float64\n        _\n    \"\"\"\n    if len(self.index):\n        return self.times(units=units)[-1]\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.value_from","title":"value_from","text":"<pre><code>value_from(data, ep=None)\n</code></pre> <p>Replace the value with the closest value from Tsd/TsdFrame/TsdTensor argument</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Tsd / TsdFrame / TsdTensor</code> <p>The object holding the values to replace.</p> required <code>ep</code> <code>IntervalSet(optional)</code> <p>The IntervalSet object to restrict the operation. If None, the time support of the tsd input object is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd / TsdFrame / TsdTensor</code> <p>Object with the new values</p> <p>Examples:</p> <p>In this example, the ts object will receive the closest values in time from tsd.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100))) # random times\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,1000), d=np.random.rand(1000), time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 500, time_units = 's')\n</code></pre> <p>The variable ts is a time series object containing only nan. The tsd object containing the values, for example the tracking data, and the epoch to restrict the operation.</p> <pre><code>&gt;&gt;&gt; newts = ts.value_from(tsd, ep)\n</code></pre> <p>newts is the same size as ts restrict to ep.</p> <pre><code>&gt;&gt;&gt; print(len(ts.restrict(ep)), len(newts))\n    52 52\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def value_from(self, data, ep=None):\n    \"\"\"\n    Replace the value with the closest value from Tsd/TsdFrame/TsdTensor argument\n\n    Parameters\n    ----------\n    data : Tsd/TsdFrame/TsdTensor\n        The object holding the values to replace.\n    ep : IntervalSet (optional)\n        The IntervalSet object to restrict the operation.\n        If None, the time support of the tsd input object is used.\n\n    Returns\n    -------\n    out : Tsd/TsdFrame/TsdTensor\n        Object with the new values\n\n    Examples\n    --------\n    In this example, the ts object will receive the closest values in time from tsd.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100))) # random times\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,1000), d=np.random.rand(1000), time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 500, time_units = 's')\n\n    The variable ts is a time series object containing only nan.\n    The tsd object containing the values, for example the tracking data, and the epoch to restrict the operation.\n\n    &gt;&gt;&gt; newts = ts.value_from(tsd, ep)\n\n    newts is the same size as ts restrict to ep.\n\n    &gt;&gt;&gt; print(len(ts.restrict(ep)), len(newts))\n        52 52\n    \"\"\"\n    if not isinstance(data, (TsdTensor, TsdFrame, Tsd)):\n        raise RuntimeError(\n            \"The time series to align to should be Tsd/TsdFrame/TsdTensor.\"\n        )\n\n    if ep is None:\n        ep = data.time_support\n    time_array = self.index.values\n    time_target_array = data.index.values\n    data_target_array = data.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if data_target_array.ndim == 1:\n        t, d, ns, ne = jitvaluefrom(\n            time_array, time_target_array, data_target_array, starts, ends\n        )\n    else:\n        t, d, ns, ne = jitvaluefromtensor(\n            time_array, time_target_array, data_target_array, starts, ends\n        )\n\n    time_support = IntervalSet(start=ns, end=ne)\n\n    if isinstance(data, TsdFrame):\n        return TsdFrame(t=t, d=d, time_support=time_support, columns=data.columns)\n    else:\n        return data.__class__(t, d, time_support=time_support)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.count","title":"count","text":"<pre><code>count(*args, **kwargs)\n</code></pre> <p>Count occurences of events within bin_size or within a set of bins defined as an IntervalSet. You can call this function in multiple ways :</p> <ol> <li> <p>tsd.count(bin_size=1, time_units = 'ms') -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.</p> </li> <li> <p>tsd.count(1, ep=my_epochs) -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.</p> </li> <li> <p>tsd.count(ep=my_bins) -&gt; Count occurent of events within each epoch of the intervalSet object my_bins</p> </li> <li> <p>tsd.count() -&gt; Count occurent of events within each epoch of the time support.</p> </li> </ol> <p>bin_size should be seconds unless specified. If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>None or float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> required <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>Tsd</code> <p>A Tsd object indexed by the center of the bins.</p> <p>Examples:</p> <p>This example shows how to count events within bins of 0.1 second.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; bincount = ts.count(0.1)\n</code></pre> <p>An epoch can be specified:</p> <pre><code>&gt;&gt;&gt; ep = nap.IntervalSet(start = 100, end = 800, time_units = 's')\n&gt;&gt;&gt; bincount = ts.count(0.1, ep=ep)\n</code></pre> <p>And bincount automatically inherit ep as time support:</p> <pre><code>&gt;&gt;&gt; bincount.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0  100.0  800.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def count(self, *args, **kwargs):\n    \"\"\"\n    Count occurences of events within bin_size or within a set of bins defined as an IntervalSet.\n    You can call this function in multiple ways :\n\n    1. *tsd.count(bin_size=1, time_units = 'ms')*\n    -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.\n\n    2. *tsd.count(1, ep=my_epochs)*\n    -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.\n\n    3. *tsd.count(ep=my_bins)*\n    -&gt; Count occurent of events within each epoch of the intervalSet object my_bins\n\n    4. *tsd.count()*\n    -&gt; Count occurent of events within each epoch of the time support.\n\n    bin_size should be seconds unless specified.\n    If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.\n\n    Parameters\n    ----------\n    bin_size : None or float, optional\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: Tsd\n        A Tsd object indexed by the center of the bins.\n\n    Examples\n    --------\n    This example shows how to count events within bins of 0.1 second.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; bincount = ts.count(0.1)\n\n    An epoch can be specified:\n\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 100, end = 800, time_units = 's')\n    &gt;&gt;&gt; bincount = ts.count(0.1, ep=ep)\n\n    And bincount automatically inherit ep as time support:\n\n    &gt;&gt;&gt; bincount.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0  100.0  800.0\n    \"\"\"\n    bin_size = None\n    if \"bin_size\" in kwargs:\n        bin_size = kwargs[\"bin_size\"]\n        if isinstance(bin_size, int):\n            bin_size = float(bin_size)\n        if not isinstance(bin_size, float):\n            raise ValueError(\"bin_size argument should be float.\")\n    else:\n        for a in args:\n            if isinstance(a, (float, int)):\n                bin_size = float(a)\n\n    time_units = \"s\"\n    if \"time_units\" in kwargs:\n        time_units = kwargs[\"time_units\"]\n        if not isinstance(time_units, str):\n            raise ValueError(\"time_units argument should be 's', 'ms' or 'us'.\")\n    else:\n        for a in args:\n            if isinstance(a, str) and a in [\"s\", \"ms\", \"us\"]:\n                time_units = a\n\n    ep = self.time_support\n    if \"ep\" in kwargs:\n        ep = kwargs[\"ep\"]\n        if not isinstance(ep, IntervalSet):\n            raise ValueError(\"ep argument should be IntervalSet\")\n    else:\n        for a in args:\n            if isinstance(a, IntervalSet):\n                ep = a\n\n    time_array = self.index.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if isinstance(bin_size, (float, int)):\n        bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n        t, d = jitcount(time_array, starts, ends, bin_size)\n    else:\n        _, d = jittsrestrict_with_count(time_array, starts, ends)\n        t = starts + (ends - starts) / 2\n\n    return Tsd(t=t, d=d, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.restrict","title":"restrict","text":"<pre><code>restrict(iset)\n</code></pre> <p>Restricts a time series object to a set of time intervals delimited by an IntervalSet object</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>the IntervalSet object</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>(Ts, Tsd, TsdFrame or TsdTensor)</code> <p>Tsd object restricted to ep</p> <p>Examples:</p> <p>The Ts object is restrict to the intervals defined by ep.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n&gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=500, time_units='s')\n&gt;&gt;&gt; newts = ts.restrict(ep)\n</code></pre> <p>The time support of newts automatically inherit the epochs defined by ep.</p> <pre><code>&gt;&gt;&gt; newts.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0    0.0  500.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def restrict(self, iset):\n    \"\"\"\n    Restricts a time series object to a set of time intervals delimited by an IntervalSet object\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        the IntervalSet object\n\n    Returns\n    -------\n    out: Ts, Tsd, TsdFrame or TsdTensor\n        Tsd object restricted to ep\n\n    Examples\n    --------\n    The Ts object is restrict to the intervals defined by ep.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; t = np.unique(np.sort(np.random.randint(0, 1000, 100)))\n    &gt;&gt;&gt; ts = nap.Ts(t=t, time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=500, time_units='s')\n    &gt;&gt;&gt; newts = ts.restrict(ep)\n\n    The time support of newts automatically inherit the epochs defined by ep.\n\n    &gt;&gt;&gt; newts.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0    0.0  500.0\n\n    \"\"\"\n    assert isinstance(iset, IntervalSet), \"Argument should be IntervalSet\"\n\n    time_array = self.index.values\n    starts = iset.start.values\n    ends = iset.end.values\n\n    if isinstance(self.values, np.ndarray):\n        data_array = self.values\n        t, d = jitrestrict(time_array, data_array, starts, ends)\n\n        if hasattr(self, \"columns\"):\n            return TsdFrame(t=t, d=d, time_support=iset, columns=self.columns)\n        else:\n            return self.__class__(t=t, d=d, time_support=iset)\n    else:\n        t = jittsrestrict(time_array, starts, ends)\n        return Ts(t, time_support=iset)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.bin_average","title":"bin_average","text":"<pre><code>bin_average(bin_size, ep=None, time_units='s')\n</code></pre> <p>Bin the data by averaging points within bin_size bin_size should be seconds unless specified. If no epochs is passed, the data will be binned based on the time support.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> <code>None</code> <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Name Type Description <code>out</code> <code>(Tsd, TsdFrame, TsdTensor)</code> <p>A Tsd object indexed by the center of the bins and holding the averaged data points.</p> <p>Examples:</p> <p>This example shows how to bin data within bins of 0.1 second.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n&gt;&gt;&gt; bintsd = tsd.bin_average(0.1)\n</code></pre> <p>An epoch can be specified:</p> <pre><code>&gt;&gt;&gt; ep = nap.IntervalSet(start = 10, end = 80, time_units = 's')\n&gt;&gt;&gt; bintsd = tsd.bin_average(0.1, ep=ep)\n</code></pre> <p>And bintsd automatically inherit ep as time support:</p> <pre><code>&gt;&gt;&gt; bintsd.time_support\n&gt;&gt;&gt;    start    end\n&gt;&gt;&gt; 0  10.0     80.0\n</code></pre> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def bin_average(self, bin_size, ep=None, time_units=\"s\"):\n    \"\"\"\n    Bin the data by averaging points within bin_size\n    bin_size should be seconds unless specified.\n    If no epochs is passed, the data will be binned based on the time support.\n\n    Parameters\n    ----------\n    bin_size : float\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: Tsd, TsdFrame, TsdTensor\n        A Tsd object indexed by the center of the bins and holding the averaged data points.\n\n    Examples\n    --------\n    This example shows how to bin data within bins of 0.1 second.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(100), d=np.random.rand(100))\n    &gt;&gt;&gt; bintsd = tsd.bin_average(0.1)\n\n    An epoch can be specified:\n\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 10, end = 80, time_units = 's')\n    &gt;&gt;&gt; bintsd = tsd.bin_average(0.1, ep=ep)\n\n    And bintsd automatically inherit ep as time support:\n\n    &gt;&gt;&gt; bintsd.time_support\n    &gt;&gt;&gt;    start    end\n    &gt;&gt;&gt; 0  10.0     80.0\n    \"\"\"\n    if not isinstance(ep, IntervalSet):\n        ep = self.time_support\n\n    bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n\n    time_array = self.index.values\n    data_array = self.values\n    starts = ep.start.values\n    ends = ep.end.values\n    if data_array.ndim &gt; 1:\n        t, d = jitbin_array(time_array, data_array, starts, ends, bin_size)\n    else:\n        t, d = jitbin(time_array, data_array, starts, ends, bin_size)\n\n    if d.ndim == 1:\n        return Tsd(t=t, d=d, time_support=ep)\n    elif d.ndim == 2:\n        kwargs = {}\n        if hasattr(self, \"columns\"):\n            kwargs[\"columns\"] = self.columns\n        return TsdFrame(t=t, d=d, time_support=ep, **kwargs)\n    else:\n        return TsdTensor(t=t, d=d, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Copy the data, index and time support</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def copy(self):\n    \"\"\"Copy the data, index and time support\"\"\"\n    return self.__class__(\n        t=self.index.copy(), d=self.values.copy(), time_support=self.time_support\n    )\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.find_support","title":"find_support","text":"<pre><code>find_support(min_gap, time_units='s')\n</code></pre> <p>find the smallest (to a min_gap resolution) IntervalSet containing all the times in the Tsd</p> <p>Parameters:</p> Name Type Description Default <code>min_gap</code> <code>float or int</code> <p>minimal interval between timestamps</p> required <code>time_units</code> <code>str</code> <p>Time units of min gap</p> <code>'s'</code> <p>Returns:</p> Type Description <code>IntervalSet</code> <p>Description</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def find_support(self, min_gap, time_units=\"s\"):\n    \"\"\"\n    find the smallest (to a min_gap resolution) IntervalSet containing all the times in the Tsd\n\n    Parameters\n    ----------\n    min_gap : float or int\n        minimal interval between timestamps\n    time_units : str, optional\n        Time units of min gap\n\n    Returns\n    -------\n    IntervalSet\n        Description\n    \"\"\"\n    assert isinstance(min_gap, Number), \"min_gap should be a float or int\"\n    min_gap = TsIndex.format_timestamps(np.array([min_gap]), time_units)[0]\n    time_array = self.index.values\n\n    starts = [time_array[0]]\n    ends = []\n    for i in range(len(time_array) - 1):\n        if (time_array[i + 1] - time_array[i]) &gt; min_gap:\n            ends.append(time_array[i] + 1e-6)\n            starts.append(time_array[i + 1])\n\n    ends.append(time_array[-1] + 1e-6)\n\n    return IntervalSet(start=starts, end=ends)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.get","title":"get","text":"<pre><code>get(start, end=None, time_units='s')\n</code></pre> <p>Slice the time series from start to end such that all the timestamps satisfy start&lt;=t&lt;=end. If end is None, only the timepoint closest to start is returned.</p> <p>By default, the time support doesn't change. If you want to change the time support, use the restrict function.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float or int</code> <p>The start</p> required <code>end</code> <code>float or int</code> <p>The end</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def get(self, start, end=None, time_units=\"s\"):\n    \"\"\"Slice the time series from start to end such that all the timestamps satisfy start&lt;=t&lt;=end.\n    If end is None, only the timepoint closest to start is returned.\n\n    By default, the time support doesn't change. If you want to change the time support, use the restrict function.\n\n    Parameters\n    ----------\n    start : float or int\n        The start\n    end : float or int\n        The end\n    \"\"\"\n    assert isinstance(start, Number), \"start should be a float or int\"\n    time_array = self.index.values\n\n    if end is None:\n        start = TsIndex.format_timestamps(np.array([start]), time_units)[0]\n        idx = int(np.searchsorted(time_array, start))\n        if idx == 0:\n            return self[idx]\n        elif idx &gt;= self.shape[0]:\n            return self[-1]\n        else:\n            if start - time_array[idx - 1] &lt; time_array[idx] - start:\n                return self[idx - 1]\n            else:\n                return self[idx]\n    else:\n        assert isinstance(end, Number), \"end should be a float or int\"\n        assert start &lt; end, \"Start should not precede end\"\n        start, end = TsIndex.format_timestamps(np.array([start, end]), time_units)\n        idx_start = np.searchsorted(time_array, start)\n        idx_end = np.searchsorted(time_array, end, side=\"right\")\n        return self[idx_start:idx_end]\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.dropna","title":"dropna","text":"<pre><code>dropna(update_time_support=True)\n</code></pre> <p>Drop every rows containing NaNs. By default, the time support is updated to start and end around the time points that are non NaNs. To change this behavior, you can set update_time_support=False.</p> <p>Parameters:</p> Name Type Description Default <code>update_time_support</code> <code>bool</code> <code>True</code> <p>Returns:</p> Type Description <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The time series without the NaNs</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def dropna(self, update_time_support=True):\n    \"\"\"Drop every rows containing NaNs. By default, the time support is updated to start and end around the time points that are non NaNs.\n    To change this behavior, you can set update_time_support=False.\n\n    Parameters\n    ----------\n    update_time_support : bool, optional\n\n    Returns\n    -------\n    Tsd, TsdFrame or TsdTensor\n        The time series without the NaNs\n    \"\"\"\n    index_nan = np.any(np.isnan(self.values), axis=tuple(range(1, self.ndim)))\n    if np.all(index_nan):  # In case it's only NaNs\n        return self.__class__(\n            t=np.array([]), d=np.empty(tuple([0] + [d for d in self.shape[1:]]))\n        )\n\n    elif np.any(index_nan):\n        if update_time_support:\n            time_array = self.index.values\n            starts, ends = jitremove_nan(time_array, index_nan)\n\n            to_fix = starts == ends\n            if np.any(to_fix):\n                ends[\n                    to_fix\n                ] += 1e-6  # adding 1 millisecond in case of a single point\n\n            ep = IntervalSet(starts, ends)\n\n            return self.__class__(\n                t=time_array[~index_nan], d=self.values[~index_nan], time_support=ep\n            )\n\n        else:\n            return self[~index_nan]\n\n    else:\n        return self\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.convolve","title":"convolve","text":"<pre><code>convolve(array, ep=None, trim='both')\n</code></pre> <p>Return the discrete linear convolution of the time series with a one dimensional sequence.</p> <p>A parameter ep can control the epochs for which the convolution will apply. Otherwise the convolution is made over the time support.</p> <p>This function assume a constant sampling rate of the time series.</p> <p>The only mode supported is full. The returned object is trimmed to match the size of the original object. The parameter trim controls which side the trimming operates. Default is 'both'.</p> <p>See the numpy documentation here : https://numpy.org/doc/stable/reference/generated/numpy.convolve.html</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>One dimensional input array</p> required <code>ep</code> <code>None</code> <p>The epochs to apply the convolution</p> <code>None</code> <code>trim</code> <code>str</code> <p>The side on which to trim the output of the convolution ('left', 'right', 'both' [default])</p> <code>'both'</code> <p>Returns:</p> Type Description <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The convolved time series</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def convolve(self, array, ep=None, trim=\"both\"):\n    \"\"\"Return the discrete linear convolution of the time series with a one dimensional sequence.\n\n    A parameter ep can control the epochs for which the convolution will apply. Otherwise the convolution is made over the time support.\n\n    This function assume a constant sampling rate of the time series.\n\n    The only mode supported is full. The returned object is trimmed to match the size of the original object. The parameter trim controls which side the trimming operates. Default is 'both'.\n\n    See the numpy documentation here : https://numpy.org/doc/stable/reference/generated/numpy.convolve.html\n\n    Parameters\n    ----------\n    array : np.ndarray\n        One dimensional input array\n    ep : None, optional\n        The epochs to apply the convolution\n    trim : str, optional\n        The side on which to trim the output of the convolution ('left', 'right', 'both' [default])\n\n    Returns\n    -------\n    Tsd, TsdFrame or TsdTensor\n        The convolved time series\n    \"\"\"\n    assert isinstance(array, np.ndarray), \"Input should be a 1-d numpy array.\"\n    assert array.ndim == 1, \"Input should be a one dimensional array.\"\n    assert trim in [\n        \"both\",\n        \"left\",\n        \"right\",\n    ], \"Unknow argument. trim should be 'both', 'left' or 'right'.\"\n\n    if ep is None:\n        ep = self.time_support\n\n    time_array = self.index.values\n    data_array = self.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if data_array.ndim == 1:\n        new_data_array = np.zeros(data_array.shape)\n        k = array.shape[0]\n        for s, e in zip(starts, ends):\n            idx_s = np.searchsorted(time_array, s)\n            idx_e = np.searchsorted(time_array, e, side=\"right\")\n\n            t = idx_e - idx_s\n            if trim == \"left\":\n                cut = (k - 1, t + k - 1)\n            elif trim == \"right\":\n                cut = (0, t)\n            else:\n                cut = ((1 - k % 2) + (k - 1) // 2, t + k - 1 - ((k - 1) // 2))\n            # scipy is actually faster for Tsd\n            new_data_array[idx_s:idx_e] = signal.convolve(\n                data_array[idx_s:idx_e], array\n            )[cut[0] : cut[1]]\n\n        return self.__class__(t=time_array, d=new_data_array, time_support=ep)\n    else:\n        new_data_array = np.zeros(data_array.shape)\n        for s, e in zip(starts, ends):\n            idx_s = np.searchsorted(time_array, s)\n            idx_e = np.searchsorted(time_array, e, side=\"right\")\n            new_data_array[idx_s:idx_e] = pjitconvolve(\n                data_array[idx_s:idx_e], array, trim=trim\n            )\n\n        return self.__class__(t=time_array, d=new_data_array, time_support=ep)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.smooth","title":"smooth","text":"<pre><code>smooth(std, size)\n</code></pre> <p>Smooth a time series with a gaussian kernel. std is the standard deviation and size is the number of point of the window.</p> <p>See the scipy documentation : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.gaussian.html</p> <p>Parameters:</p> Name Type Description Default <code>std</code> <code>int</code> <p>Standard deviation</p> required <code>size</code> <code>int</code> <p>Description</p> required <p>Returns:</p> Type Description <code>(Tsd, TsdFrame, TsdTensor)</code> <p>Time series convolved with a gaussian kernel</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def smooth(self, std, size):\n    \"\"\"Smooth a time series with a gaussian kernel. std is the standard deviation and size is the number of point of the window.\n\n    See the scipy documentation : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.gaussian.html\n\n    Parameters\n    ----------\n    std : int\n        Standard deviation\n    size : int\n        Description\n\n    Returns\n    -------\n    Tsd, TsdFrame, TsdTensor\n        Time series convolved with a gaussian kernel\n    \"\"\"\n    assert isinstance(std, int), \"std should be type int\"\n    assert isinstance(size, int), \"size should be type int\"\n    window = signal.windows.gaussian(size, std=std)\n    window = window / window.sum()\n    return self.convolve(window)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.interpolate","title":"interpolate","text":"<pre><code>interpolate(ts, ep=None, left=None, right=None)\n</code></pre> <p>Wrapper of the numpy linear interpolation method. See https://numpy.org/doc/stable/reference/generated/numpy.interp.html for an explanation of the parameters. The argument ts should be Ts, Tsd, TsdFrame, TsdTensor to ensure interpolating from sorted timestamps in the right unit,</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>(Ts, Tsd or TsdFrame)</code> <p>The object holding the timestamps</p> required <code>ep</code> <code>IntervalSet</code> <p>The epochs to use to interpolate. If None, the time support of Tsd is used.</p> <code>None</code> <code>left</code> <code>None</code> <p>Value to return for ts &lt; tsd[0], default is tsd[0].</p> <code>None</code> <code>right</code> <code>None</code> <p>Value to return for ts &gt; tsd[-1], default is tsd[-1].</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def interpolate(self, ts, ep=None, left=None, right=None):\n    \"\"\"Wrapper of the numpy linear interpolation method. See https://numpy.org/doc/stable/reference/generated/numpy.interp.html for an explanation of the parameters.\n    The argument ts should be Ts, Tsd, TsdFrame, TsdTensor to ensure interpolating from sorted timestamps in the right unit,\n\n    Parameters\n    ----------\n    ts : Ts, Tsd or TsdFrame\n        The object holding the timestamps\n    ep : IntervalSet, optional\n        The epochs to use to interpolate. If None, the time support of Tsd is used.\n    left : None, optional\n        Value to return for ts &lt; tsd[0], default is tsd[0].\n    right : None, optional\n        Value to return for ts &gt; tsd[-1], default is tsd[-1].\n    \"\"\"\n    if not isinstance(ts, (Ts, Tsd, TsdFrame, TsdTensor)):\n        raise RuntimeError(\n            \"First argument should be an instance of Ts, Tsd or TsdFrame\"\n        )\n\n    if not isinstance(ep, IntervalSet):\n        ep = self.time_support\n\n    new_t = ts.restrict(ep).index\n\n    new_shape = (\n        len(new_t) if self.values.ndim == 1 else (len(new_t),) + self.shape[1:]\n    )\n    new_d = np.full(new_shape, np.nan)\n\n    start = 0\n    for i in range(len(ep)):\n        t = ts.get(ep.loc[i, \"start\"], ep.loc[i, \"end\"])\n        tmp = self.get(ep.loc[i, \"start\"], ep.loc[i, \"end\"])\n\n        if len(t) and len(tmp):\n            if self.values.ndim == 1:\n                new_d[start : start + len(t)] = np.interp(\n                    t.index.values,\n                    tmp.index.values,\n                    tmp.values,\n                    left=left,\n                    right=right,\n                )\n            else:\n                interpolated_values = np.apply_along_axis(\n                    lambda row: np.interp(\n                        t.index.values,\n                        tmp.index.values,\n                        row,\n                        left=left,\n                        right=right,\n                    ),\n                    0,\n                    tmp.values,\n                )\n                new_d[start : start + len(t), ...] = interpolated_values\n\n        start += len(t)\n    kwargs_dict = dict(time_support=ep)\n    if hasattr(self, \"columns\"):\n        kwargs_dict[\"columns\"] = self.columns\n    return self.__class__(t=new_t, d=new_d, **kwargs_dict)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.__init__","title":"__init__","text":"<pre><code>__init__(t, time_units='s', time_support=None)\n</code></pre> <p>Ts Initializer</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray or Series</code> <p>An object transformable in a time series, or a pandas.Series equivalent (if d is None)</p> required <code>time_units</code> <code>str</code> <p>The time units in which times are specified ('us', 'ms', 's' [default])</p> <code>'s'</code> <code>time_support</code> <code>IntervalSet</code> <p>The time support of the Ts object</p> <code>None</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def __init__(self, t, time_units=\"s\", time_support=None):\n    \"\"\"\n    Ts Initializer\n\n    Parameters\n    ----------\n    t : numpy.ndarray or pandas.Series\n        An object transformable in a time series, or a pandas.Series equivalent (if d is None)\n    time_units : str, optional\n        The time units in which times are specified ('us', 'ms', 's' [default])\n    time_support : IntervalSet, optional\n        The time support of the Ts object\n    \"\"\"\n    if isinstance(t, Number):\n        t = np.array([t])\n\n    if isinstance(t, TsIndex):\n        self.index = t\n    else:\n        # Checking timestamps\n        self.index = TsIndex(t, time_units)\n\n    if len(self.index):\n        if isinstance(time_support, IntervalSet):\n            starts = time_support.start.values\n            ends = time_support.end.values\n            t = jittsrestrict(self.index.values, starts, ends)\n            self.index = TsIndex(t)\n        else:\n            time_support = IntervalSet(start=t[0], end=t[-1])\n\n        self.time_support = time_support\n        self.rate = self.index.shape[0] / np.sum(\n            time_support.values[:, 1] - time_support.values[:, 0]\n        )\n    else:\n        self.rate = np.NaN\n        self.time_support = IntervalSet(start=[], end=[])\n\n    self.values = None\n    self.nap_class = self.__class__.__name__\n    self._initialized = True\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.as_series","title":"as_series","text":"<pre><code>as_series()\n</code></pre> <p>Convert the Ts/Tsd object to a pandas.Series object.</p> <p>Returns:</p> Name Type Description <code>out</code> <code>Series</code> <p>_</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_series(self):\n    \"\"\"\n    Convert the Ts/Tsd object to a pandas.Series object.\n\n    Returns\n    -------\n    out: pandas.Series\n        _\n    \"\"\"\n    return pd.Series(index=self.index.values, dtype=\"object\")\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.as_units","title":"as_units","text":"<pre><code>as_units(units='s')\n</code></pre> <p>Returns a pandas Series with time expressed in the desired unit.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str</code> <p>('us', 'ms', 's' [default])</p> <code>'s'</code> <p>Returns:</p> Type Description <code>Series</code> <p>the series object with adjusted times</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def as_units(self, units=\"s\"):\n    \"\"\"\n    Returns a pandas Series with time expressed in the desired unit.\n\n    Parameters\n    ----------\n    units : str, optional\n        ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    pandas.Series\n        the series object with adjusted times\n    \"\"\"\n    t = self.index.in_units(units)\n    if units == \"us\":\n        t = t.astype(np.int64)\n    ss = pd.Series(index=t, dtype=\"object\")\n    ss.index.name = \"Time (\" + str(units) + \")\"\n    return ss\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.fillna","title":"fillna","text":"<pre><code>fillna(value)\n</code></pre> <p>Similar to pandas fillna function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Number</code> <p>Value for filling</p> required <p>Returns:</p> Type Description <code>Tsd</code> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def fillna(self, value):\n    \"\"\"\n    Similar to pandas fillna function.\n\n    Parameters\n    ----------\n    value : Number\n        Value for filling\n\n    Returns\n    -------\n    Tsd\n\n\n    \"\"\"\n    assert isinstance(value, Number), \"Only a scalar can be passed to fillna\"\n    d = np.empty(len(self))\n    d.fill(value)\n    return Tsd(t=self.index, d=d, time_support=self.time_support)\n</code></pre>"},{"location":"reference/core/time_series/#pynapple.core.time_series.Ts.save","title":"save","text":"<pre><code>save(filename)\n</code></pre> <p>Save Ts object in npz format. The file will contain the timestamps and the time support.</p> <p>The main purpose of this function is to save small/medium sized timestamps object.</p> <p>You can load the object with numpy.load. Keys are 't', 'start' and 'end' and 'type'. See the example below.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; ts = nap.Ts(t=np.array([0., 1., 1.5]))\n&gt;&gt;&gt; ts.save(\"my_path/my_ts.npz\")\n</code></pre> <p>Here I can retrieve my data with numpy directly:</p> <pre><code>&gt;&gt;&gt; file = np.load(\"my_path/my_ts.npz\")\n&gt;&gt;&gt; print(list(file.keys()))\n['t', 'start', 'end', 'type']\n&gt;&gt;&gt; print(file['t'])\n[0. 1. 1.5]\n</code></pre> <p>It is then easy to recreate the Tsd object.</p> <pre><code>&gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n&gt;&gt;&gt; nap.Ts(t=file['t'], time_support=time_support)\nTime (s)\n0.0\n1.0\n1.5\n</code></pre> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If filename is not str, path does not exist or filename is a directory.</p> Source code in <code>pynapple/core/time_series.py</code> <pre><code>def save(self, filename):\n    \"\"\"\n    Save Ts object in npz format. The file will contain the timestamps and\n    the time support.\n\n    The main purpose of this function is to save small/medium sized timestamps\n    object.\n\n    You can load the object with numpy.load. Keys are 't', 'start' and 'end' and 'type'.\n    See the example below.\n\n    Parameters\n    ----------\n    filename : str\n        The filename\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; ts = nap.Ts(t=np.array([0., 1., 1.5]))\n    &gt;&gt;&gt; ts.save(\"my_path/my_ts.npz\")\n\n    Here I can retrieve my data with numpy directly:\n\n    &gt;&gt;&gt; file = np.load(\"my_path/my_ts.npz\")\n    &gt;&gt;&gt; print(list(file.keys()))\n    ['t', 'start', 'end', 'type']\n    &gt;&gt;&gt; print(file['t'])\n    [0. 1. 1.5]\n\n    It is then easy to recreate the Tsd object.\n    &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n    &gt;&gt;&gt; nap.Ts(t=file['t'], time_support=time_support)\n    Time (s)\n    0.0\n    1.0\n    1.5\n\n\n    Raises\n    ------\n    RuntimeError\n        If filename is not str, path does not exist or filename is a directory.\n    \"\"\"\n    if not isinstance(filename, str):\n        raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n    if os.path.isdir(filename):\n        raise RuntimeError(\n            \"Invalid filename input. {} is directory.\".format(filename)\n        )\n\n    if not filename.lower().endswith(\".npz\"):\n        filename = filename + \".npz\"\n\n    dirname = os.path.dirname(filename)\n\n    if len(dirname) and not os.path.exists(dirname):\n        raise RuntimeError(\n            \"Path {} does not exist.\".format(os.path.dirname(filename))\n        )\n\n    np.savez(\n        filename,\n        t=self.index.values,\n        start=self.time_support.start.values,\n        end=self.time_support.end.values,\n        type=np.array([\"Ts\"], dtype=np.str_),\n    )\n\n    return\n</code></pre>"},{"location":"reference/core/time_units/","title":"Time units","text":""},{"location":"reference/core/time_units/#pynapple.core.time_units","title":"pynapple.core.time_units","text":"<p>DEPRECATED This class deals with conversion between different time units for all pynapple objects. It also provides a context manager that tweaks the default time units to the supported units:</p> <ul> <li>'us': microseconds</li> <li>'ms': milliseconds</li> <li>'s': seconds  (overall default)</li> </ul>"},{"location":"reference/core/time_units/#pynapple.core.time_units.format_timestamps","title":"format_timestamps","text":"<pre><code>format_timestamps(t, units='s')\n</code></pre> <p>Converts time index in pynapple in a default format</p> <p>Args:     t: a vector (or scalar) of times     units: the units in which times are given</p> <p>Returns:     t: times in standard pynapple format</p> Source code in <code>pynapple/core/time_units.py</code> <pre><code>def format_timestamps(t, units=\"s\"):\n    \"\"\"\n    Converts time index in pynapple in a default format\n\n    Args:\n        t: a vector (or scalar) of times\n        units: the units in which times are given\n\n    Returns:\n        t: times in standard pynapple format\n    \"\"\"\n    if units == \"s\":\n        t = np.around(t, 9)\n    elif units == \"ms\":\n        t = np.around(t / 1.0e3, 9)\n    elif units == \"us\":\n        t = np.around(t / 1.0e6, 9)\n    else:\n        raise ValueError(\"unrecognized time units type\")\n\n    return t\n</code></pre>"},{"location":"reference/core/time_units/#pynapple.core.time_units.return_timestamps","title":"return_timestamps","text":"<pre><code>return_timestamps(t, units='s')\n</code></pre> <p>Converts time index in pynapple in a particular format</p> <p>Args:     t: a vector (or scalar) of times     units: the units in which times are given</p> <p>Returns:     t: times in standard pynapple format</p> Source code in <code>pynapple/core/time_units.py</code> <pre><code>def return_timestamps(t, units=\"s\"):\n    \"\"\"\n    Converts time index in pynapple in a particular format\n\n    Args:\n        t: a vector (or scalar) of times\n        units: the units in which times are given\n\n    Returns:\n        t: times in standard pynapple format\n    \"\"\"\n    if units == \"s\":\n        t = np.around(t, 9)\n    elif units == \"ms\":\n        t = np.around(t * 1.0e3, 9)\n    elif units == \"us\":\n        t = np.around(t * 1.0e6, 9)\n    else:\n        raise ValueError(\"unrecognized time units type\")\n\n    return t\n</code></pre>"},{"location":"reference/core/ts_group/","title":"Ts group","text":""},{"location":"reference/core/ts_group/#pynapple.core.ts_group","title":"pynapple.core.ts_group","text":""},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup","title":"TsGroup","text":"<p>             Bases: <code>UserDict</code></p> <p>The TsGroup is a dictionnary-like object to hold multiple <code>Ts</code> or <code>Tsd</code> objects with different time index.</p> <p>Attributes:</p> Name Type Description <code>time_support</code> <code>IntervalSet</code> <p>The time support of the TsGroup</p> <code>rates</code> <code>Series</code> <p>The rate of each element of the TsGroup</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>class TsGroup(UserDict):\n    \"\"\"\n    The TsGroup is a dictionnary-like object to hold multiple [`Ts`][pynapple.core.time_series.Ts] or [`Tsd`][pynapple.core.time_series.Tsd] objects with different time index.\n\n    Attributes\n    ----------\n    time_support: IntervalSet\n        The time support of the TsGroup\n    rates : pandas.Series\n        The rate of each element of the TsGroup\n    \"\"\"\n\n    def __init__(\n        self, data, time_support=None, time_units=\"s\", bypass_check=False, **kwargs\n    ):\n        \"\"\"\n        TsGroup Initializer\n\n        Parameters\n        ----------\n        data : dict\n            Dictionnary containing Ts/Tsd objects\n        time_support : IntervalSet, optional\n            The time support of the TsGroup. Ts/Tsd objects will be restricted to the time support if passed.\n            If no time support is specified, TsGroup will merge time supports from all the Ts/Tsd objects in data.\n        time_units : str, optional\n            Time units if data does not contain Ts/Tsd objects ('us', 'ms', 's' [default]).\n        bypass_check: bool, optional\n            To avoid checking that each element is within time_support.\n            Useful to speed up initialization of TsGroup when Ts/Tsd objects have already been restricted beforehand\n        **kwargs\n            Meta-info about the Ts/Tsd objects. Can be either pandas.Series or numpy.ndarray.\n            Note that the index should match the index of the input dictionnary.\n\n        Raises\n        ------\n        RuntimeError\n            Raise error if the union of time support of Ts/Tsd object is empty.\n        \"\"\"\n        self._initialized = False\n\n        self.index = np.sort(list(data.keys()))\n\n        self._metadata = pd.DataFrame(index=self.index, columns=[\"rate\"], dtype=\"float\")\n\n        # Transform elements to Ts/Tsd objects\n        for k in self.index:\n            if isinstance(data[k], (np.ndarray, list)):\n                warnings.warn(\n                    \"Elements should not be passed as numpy array. Default time units is seconds when creating the Ts object.\",\n                    stacklevel=2,\n                )\n                data[k] = Ts(\n                    t=data[k], time_support=time_support, time_units=time_units\n                )\n\n        # If time_support is passed, all elements of data are restricted prior to init\n        if isinstance(time_support, IntervalSet):\n            self.time_support = time_support\n            if not bypass_check:\n                data = {k: data[k].restrict(self.time_support) for k in self.index}\n        else:\n            # Otherwise do the union of all time supports\n            time_support = union_intervals([data[k].time_support for k in self.index])\n            if len(time_support) == 0:\n                raise RuntimeError(\n                    \"Union of time supports is empty. Consider passing a time support as argument.\"\n                )\n            self.time_support = time_support\n            if not bypass_check:\n                data = {k: data[k].restrict(self.time_support) for k in self.index}\n\n        UserDict.__init__(self, data)\n\n        # Making the TsGroup non mutable\n        self._initialized = True\n\n        # Trying to add argument as metainfo\n        self.set_info(**kwargs)\n\n    \"\"\"\n    Base functions\n    \"\"\"\n\n    def __setitem__(self, key, value):\n        if self._initialized:\n            raise RuntimeError(\"TsGroup object is not mutable.\")\n\n        self._metadata.loc[int(key), \"rate\"] = float(value.rate)\n        super().__setitem__(int(key), value)\n        # if self.__contains__(key):\n        #     raise KeyError(\"Key {} already in group index.\".format(key))\n        # else:\n        # if isinstance(value, (Ts, Tsd)):\n        #     self._metadata.loc[int(key), \"rate\"] = value.rate\n        #     super().__setitem__(int(key), value)\n        # elif isinstance(value, (np.ndarray, list)):\n        #     warnings.warn(\n        #         \"Elements should not be passed as numpy array. Default time units is seconds when creating the Ts object.\",\n        #         stacklevel=2,\n        #     )\n        #     tmp = Ts(t=value, time_units=\"s\")\n        #     self._metadata.loc[int(key), \"rate\"] = tmp.rate\n        #     super().__setitem__(int(key), tmp)\n        # else:\n        #     raise ValueError(\"Value with key {} is not an iterable.\".format(key))\n\n    def __getitem__(self, key):\n        if key.__hash__:\n            if self.__contains__(key):\n                return self.data[key]\n            else:\n                raise KeyError(\"Can't find key {} in group index.\".format(key))\n        else:\n            metadata = self._metadata.loc[key, self._metadata.columns.drop(\"rate\")]\n            return TsGroup(\n                {k: self[k] for k in key}, time_support=self.time_support, **metadata\n            )\n\n    def __repr__(self):\n        cols = self._metadata.columns.drop(\"rate\")\n        headers = [\"Index\", \"rate\"] + [c for c in cols]\n        lines = []\n\n        for i in self.data.keys():\n            lines.append(\n                [str(i), \"%.2f\" % self._metadata.loc[i, \"rate\"]]\n                + [self._metadata.loc[i, c] for c in cols]\n            )\n        return tabulate(lines, headers=headers)\n\n    def __str__(self):\n        return self.__repr__()\n\n    def keys(self):\n        \"\"\"\n        Return index/keys of TsGroup\n\n        Returns\n        -------\n        list\n            List of keys\n        \"\"\"\n        return list(self.data.keys())\n\n    def items(self):\n        \"\"\"\n        Return a list of key/object.\n\n        Returns\n        -------\n        list\n            List of tuples\n        \"\"\"\n        return list(self.data.items())\n\n    def values(self):\n        \"\"\"\n        Return a list of all the Ts/Tsd objects in the TsGroup\n\n        Returns\n        -------\n        list\n            List of Ts/Tsd objects\n        \"\"\"\n        return list(self.data.values())\n\n    @property\n    def rates(self):\n        \"\"\"\n        Return the rates of each element of the group in Hz\n        \"\"\"\n        return self._metadata[\"rate\"]\n\n    #######################\n    # Metadata\n    #######################\n\n    @property\n    def metadata_columns(self):\n        \"\"\"\n        Returns list of metadata columns\n        -------\n        \"\"\"\n        return list(self._metadata.columns)\n\n    def set_info(self, *args, **kwargs):\n        \"\"\"\n        Add metadata informations about the TsGroup.\n        Metadata are saved as a DataFrame.\n\n        Parameters\n        ----------\n        *args\n            pandas.Dataframe or list of pandas.DataFrame\n        **kwargs\n            Can be either pandas.Series, numpy.ndarray, list or tuple\n\n        Raises\n        ------\n        RuntimeError\n            Raise an error if\n                no column labels are found when passing simple arguments,\n                indexes are not equals for a pandas series,\n                not the same length when passing numpy array.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n        1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n        2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n        }\n        &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n\n        To add metadata with a pandas.DataFrame:\n\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; structs = pd.DataFrame(index = [0,1,2], data=['pfc','pfc','ca1'], columns=['struct'])\n        &gt;&gt;&gt; tsgroup.set_info(structs)\n        &gt;&gt;&gt; tsgroup\n          Index    Freq. (Hz)  struct\n        -------  ------------  --------\n              0             1  pfc\n              1             2  pfc\n              2             4  ca1\n\n        To add metadata with a pd.Series, numpy.ndarray, list or tuple:\n\n        &gt;&gt;&gt; hd = pd.Series(index = [0,1,2], data = [0,1,1])\n        &gt;&gt;&gt; tsgroup.set_info(hd=hd)\n        &gt;&gt;&gt; tsgroup\n          Index    Freq. (Hz)  struct      hd\n        -------  ------------  --------  ----\n              0             1  pfc          0\n              1             2  pfc          1\n              2             4  ca1          1\n\n        \"\"\"\n        if len(args):\n            for arg in args:\n                if isinstance(arg, pd.DataFrame):\n                    if pd.Index.equals(self._metadata.index, arg.index):\n                        self._metadata = self._metadata.join(arg)\n                    else:\n                        raise RuntimeError(\"Index are not equals\")\n                elif isinstance(arg, (pd.Series, np.ndarray)):\n                    raise RuntimeError(\"Columns needs to be labelled for metadata\")\n        if len(kwargs):\n            for k, v in kwargs.items():\n                if isinstance(v, pd.Series):\n                    if pd.Index.equals(self._metadata.index, v.index):\n                        self._metadata[k] = v\n                    else:\n                        raise RuntimeError(\"Index are not equals\")\n                elif isinstance(v, (np.ndarray, list, tuple)):\n                    if len(self._metadata) == len(v):\n                        self._metadata[k] = np.asarray(v)\n                    else:\n                        raise RuntimeError(\"Array is not the same length.\")\n        return\n\n    def get_info(self, key):\n        \"\"\"\n        Returns the metainfo located in one column.\n        The key for the column frequency is \"rate\".\n\n        Parameters\n        ----------\n        key : str\n            One of the metainfo columns name\n\n        Returns\n        -------\n        pandas.Series\n            The metainfo\n        \"\"\"\n        if key in [\"freq\", \"frequency\"]:\n            key = \"rate\"\n        return self._metadata[key]\n\n    #################################\n    # Generic functions of Tsd objects\n    #################################\n    def restrict(self, ep):\n        \"\"\"\n        Restricts a TsGroup object to a set of time intervals delimited by an IntervalSet object\n\n        Parameters\n        ----------\n        ep : IntervalSet\n            the IntervalSet object\n\n        Returns\n        -------\n        TsGroup\n            TsGroup object restricted to ep\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n        1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n        2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n        }\n        &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n        &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n        &gt;&gt;&gt; newtsgroup = tsgroup.restrict(ep)\n\n        All objects within the TsGroup automatically inherit the epochs defined by ep.\n\n        &gt;&gt;&gt; newtsgroup.time_support\n           start    end\n        0    0.0  100.0\n        &gt;&gt;&gt; newtsgroup[0].time_support\n           start    end\n        0    0.0  100.0\n        \"\"\"\n        newgr = {}\n        for k in self.index:\n            newgr[k] = self.data[k].restrict(ep)\n        cols = self._metadata.columns.drop(\"rate\")\n\n        return TsGroup(\n            newgr, time_support=ep, bypass_check=True, **self._metadata[cols]\n        )\n\n    def value_from(self, tsd, ep=None):\n        \"\"\"\n        Replace the value of each Ts/Tsd object within the Ts group with the closest value from tsd argument\n\n        Parameters\n        ----------\n        tsd : Tsd\n            The Tsd object holding the values to replace\n        ep : IntervalSet\n            The IntervalSet object to restrict the operation.\n            If None, the time support of the tsd input object is used.\n\n        Returns\n        -------\n        TsGroup\n            TsGroup object with the new values\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n        1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n        2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n        }\n        &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n        &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n\n        The variable tsd is a time series object containing the values to assign, for example the tracking data:\n\n        &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,100), d=np.random.rand(100), time_units='s')\n        &gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 100, time_units = 's')\n        &gt;&gt;&gt; newtsgroup = tsgroup.value_from(tsd, ep)\n\n        \"\"\"\n        if ep is None:\n            ep = tsd.time_support\n\n        newgr = {}\n        for k in self.data:\n            newgr[k] = self.data[k].value_from(tsd, ep)\n\n        cols = self._metadata.columns.drop(\"rate\")\n        return TsGroup(newgr, time_support=ep, **self._metadata[cols])\n\n    def count(self, *args, **kwargs):\n        \"\"\"\n        Count occurences of events within bin_size or within a set of bins defined as an IntervalSet.\n        You can call this function in multiple ways :\n\n        1. *tsgroup.count(bin_size=1, time_units = 'ms')*\n        -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.\n\n        2. *tsgroup.count(1, ep=my_epochs)*\n        -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.\n\n        3. *tsgroup.count(ep=my_bins)*\n        -&gt; Count occurent of events within each epoch of the intervalSet object my_bins\n\n        4. *tsgroup.count()*\n        -&gt; Count occurent of events within each epoch of the time support.\n\n        bin_size should be seconds unless specified.\n        If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.\n\n        Parameters\n        ----------\n        bin_size : None or float, optional\n            The bin size (default is second)\n        ep : None or IntervalSet, optional\n            IntervalSet to restrict the operation\n        time_units : str, optional\n            Time units of bin size ('us', 'ms', 's' [default])\n\n        Returns\n        -------\n        out: TsdFrame\n            A TsdFrame with the columns being the index of each item in the TsGroup.\n\n        Examples\n        --------\n        This example shows how to count events within bins of 0.1 second for the first 100 seconds.\n\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n        1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n        2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n        }\n        &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n        &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n        &gt;&gt;&gt; bincount = tsgroup.count(0.1, ep)\n        &gt;&gt;&gt; bincount\n                  0  1  2\n        Time (s)\n        0.05      0  0  0\n        0.15      0  0  0\n        0.25      0  0  1\n        0.35      0  0  0\n        0.45      0  0  0\n        ...      .. .. ..\n        99.55     0  1  1\n        99.65     0  0  0\n        99.75     0  0  1\n        99.85     0  0  0\n        99.95     1  1  1\n        [1000 rows x 3 columns]\n\n        \"\"\"\n        bin_size = None\n        if \"bin_size\" in kwargs:\n            bin_size = kwargs[\"bin_size\"]\n            if isinstance(bin_size, int):\n                bin_size = float(bin_size)\n            if not isinstance(bin_size, float):\n                raise ValueError(\"bin_size argument should be float.\")\n        else:\n            for a in args:\n                if isinstance(a, (float, int)):\n                    bin_size = float(a)\n\n        time_units = \"s\"\n        if \"time_units\" in kwargs:\n            time_units = kwargs[\"time_units\"]\n            if not isinstance(time_units, str):\n                raise ValueError(\"time_units argument should be 's', 'ms' or 'us'.\")\n        else:\n            for a in args:\n                if isinstance(a, str) and a in [\"s\", \"ms\", \"us\"]:\n                    time_units = a\n\n        ep = self.time_support\n        if \"ep\" in kwargs:\n            ep = kwargs[\"ep\"]\n            if not isinstance(ep, IntervalSet):\n                raise ValueError(\"ep argument should be IntervalSet\")\n        else:\n            for a in args:\n                if isinstance(a, IntervalSet):\n                    ep = a\n\n        starts = ep.start.values\n        ends = ep.end.values\n\n        if isinstance(bin_size, (float, int)):\n            bin_size = float(bin_size)\n            bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n            time_index, _ = jitcount(np.array([]), starts, ends, bin_size)\n            n = len(self.index)\n            count = np.zeros((time_index.shape[0], n), dtype=np.int64)\n\n            for i in range(n):\n                count[:, i] = jitcount(\n                    self.data[self.index[i]].index, starts, ends, bin_size\n                )[1]\n\n        else:\n            time_index = starts + (ends - starts) / 2\n            n = len(self.index)\n            count = np.zeros((time_index.shape[0], n), dtype=np.int64)\n\n            for i in range(n):\n                count[:, i] = jittsrestrict_with_count(\n                    self.data[self.index[i]].index, starts, ends\n                )[1]\n\n        toreturn = TsdFrame(t=time_index, d=count, time_support=ep, columns=self.index)\n        return toreturn\n\n    def to_tsd(self, *args):\n        \"\"\"\n        Convert TsGroup to a Tsd. The timestamps of the TsGroup are merged together and sorted.\n\n        Parameters\n        ----------\n        *args\n            string, list, numpy.ndarray or pandas.Series\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tsgroup = nap.TsGroup({0:nap.Ts(t=np.array([0, 1])), 5:nap.Ts(t=np.array([2, 3]))})\n        Index    rate\n        -------  ------\n        0       1\n        5       1\n\n        By default, the values of the Tsd is the index of the timestamp in the TsGroup:\n\n        &gt;&gt;&gt; tsgroup.to_tsd()\n        Time (s)\n        0.0    0.0\n        1.0    0.0\n        2.0    5.0\n        3.0    5.0\n        dtype: float64\n\n        Values can be inherited from the metadata of the TsGroup by giving the key of the corresponding columns.\n\n        &gt;&gt;&gt; tsgroup.set_info( phase=np.array([np.pi, 2*np.pi]) ) # assigning a phase to my 2 elements of the TsGroup\n        &gt;&gt;&gt; tsgroup.to_tsd(\"phase\")\n        Time (s)\n        0.0    3.141593\n        1.0    3.141593\n        2.0    6.283185\n        3.0    6.283185\n        dtype: float64\n\n        Values can also be passed directly to the function from a list, numpy.ndarray or pandas.Series of values as long as the length matches :\n\n        &gt;&gt;&gt; tsgroup.to_tsd([-1, 1])\n        Time (s)\n        0.0   -1.0\n        1.0   -1.0\n        2.0    1.0\n        3.0    1.0\n        dtype: float64\n\n        The reverse operation can be done with the Tsd.to_tsgroup function :\n\n        &gt;&gt;&gt; my_tsd\n        Time (s)\n        0.0    0.0\n        1.0    0.0\n        2.0    5.0\n        3.0    5.0\n        dtype: float64\n        &gt;&gt;&gt; my_tsd.to_tsgroup()\n          Index    rate\n        -------  ------\n              0       1\n              5       1\n\n        Returns\n        -------\n        Tsd\n\n        Raises\n        ------\n        RuntimeError\n            \"Index are not equals\" : if pandas.Series indexes don't match the TsGroup indexes\n            \"Values is not the same length\" : if numpy.ndarray/list object is not the same size as the TsGroup object\n            \"Key not in metadata of TsGroup\" : if string argument does not match any column names of the metadata,\n            \"Unknown argument format\" ; if argument is not a string, list, numpy.ndarray or pandas.Series\n\n        \"\"\"\n        if len(args):\n            if isinstance(args[0], pd.Series):\n                if pd.Index.equals(self._metadata.index, args[0].index):\n                    _values = args[0].values.flatten()\n                else:\n                    raise RuntimeError(\"Index are not equals\")\n            elif isinstance(args[0], (np.ndarray, list)):\n                if len(self._metadata) == len(args[0]):\n                    _values = np.array(args[0])\n                else:\n                    raise RuntimeError(\"Values is not the same length.\")\n            elif isinstance(args[0], str):\n                if args[0] in self._metadata.columns:\n                    _values = self._metadata[args[0]].values\n                else:\n                    raise RuntimeError(\n                        \"Key {} not in metadata of TsGroup\".format(args[0])\n                    )\n            else:\n                possible_keys = []\n                for k, d in self._metadata.dtypes.items():\n                    if \"int\" in str(d) or \"float\" in str(d):\n                        possible_keys.append(k)\n                raise RuntimeError(\n                    \"Unknown argument format. Must be pandas.Series, numpy.ndarray or a string from one of the following values : [{}]\".format(\n                        \", \".join(possible_keys)\n                    )\n                )\n        else:\n            _values = self.index\n\n        nt = 0\n        for n in self.index:\n            nt += len(self[n])\n\n        times = np.zeros(nt)\n        data = np.zeros(nt)\n        k = 0\n        for n, v in zip(self.index, _values):\n            kl = len(self[n])\n            times[k : k + kl] = self[n].index\n            data[k : k + kl] = v\n            k += kl\n\n        idx = np.argsort(times)\n        toreturn = Tsd(t=times[idx], d=data[idx], time_support=self.time_support)\n\n        return toreturn\n\n    \"\"\"\n    Special slicing of metadata\n    \"\"\"\n\n    def getby_threshold(self, key, thr, op=\"&gt;\"):\n        \"\"\"\n        Return a TsGroup with all Ts/Tsd objects with values above threshold for metainfo under key.\n\n        Parameters\n        ----------\n        key : str\n            One of the metainfo columns name\n        thr : float\n            THe value for thresholding\n        op : str, optional\n            The type of operation. Possibilities are '&gt;', '&lt;', '&gt;=' or '&lt;='.\n\n        Returns\n        -------\n        TsGroup\n            The new TsGroup\n\n        Raises\n        ------\n        RuntimeError\n            Raise eror is operation is not recognized.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n        1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n        2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n        }\n        &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n          Index    Freq. (Hz)\n        -------  ------------\n              0             1\n              1             2\n              2             4\n\n        This exemple shows how to get a new TsGroup with all elements for which the metainfo frequency is above 1.\n        &gt;&gt;&gt; newtsgroup = tsgroup.getby_threshold('freq', 1, op = '&gt;')\n          Index    Freq. (Hz)\n        -------  ------------\n              1             2\n              2             4\n\n        \"\"\"\n        if op == \"&gt;\":\n            ix = list(self._metadata.index[self._metadata[key] &gt; thr])\n            return self[ix]\n        elif op == \"&lt;\":\n            ix = list(self._metadata.index[self._metadata[key] &lt; thr])\n            return self[ix]\n        elif op == \"&gt;=\":\n            ix = list(self._metadata.index[self._metadata[key] &gt;= thr])\n            return self[ix]\n        elif op == \"&lt;=\":\n            ix = list(self._metadata.index[self._metadata[key] &lt;= thr])\n            return self[ix]\n        else:\n            raise RuntimeError(\"Operation {} not recognized.\".format(op))\n\n    def getby_intervals(self, key, bins):\n        \"\"\"\n        Return a list of TsGroup binned.\n\n        Parameters\n        ----------\n        key : str\n            One of the metainfo columns name\n        bins : numpy.ndarray or list\n            The bin intervals\n\n        Returns\n        -------\n        list\n            A list of TsGroup\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n        1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n        2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n        }\n        &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp, alpha = np.arange(3))\n          Index    Freq. (Hz)    alpha\n        -------  ------------  -------\n              0             1        0\n              1             2        1\n              2             4        2\n\n        This exemple shows how to bin the TsGroup according to one metainfo key.\n        &gt;&gt;&gt; newtsgroup, bincenter = tsgroup.getby_intervals('alpha', [0, 1, 2])\n        &gt;&gt;&gt; newtsgroup\n        [  Index    Freq. (Hz)    alpha\n         -------  ------------  -------\n               0             1        0,\n           Index    Freq. (Hz)    alpha\n         -------  ------------  -------\n               1             2        1]\n\n        By default, the function returns the center of the bins.\n        &gt;&gt;&gt; bincenter\n        array([0.5, 1.5])\n        \"\"\"\n        idx = np.digitize(self._metadata[key], bins) - 1\n        groups = self._metadata.index.groupby(idx)\n        ix = np.unique(list(groups.keys()))\n        ix = ix[ix &gt;= 0]\n        ix = ix[ix &lt; len(bins) - 1]\n        xb = bins[0:-1] + np.diff(bins) / 2\n        sliced = [self[list(groups[i])] for i in ix]\n        return sliced, xb[ix]\n\n    def getby_category(self, key):\n        \"\"\"\n        Return a list of TsGroup grouped by category.\n\n        Parameters\n        ----------\n        key : str\n            One of the metainfo columns name\n\n        Returns\n        -------\n        dict\n            A dictionnary of TsGroup\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n        1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n        2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n        }\n        &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp, group = [0,1,1])\n          Index    Freq. (Hz)    group\n        -------  ------------  -------\n              0             1        0\n              1             2        1\n              2             4        1\n\n        This exemple shows how to group the TsGroup according to one metainfo key.\n        &gt;&gt;&gt; newtsgroup = tsgroup.getby_category('group')\n        &gt;&gt;&gt; newtsgroup\n        {0:   Index    Freq. (Hz)    group\n         -------  ------------  -------\n               0             1        0,\n         1:   Index    Freq. (Hz)    group\n         -------  ------------  -------\n               1             2        1\n               2             4        1}\n        \"\"\"\n        groups = self._metadata.groupby(key).groups\n        sliced = {k: self[list(groups[k])] for k in groups.keys()}\n        return sliced\n\n    def save(self, filename):\n        \"\"\"\n        Save TsGroup object in npz format. The file will contain the timestamps,\n        the data (if group of Tsd), group index, the time support and the metadata\n\n        The main purpose of this function is to save small/medium sized TsGroup\n        objects.\n\n        The function will \"flatten\" the TsGroup by sorting all the timestamps\n        and assigning to each the corresponding index. Typically, a TsGroup like\n        this :\n\n            TsGroup({\n                0 : Tsd(t=[0, 2, 4], d=[1, 2, 3])\n                1 : Tsd(t=[1, 5], d=[5, 6])\n            })\n\n        will be saved as npz with the following keys:\n\n            {\n                't' : [0, 1, 2, 4, 5],\n                'd' : [1, 5, 2, 3, 5],\n                'index' : [0, 1, 0, 0, 1],\n                'start' : [0],\n                'end' : [5],\n                'type' : 'TsGroup'\n            }\n\n        Metadata are saved by columns with the column name as the npz key. To avoid\n        potential conflicts, make sure the columns name of the metadata are different\n        from ['t', 'd', 'start', 'end', 'index']\n\n        You can load the object with numpy.load. Default keys are 't', 'd'(optional),\n        'start', 'end', 'index' and 'type'.\n        See the example below.\n\n        Parameters\n        ----------\n        filename : str\n            The filename\n\n        Examples\n        --------\n        &gt;&gt;&gt; import pynapple as nap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tsgroup = nap.TsGroup({\n            0 : nap.Ts(t=np.array([0.0, 2.0, 4.0])),\n            6 : nap.Ts(t=np.array([1.0, 5.0]))\n            },\n            group = np.array([0, 1]),\n            location = np.array(['right foot', 'left foot'])\n            )\n        &gt;&gt;&gt; tsgroup\n          Index    rate    group  location\n        -------  ------  -------  ----------\n              0     0.6        0  right foot\n              6     0.4        1  left foot\n        &gt;&gt;&gt; tsgroup.save(\"my_tsgroup.npz\")\n\n        Here I can retrieve my data with numpy directly:\n\n        &gt;&gt;&gt; file = np.load(\"my_tsgroup.npz\")\n        &gt;&gt;&gt; print(list(file.keys()))\n        ['rate', 'group', 'location', 't', 'index', 'start', 'end', 'type']\n        &gt;&gt;&gt; print(file['index'])\n        [0 6 0 0 6]\n\n        In the case where TsGroup is a set of Ts objects, it is very direct to\n        recreate the TsGroup by using the function to_tsgroup :\n\n        &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n        &gt;&gt;&gt; tsd = nap.Tsd(t=file['t'], d=file['index'], time_support = time_support)\n        &gt;&gt;&gt; tsgroup = tsd.to_tsgroup()\n        &gt;&gt;&gt; tsgroup.set_info(group = file['group'], location = file['location'])\n        &gt;&gt;&gt; tsgroup\n          Index    rate    group  location\n        -------  ------  -------  ----------\n              0     0.6        0  right foot\n              6     0.4        1  left foot\n\n        Raises\n        ------\n        RuntimeError\n            If filename is not str, path does not exist or filename is a directory.\n        \"\"\"\n        if not isinstance(filename, str):\n            raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n        if os.path.isdir(filename):\n            raise RuntimeError(\n                \"Invalid filename input. {} is directory.\".format(filename)\n            )\n\n        if not filename.lower().endswith(\".npz\"):\n            filename = filename + \".npz\"\n\n        dirname = os.path.dirname(filename)\n\n        if len(dirname) and not os.path.exists(dirname):\n            raise RuntimeError(\n                \"Path {} does not exist.\".format(os.path.dirname(filename))\n            )\n\n        dicttosave = {\"type\": np.array([\"TsGroup\"], dtype=np.str_)}\n        for k in self._metadata.columns:\n            if k not in [\"t\", \"d\", \"start\", \"end\", \"index\"]:\n                tmp = self._metadata[k].values\n                if tmp.dtype == np.dtype(\"O\"):\n                    tmp = tmp.astype(np.str_)\n                dicttosave[k] = tmp\n\n        # We can't use to_tsd here in case tsgroup contains Tsd and not only Ts.\n        nt = 0\n        for n in self.index:\n            nt += len(self[n])\n\n        times = np.zeros(nt)\n        data = np.zeros(nt)\n        index = np.zeros(nt, dtype=np.int64)\n        k = 0\n        for n in self.index:\n            kl = len(self[n])\n            times[k : k + kl] = self[n].index\n            data[k : k + kl] = self[n].values\n            index[k : k + kl] = int(n)\n            k += kl\n\n        idx = np.argsort(times)\n        times = times[idx]\n        index = index[idx]\n\n        dicttosave[\"t\"] = times\n        dicttosave[\"index\"] = index\n        if not np.all(np.isnan(data)):\n            dicttosave[\"d\"] = data[idx]\n\n        dicttosave[\"start\"] = self.time_support.start.values\n        dicttosave[\"end\"] = self.time_support.end.values\n\n        np.savez(filename, **dicttosave)\n\n        return\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.rates","title":"rates  <code>property</code>","text":"<pre><code>rates\n</code></pre> <p>Return the rates of each element of the group in Hz</p>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.metadata_columns","title":"metadata_columns  <code>property</code>","text":"<pre><code>metadata_columns\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.metadata_columns--returns-list-of-metadata-columns","title":"Returns list of metadata columns","text":""},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.__init__","title":"__init__","text":"<pre><code>__init__(\n    data,\n    time_support=None,\n    time_units=\"s\",\n    bypass_check=False,\n    **kwargs\n)\n</code></pre> <p>TsGroup Initializer</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionnary containing Ts/Tsd objects</p> required <code>time_support</code> <code>IntervalSet</code> <p>The time support of the TsGroup. Ts/Tsd objects will be restricted to the time support if passed. If no time support is specified, TsGroup will merge time supports from all the Ts/Tsd objects in data.</p> <code>None</code> <code>time_units</code> <code>str</code> <p>Time units if data does not contain Ts/Tsd objects ('us', 'ms', 's' [default]).</p> <code>'s'</code> <code>bypass_check</code> <p>To avoid checking that each element is within time_support. Useful to speed up initialization of TsGroup when Ts/Tsd objects have already been restricted beforehand</p> <code>False</code> <code>**kwargs</code> <p>Meta-info about the Ts/Tsd objects. Can be either pandas.Series or numpy.ndarray. Note that the index should match the index of the input dictionnary.</p> <code>{}</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Raise error if the union of time support of Ts/Tsd object is empty.</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def __init__(\n    self, data, time_support=None, time_units=\"s\", bypass_check=False, **kwargs\n):\n    \"\"\"\n    TsGroup Initializer\n\n    Parameters\n    ----------\n    data : dict\n        Dictionnary containing Ts/Tsd objects\n    time_support : IntervalSet, optional\n        The time support of the TsGroup. Ts/Tsd objects will be restricted to the time support if passed.\n        If no time support is specified, TsGroup will merge time supports from all the Ts/Tsd objects in data.\n    time_units : str, optional\n        Time units if data does not contain Ts/Tsd objects ('us', 'ms', 's' [default]).\n    bypass_check: bool, optional\n        To avoid checking that each element is within time_support.\n        Useful to speed up initialization of TsGroup when Ts/Tsd objects have already been restricted beforehand\n    **kwargs\n        Meta-info about the Ts/Tsd objects. Can be either pandas.Series or numpy.ndarray.\n        Note that the index should match the index of the input dictionnary.\n\n    Raises\n    ------\n    RuntimeError\n        Raise error if the union of time support of Ts/Tsd object is empty.\n    \"\"\"\n    self._initialized = False\n\n    self.index = np.sort(list(data.keys()))\n\n    self._metadata = pd.DataFrame(index=self.index, columns=[\"rate\"], dtype=\"float\")\n\n    # Transform elements to Ts/Tsd objects\n    for k in self.index:\n        if isinstance(data[k], (np.ndarray, list)):\n            warnings.warn(\n                \"Elements should not be passed as numpy array. Default time units is seconds when creating the Ts object.\",\n                stacklevel=2,\n            )\n            data[k] = Ts(\n                t=data[k], time_support=time_support, time_units=time_units\n            )\n\n    # If time_support is passed, all elements of data are restricted prior to init\n    if isinstance(time_support, IntervalSet):\n        self.time_support = time_support\n        if not bypass_check:\n            data = {k: data[k].restrict(self.time_support) for k in self.index}\n    else:\n        # Otherwise do the union of all time supports\n        time_support = union_intervals([data[k].time_support for k in self.index])\n        if len(time_support) == 0:\n            raise RuntimeError(\n                \"Union of time supports is empty. Consider passing a time support as argument.\"\n            )\n        self.time_support = time_support\n        if not bypass_check:\n            data = {k: data[k].restrict(self.time_support) for k in self.index}\n\n    UserDict.__init__(self, data)\n\n    # Making the TsGroup non mutable\n    self._initialized = True\n\n    # Trying to add argument as metainfo\n    self.set_info(**kwargs)\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return index/keys of TsGroup</p> <p>Returns:</p> Type Description <code>list</code> <p>List of keys</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def keys(self):\n    \"\"\"\n    Return index/keys of TsGroup\n\n    Returns\n    -------\n    list\n        List of keys\n    \"\"\"\n    return list(self.data.keys())\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return a list of key/object.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of tuples</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def items(self):\n    \"\"\"\n    Return a list of key/object.\n\n    Returns\n    -------\n    list\n        List of tuples\n    \"\"\"\n    return list(self.data.items())\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Return a list of all the Ts/Tsd objects in the TsGroup</p> <p>Returns:</p> Type Description <code>list</code> <p>List of Ts/Tsd objects</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def values(self):\n    \"\"\"\n    Return a list of all the Ts/Tsd objects in the TsGroup\n\n    Returns\n    -------\n    list\n        List of Ts/Tsd objects\n    \"\"\"\n    return list(self.data.values())\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.set_info","title":"set_info","text":"<pre><code>set_info(*args, **kwargs)\n</code></pre> <p>Add metadata informations about the TsGroup. Metadata are saved as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>pandas.Dataframe or list of pandas.DataFrame</p> <code>()</code> <code>**kwargs</code> <p>Can be either pandas.Series, numpy.ndarray, list or tuple</p> <code>{}</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Raise an error if     no column labels are found when passing simple arguments,     indexes are not equals for a pandas series,     not the same length when passing numpy array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n}\n&gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n</code></pre> <p>To add metadata with a pandas.DataFrame:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; structs = pd.DataFrame(index = [0,1,2], data=['pfc','pfc','ca1'], columns=['struct'])\n&gt;&gt;&gt; tsgroup.set_info(structs)\n&gt;&gt;&gt; tsgroup\n  Index    Freq. (Hz)  struct\n-------  ------------  --------\n      0             1  pfc\n      1             2  pfc\n      2             4  ca1\n</code></pre> <p>To add metadata with a pd.Series, numpy.ndarray, list or tuple:</p> <pre><code>&gt;&gt;&gt; hd = pd.Series(index = [0,1,2], data = [0,1,1])\n&gt;&gt;&gt; tsgroup.set_info(hd=hd)\n&gt;&gt;&gt; tsgroup\n  Index    Freq. (Hz)  struct      hd\n-------  ------------  --------  ----\n      0             1  pfc          0\n      1             2  pfc          1\n      2             4  ca1          1\n</code></pre> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def set_info(self, *args, **kwargs):\n    \"\"\"\n    Add metadata informations about the TsGroup.\n    Metadata are saved as a DataFrame.\n\n    Parameters\n    ----------\n    *args\n        pandas.Dataframe or list of pandas.DataFrame\n    **kwargs\n        Can be either pandas.Series, numpy.ndarray, list or tuple\n\n    Raises\n    ------\n    RuntimeError\n        Raise an error if\n            no column labels are found when passing simple arguments,\n            indexes are not equals for a pandas series,\n            not the same length when passing numpy array.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n    1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n    2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n    }\n    &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n\n    To add metadata with a pandas.DataFrame:\n\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; structs = pd.DataFrame(index = [0,1,2], data=['pfc','pfc','ca1'], columns=['struct'])\n    &gt;&gt;&gt; tsgroup.set_info(structs)\n    &gt;&gt;&gt; tsgroup\n      Index    Freq. (Hz)  struct\n    -------  ------------  --------\n          0             1  pfc\n          1             2  pfc\n          2             4  ca1\n\n    To add metadata with a pd.Series, numpy.ndarray, list or tuple:\n\n    &gt;&gt;&gt; hd = pd.Series(index = [0,1,2], data = [0,1,1])\n    &gt;&gt;&gt; tsgroup.set_info(hd=hd)\n    &gt;&gt;&gt; tsgroup\n      Index    Freq. (Hz)  struct      hd\n    -------  ------------  --------  ----\n          0             1  pfc          0\n          1             2  pfc          1\n          2             4  ca1          1\n\n    \"\"\"\n    if len(args):\n        for arg in args:\n            if isinstance(arg, pd.DataFrame):\n                if pd.Index.equals(self._metadata.index, arg.index):\n                    self._metadata = self._metadata.join(arg)\n                else:\n                    raise RuntimeError(\"Index are not equals\")\n            elif isinstance(arg, (pd.Series, np.ndarray)):\n                raise RuntimeError(\"Columns needs to be labelled for metadata\")\n    if len(kwargs):\n        for k, v in kwargs.items():\n            if isinstance(v, pd.Series):\n                if pd.Index.equals(self._metadata.index, v.index):\n                    self._metadata[k] = v\n                else:\n                    raise RuntimeError(\"Index are not equals\")\n            elif isinstance(v, (np.ndarray, list, tuple)):\n                if len(self._metadata) == len(v):\n                    self._metadata[k] = np.asarray(v)\n                else:\n                    raise RuntimeError(\"Array is not the same length.\")\n    return\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.get_info","title":"get_info","text":"<pre><code>get_info(key)\n</code></pre> <p>Returns the metainfo located in one column. The key for the column frequency is \"rate\".</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>One of the metainfo columns name</p> required <p>Returns:</p> Type Description <code>Series</code> <p>The metainfo</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def get_info(self, key):\n    \"\"\"\n    Returns the metainfo located in one column.\n    The key for the column frequency is \"rate\".\n\n    Parameters\n    ----------\n    key : str\n        One of the metainfo columns name\n\n    Returns\n    -------\n    pandas.Series\n        The metainfo\n    \"\"\"\n    if key in [\"freq\", \"frequency\"]:\n        key = \"rate\"\n    return self._metadata[key]\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.restrict","title":"restrict","text":"<pre><code>restrict(ep)\n</code></pre> <p>Restricts a TsGroup object to a set of time intervals delimited by an IntervalSet object</p> <p>Parameters:</p> Name Type Description Default <code>ep</code> <code>IntervalSet</code> <p>the IntervalSet object</p> required <p>Returns:</p> Type Description <code>TsGroup</code> <p>TsGroup object restricted to ep</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n}\n&gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n&gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n&gt;&gt;&gt; newtsgroup = tsgroup.restrict(ep)\n</code></pre> <p>All objects within the TsGroup automatically inherit the epochs defined by ep.</p> <pre><code>&gt;&gt;&gt; newtsgroup.time_support\n   start    end\n0    0.0  100.0\n&gt;&gt;&gt; newtsgroup[0].time_support\n   start    end\n0    0.0  100.0\n</code></pre> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def restrict(self, ep):\n    \"\"\"\n    Restricts a TsGroup object to a set of time intervals delimited by an IntervalSet object\n\n    Parameters\n    ----------\n    ep : IntervalSet\n        the IntervalSet object\n\n    Returns\n    -------\n    TsGroup\n        TsGroup object restricted to ep\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n    1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n    2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n    }\n    &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n    &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n    &gt;&gt;&gt; newtsgroup = tsgroup.restrict(ep)\n\n    All objects within the TsGroup automatically inherit the epochs defined by ep.\n\n    &gt;&gt;&gt; newtsgroup.time_support\n       start    end\n    0    0.0  100.0\n    &gt;&gt;&gt; newtsgroup[0].time_support\n       start    end\n    0    0.0  100.0\n    \"\"\"\n    newgr = {}\n    for k in self.index:\n        newgr[k] = self.data[k].restrict(ep)\n    cols = self._metadata.columns.drop(\"rate\")\n\n    return TsGroup(\n        newgr, time_support=ep, bypass_check=True, **self._metadata[cols]\n    )\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.value_from","title":"value_from","text":"<pre><code>value_from(tsd, ep=None)\n</code></pre> <p>Replace the value of each Ts/Tsd object within the Ts group with the closest value from tsd argument</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>Tsd</code> <p>The Tsd object holding the values to replace</p> required <code>ep</code> <code>IntervalSet</code> <p>The IntervalSet object to restrict the operation. If None, the time support of the tsd input object is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>TsGroup</code> <p>TsGroup object with the new values</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n}\n&gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n&gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n</code></pre> <p>The variable tsd is a time series object containing the values to assign, for example the tracking data:</p> <pre><code>&gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,100), d=np.random.rand(100), time_units='s')\n&gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 100, time_units = 's')\n&gt;&gt;&gt; newtsgroup = tsgroup.value_from(tsd, ep)\n</code></pre> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def value_from(self, tsd, ep=None):\n    \"\"\"\n    Replace the value of each Ts/Tsd object within the Ts group with the closest value from tsd argument\n\n    Parameters\n    ----------\n    tsd : Tsd\n        The Tsd object holding the values to replace\n    ep : IntervalSet\n        The IntervalSet object to restrict the operation.\n        If None, the time support of the tsd input object is used.\n\n    Returns\n    -------\n    TsGroup\n        TsGroup object with the new values\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n    1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n    2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n    }\n    &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n    &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n\n    The variable tsd is a time series object containing the values to assign, for example the tracking data:\n\n    &gt;&gt;&gt; tsd = nap.Tsd(t=np.arange(0,100), d=np.random.rand(100), time_units='s')\n    &gt;&gt;&gt; ep = nap.IntervalSet(start = 0, end = 100, time_units = 's')\n    &gt;&gt;&gt; newtsgroup = tsgroup.value_from(tsd, ep)\n\n    \"\"\"\n    if ep is None:\n        ep = tsd.time_support\n\n    newgr = {}\n    for k in self.data:\n        newgr[k] = self.data[k].value_from(tsd, ep)\n\n    cols = self._metadata.columns.drop(\"rate\")\n    return TsGroup(newgr, time_support=ep, **self._metadata[cols])\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.count","title":"count","text":"<pre><code>count(*args, **kwargs)\n</code></pre> <p>Count occurences of events within bin_size or within a set of bins defined as an IntervalSet. You can call this function in multiple ways :</p> <ol> <li> <p>tsgroup.count(bin_size=1, time_units = 'ms') -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.</p> </li> <li> <p>tsgroup.count(1, ep=my_epochs) -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.</p> </li> <li> <p>tsgroup.count(ep=my_bins) -&gt; Count occurent of events within each epoch of the intervalSet object my_bins</p> </li> <li> <p>tsgroup.count() -&gt; Count occurent of events within each epoch of the time support.</p> </li> </ol> <p>bin_size should be seconds unless specified. If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>None or float</code> <p>The bin size (default is second)</p> required <code>ep</code> <code>None or IntervalSet</code> <p>IntervalSet to restrict the operation</p> required <code>time_units</code> <code>str</code> <p>Time units of bin size ('us', 'ms', 's' [default])</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>TsdFrame</code> <p>A TsdFrame with the columns being the index of each item in the TsGroup.</p> <p>Examples:</p> <p>This example shows how to count events within bins of 0.1 second for the first 100 seconds.</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n}\n&gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n&gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n&gt;&gt;&gt; bincount = tsgroup.count(0.1, ep)\n&gt;&gt;&gt; bincount\n          0  1  2\nTime (s)\n0.05      0  0  0\n0.15      0  0  0\n0.25      0  0  1\n0.35      0  0  0\n0.45      0  0  0\n...      .. .. ..\n99.55     0  1  1\n99.65     0  0  0\n99.75     0  0  1\n99.85     0  0  0\n99.95     1  1  1\n[1000 rows x 3 columns]\n</code></pre> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def count(self, *args, **kwargs):\n    \"\"\"\n    Count occurences of events within bin_size or within a set of bins defined as an IntervalSet.\n    You can call this function in multiple ways :\n\n    1. *tsgroup.count(bin_size=1, time_units = 'ms')*\n    -&gt; Count occurence of events within a 1 ms bin defined on the time support of the object.\n\n    2. *tsgroup.count(1, ep=my_epochs)*\n    -&gt; Count occurent of events within a 1 second bin defined on the IntervalSet my_epochs.\n\n    3. *tsgroup.count(ep=my_bins)*\n    -&gt; Count occurent of events within each epoch of the intervalSet object my_bins\n\n    4. *tsgroup.count()*\n    -&gt; Count occurent of events within each epoch of the time support.\n\n    bin_size should be seconds unless specified.\n    If bin_size is used and no epochs is passed, the data will be binned based on the time support of the object.\n\n    Parameters\n    ----------\n    bin_size : None or float, optional\n        The bin size (default is second)\n    ep : None or IntervalSet, optional\n        IntervalSet to restrict the operation\n    time_units : str, optional\n        Time units of bin size ('us', 'ms', 's' [default])\n\n    Returns\n    -------\n    out: TsdFrame\n        A TsdFrame with the columns being the index of each item in the TsGroup.\n\n    Examples\n    --------\n    This example shows how to count events within bins of 0.1 second for the first 100 seconds.\n\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n    1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n    2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n    }\n    &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n    &gt;&gt;&gt; ep = nap.IntervalSet(start=0, end=100, time_units='s')\n    &gt;&gt;&gt; bincount = tsgroup.count(0.1, ep)\n    &gt;&gt;&gt; bincount\n              0  1  2\n    Time (s)\n    0.05      0  0  0\n    0.15      0  0  0\n    0.25      0  0  1\n    0.35      0  0  0\n    0.45      0  0  0\n    ...      .. .. ..\n    99.55     0  1  1\n    99.65     0  0  0\n    99.75     0  0  1\n    99.85     0  0  0\n    99.95     1  1  1\n    [1000 rows x 3 columns]\n\n    \"\"\"\n    bin_size = None\n    if \"bin_size\" in kwargs:\n        bin_size = kwargs[\"bin_size\"]\n        if isinstance(bin_size, int):\n            bin_size = float(bin_size)\n        if not isinstance(bin_size, float):\n            raise ValueError(\"bin_size argument should be float.\")\n    else:\n        for a in args:\n            if isinstance(a, (float, int)):\n                bin_size = float(a)\n\n    time_units = \"s\"\n    if \"time_units\" in kwargs:\n        time_units = kwargs[\"time_units\"]\n        if not isinstance(time_units, str):\n            raise ValueError(\"time_units argument should be 's', 'ms' or 'us'.\")\n    else:\n        for a in args:\n            if isinstance(a, str) and a in [\"s\", \"ms\", \"us\"]:\n                time_units = a\n\n    ep = self.time_support\n    if \"ep\" in kwargs:\n        ep = kwargs[\"ep\"]\n        if not isinstance(ep, IntervalSet):\n            raise ValueError(\"ep argument should be IntervalSet\")\n    else:\n        for a in args:\n            if isinstance(a, IntervalSet):\n                ep = a\n\n    starts = ep.start.values\n    ends = ep.end.values\n\n    if isinstance(bin_size, (float, int)):\n        bin_size = float(bin_size)\n        bin_size = TsIndex.format_timestamps(np.array([bin_size]), time_units)[0]\n        time_index, _ = jitcount(np.array([]), starts, ends, bin_size)\n        n = len(self.index)\n        count = np.zeros((time_index.shape[0], n), dtype=np.int64)\n\n        for i in range(n):\n            count[:, i] = jitcount(\n                self.data[self.index[i]].index, starts, ends, bin_size\n            )[1]\n\n    else:\n        time_index = starts + (ends - starts) / 2\n        n = len(self.index)\n        count = np.zeros((time_index.shape[0], n), dtype=np.int64)\n\n        for i in range(n):\n            count[:, i] = jittsrestrict_with_count(\n                self.data[self.index[i]].index, starts, ends\n            )[1]\n\n    toreturn = TsdFrame(t=time_index, d=count, time_support=ep, columns=self.index)\n    return toreturn\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.to_tsd","title":"to_tsd","text":"<pre><code>to_tsd(*args)\n</code></pre> <p>Convert TsGroup to a Tsd. The timestamps of the TsGroup are merged together and sorted.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>string, list, numpy.ndarray or pandas.Series</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsgroup = nap.TsGroup({0:nap.Ts(t=np.array([0, 1])), 5:nap.Ts(t=np.array([2, 3]))})\nIndex    rate\n-------  ------\n0       1\n5       1\n</code></pre> <p>By default, the values of the Tsd is the index of the timestamp in the TsGroup:</p> <pre><code>&gt;&gt;&gt; tsgroup.to_tsd()\nTime (s)\n0.0    0.0\n1.0    0.0\n2.0    5.0\n3.0    5.0\ndtype: float64\n</code></pre> <p>Values can be inherited from the metadata of the TsGroup by giving the key of the corresponding columns.</p> <pre><code>&gt;&gt;&gt; tsgroup.set_info( phase=np.array([np.pi, 2*np.pi]) ) # assigning a phase to my 2 elements of the TsGroup\n&gt;&gt;&gt; tsgroup.to_tsd(\"phase\")\nTime (s)\n0.0    3.141593\n1.0    3.141593\n2.0    6.283185\n3.0    6.283185\ndtype: float64\n</code></pre> <p>Values can also be passed directly to the function from a list, numpy.ndarray or pandas.Series of values as long as the length matches :</p> <pre><code>&gt;&gt;&gt; tsgroup.to_tsd([-1, 1])\nTime (s)\n0.0   -1.0\n1.0   -1.0\n2.0    1.0\n3.0    1.0\ndtype: float64\n</code></pre> <p>The reverse operation can be done with the Tsd.to_tsgroup function :</p> <pre><code>&gt;&gt;&gt; my_tsd\nTime (s)\n0.0    0.0\n1.0    0.0\n2.0    5.0\n3.0    5.0\ndtype: float64\n&gt;&gt;&gt; my_tsd.to_tsgroup()\n  Index    rate\n-------  ------\n      0       1\n      5       1\n</code></pre> <p>Returns:</p> Type Description <code>Tsd</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>\"Index are not equals\" : if pandas.Series indexes don't match the TsGroup indexes \"Values is not the same length\" : if numpy.ndarray/list object is not the same size as the TsGroup object \"Key not in metadata of TsGroup\" : if string argument does not match any column names of the metadata, \"Unknown argument format\" ; if argument is not a string, list, numpy.ndarray or pandas.Series</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def to_tsd(self, *args):\n    \"\"\"\n    Convert TsGroup to a Tsd. The timestamps of the TsGroup are merged together and sorted.\n\n    Parameters\n    ----------\n    *args\n        string, list, numpy.ndarray or pandas.Series\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsgroup = nap.TsGroup({0:nap.Ts(t=np.array([0, 1])), 5:nap.Ts(t=np.array([2, 3]))})\n    Index    rate\n    -------  ------\n    0       1\n    5       1\n\n    By default, the values of the Tsd is the index of the timestamp in the TsGroup:\n\n    &gt;&gt;&gt; tsgroup.to_tsd()\n    Time (s)\n    0.0    0.0\n    1.0    0.0\n    2.0    5.0\n    3.0    5.0\n    dtype: float64\n\n    Values can be inherited from the metadata of the TsGroup by giving the key of the corresponding columns.\n\n    &gt;&gt;&gt; tsgroup.set_info( phase=np.array([np.pi, 2*np.pi]) ) # assigning a phase to my 2 elements of the TsGroup\n    &gt;&gt;&gt; tsgroup.to_tsd(\"phase\")\n    Time (s)\n    0.0    3.141593\n    1.0    3.141593\n    2.0    6.283185\n    3.0    6.283185\n    dtype: float64\n\n    Values can also be passed directly to the function from a list, numpy.ndarray or pandas.Series of values as long as the length matches :\n\n    &gt;&gt;&gt; tsgroup.to_tsd([-1, 1])\n    Time (s)\n    0.0   -1.0\n    1.0   -1.0\n    2.0    1.0\n    3.0    1.0\n    dtype: float64\n\n    The reverse operation can be done with the Tsd.to_tsgroup function :\n\n    &gt;&gt;&gt; my_tsd\n    Time (s)\n    0.0    0.0\n    1.0    0.0\n    2.0    5.0\n    3.0    5.0\n    dtype: float64\n    &gt;&gt;&gt; my_tsd.to_tsgroup()\n      Index    rate\n    -------  ------\n          0       1\n          5       1\n\n    Returns\n    -------\n    Tsd\n\n    Raises\n    ------\n    RuntimeError\n        \"Index are not equals\" : if pandas.Series indexes don't match the TsGroup indexes\n        \"Values is not the same length\" : if numpy.ndarray/list object is not the same size as the TsGroup object\n        \"Key not in metadata of TsGroup\" : if string argument does not match any column names of the metadata,\n        \"Unknown argument format\" ; if argument is not a string, list, numpy.ndarray or pandas.Series\n\n    \"\"\"\n    if len(args):\n        if isinstance(args[0], pd.Series):\n            if pd.Index.equals(self._metadata.index, args[0].index):\n                _values = args[0].values.flatten()\n            else:\n                raise RuntimeError(\"Index are not equals\")\n        elif isinstance(args[0], (np.ndarray, list)):\n            if len(self._metadata) == len(args[0]):\n                _values = np.array(args[0])\n            else:\n                raise RuntimeError(\"Values is not the same length.\")\n        elif isinstance(args[0], str):\n            if args[0] in self._metadata.columns:\n                _values = self._metadata[args[0]].values\n            else:\n                raise RuntimeError(\n                    \"Key {} not in metadata of TsGroup\".format(args[0])\n                )\n        else:\n            possible_keys = []\n            for k, d in self._metadata.dtypes.items():\n                if \"int\" in str(d) or \"float\" in str(d):\n                    possible_keys.append(k)\n            raise RuntimeError(\n                \"Unknown argument format. Must be pandas.Series, numpy.ndarray or a string from one of the following values : [{}]\".format(\n                    \", \".join(possible_keys)\n                )\n            )\n    else:\n        _values = self.index\n\n    nt = 0\n    for n in self.index:\n        nt += len(self[n])\n\n    times = np.zeros(nt)\n    data = np.zeros(nt)\n    k = 0\n    for n, v in zip(self.index, _values):\n        kl = len(self[n])\n        times[k : k + kl] = self[n].index\n        data[k : k + kl] = v\n        k += kl\n\n    idx = np.argsort(times)\n    toreturn = Tsd(t=times[idx], d=data[idx], time_support=self.time_support)\n\n    return toreturn\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.getby_threshold","title":"getby_threshold","text":"<pre><code>getby_threshold(key, thr, op='&gt;')\n</code></pre> <p>Return a TsGroup with all Ts/Tsd objects with values above threshold for metainfo under key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>One of the metainfo columns name</p> required <code>thr</code> <code>float</code> <p>THe value for thresholding</p> required <code>op</code> <code>str</code> <p>The type of operation. Possibilities are '&gt;', '&lt;', '&gt;=' or '&lt;='.</p> <code>'&gt;'</code> <p>Returns:</p> Type Description <code>TsGroup</code> <p>The new TsGroup</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Raise eror is operation is not recognized.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n}\n&gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n  Index    Freq. (Hz)\n-------  ------------\n      0             1\n      1             2\n      2             4\n</code></pre> <p>This exemple shows how to get a new TsGroup with all elements for which the metainfo frequency is above 1.</p> <pre><code>&gt;&gt;&gt; newtsgroup = tsgroup.getby_threshold('freq', 1, op = '&gt;')\n  Index    Freq. (Hz)\n-------  ------------\n      1             2\n      2             4\n</code></pre> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def getby_threshold(self, key, thr, op=\"&gt;\"):\n    \"\"\"\n    Return a TsGroup with all Ts/Tsd objects with values above threshold for metainfo under key.\n\n    Parameters\n    ----------\n    key : str\n        One of the metainfo columns name\n    thr : float\n        THe value for thresholding\n    op : str, optional\n        The type of operation. Possibilities are '&gt;', '&lt;', '&gt;=' or '&lt;='.\n\n    Returns\n    -------\n    TsGroup\n        The new TsGroup\n\n    Raises\n    ------\n    RuntimeError\n        Raise eror is operation is not recognized.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n    1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n    2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n    }\n    &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp)\n      Index    Freq. (Hz)\n    -------  ------------\n          0             1\n          1             2\n          2             4\n\n    This exemple shows how to get a new TsGroup with all elements for which the metainfo frequency is above 1.\n    &gt;&gt;&gt; newtsgroup = tsgroup.getby_threshold('freq', 1, op = '&gt;')\n      Index    Freq. (Hz)\n    -------  ------------\n          1             2\n          2             4\n\n    \"\"\"\n    if op == \"&gt;\":\n        ix = list(self._metadata.index[self._metadata[key] &gt; thr])\n        return self[ix]\n    elif op == \"&lt;\":\n        ix = list(self._metadata.index[self._metadata[key] &lt; thr])\n        return self[ix]\n    elif op == \"&gt;=\":\n        ix = list(self._metadata.index[self._metadata[key] &gt;= thr])\n        return self[ix]\n    elif op == \"&lt;=\":\n        ix = list(self._metadata.index[self._metadata[key] &lt;= thr])\n        return self[ix]\n    else:\n        raise RuntimeError(\"Operation {} not recognized.\".format(op))\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.getby_intervals","title":"getby_intervals","text":"<pre><code>getby_intervals(key, bins)\n</code></pre> <p>Return a list of TsGroup binned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>One of the metainfo columns name</p> required <code>bins</code> <code>ndarray or list</code> <p>The bin intervals</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of TsGroup</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n}\n&gt;&gt;&gt; tsgroup = nap.TsGroup(tmp, alpha = np.arange(3))\n  Index    Freq. (Hz)    alpha\n-------  ------------  -------\n      0             1        0\n      1             2        1\n      2             4        2\n</code></pre> <p>This exemple shows how to bin the TsGroup according to one metainfo key.</p> <pre><code>&gt;&gt;&gt; newtsgroup, bincenter = tsgroup.getby_intervals('alpha', [0, 1, 2])\n&gt;&gt;&gt; newtsgroup\n[  Index    Freq. (Hz)    alpha\n -------  ------------  -------\n       0             1        0,\n   Index    Freq. (Hz)    alpha\n -------  ------------  -------\n       1             2        1]\n</code></pre> <p>By default, the function returns the center of the bins.</p> <pre><code>&gt;&gt;&gt; bincenter\narray([0.5, 1.5])\n</code></pre> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def getby_intervals(self, key, bins):\n    \"\"\"\n    Return a list of TsGroup binned.\n\n    Parameters\n    ----------\n    key : str\n        One of the metainfo columns name\n    bins : numpy.ndarray or list\n        The bin intervals\n\n    Returns\n    -------\n    list\n        A list of TsGroup\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n    1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n    2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n    }\n    &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp, alpha = np.arange(3))\n      Index    Freq. (Hz)    alpha\n    -------  ------------  -------\n          0             1        0\n          1             2        1\n          2             4        2\n\n    This exemple shows how to bin the TsGroup according to one metainfo key.\n    &gt;&gt;&gt; newtsgroup, bincenter = tsgroup.getby_intervals('alpha', [0, 1, 2])\n    &gt;&gt;&gt; newtsgroup\n    [  Index    Freq. (Hz)    alpha\n     -------  ------------  -------\n           0             1        0,\n       Index    Freq. (Hz)    alpha\n     -------  ------------  -------\n           1             2        1]\n\n    By default, the function returns the center of the bins.\n    &gt;&gt;&gt; bincenter\n    array([0.5, 1.5])\n    \"\"\"\n    idx = np.digitize(self._metadata[key], bins) - 1\n    groups = self._metadata.index.groupby(idx)\n    ix = np.unique(list(groups.keys()))\n    ix = ix[ix &gt;= 0]\n    ix = ix[ix &lt; len(bins) - 1]\n    xb = bins[0:-1] + np.diff(bins) / 2\n    sliced = [self[list(groups[i])] for i in ix]\n    return sliced, xb[ix]\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.getby_category","title":"getby_category","text":"<pre><code>getby_category(key)\n</code></pre> <p>Return a list of TsGroup grouped by category.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>One of the metainfo columns name</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionnary of TsGroup</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n}\n&gt;&gt;&gt; tsgroup = nap.TsGroup(tmp, group = [0,1,1])\n  Index    Freq. (Hz)    group\n-------  ------------  -------\n      0             1        0\n      1             2        1\n      2             4        1\n</code></pre> <p>This exemple shows how to group the TsGroup according to one metainfo key.</p> <pre><code>&gt;&gt;&gt; newtsgroup = tsgroup.getby_category('group')\n&gt;&gt;&gt; newtsgroup\n{0:   Index    Freq. (Hz)    group\n -------  ------------  -------\n       0             1        0,\n 1:   Index    Freq. (Hz)    group\n -------  ------------  -------\n       1             2        1\n       2             4        1}\n</code></pre> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def getby_category(self, key):\n    \"\"\"\n    Return a list of TsGroup grouped by category.\n\n    Parameters\n    ----------\n    key : str\n        One of the metainfo columns name\n\n    Returns\n    -------\n    dict\n        A dictionnary of TsGroup\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tmp = { 0:nap.Ts(t=np.arange(0,200), time_units='s'),\n    1:nap.Ts(t=np.arange(0,200,0.5), time_units='s'),\n    2:nap.Ts(t=np.arange(0,300,0.25), time_units='s'),\n    }\n    &gt;&gt;&gt; tsgroup = nap.TsGroup(tmp, group = [0,1,1])\n      Index    Freq. (Hz)    group\n    -------  ------------  -------\n          0             1        0\n          1             2        1\n          2             4        1\n\n    This exemple shows how to group the TsGroup according to one metainfo key.\n    &gt;&gt;&gt; newtsgroup = tsgroup.getby_category('group')\n    &gt;&gt;&gt; newtsgroup\n    {0:   Index    Freq. (Hz)    group\n     -------  ------------  -------\n           0             1        0,\n     1:   Index    Freq. (Hz)    group\n     -------  ------------  -------\n           1             2        1\n           2             4        1}\n    \"\"\"\n    groups = self._metadata.groupby(key).groups\n    sliced = {k: self[list(groups[k])] for k in groups.keys()}\n    return sliced\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.TsGroup.save","title":"save","text":"<pre><code>save(filename)\n</code></pre> <p>Save TsGroup object in npz format. The file will contain the timestamps, the data (if group of Tsd), group index, the time support and the metadata</p> <p>The main purpose of this function is to save small/medium sized TsGroup objects.</p> <p>The function will \"flatten\" the TsGroup by sorting all the timestamps and assigning to each the corresponding index. Typically, a TsGroup like this :</p> <pre><code>TsGroup({\n    0 : Tsd(t=[0, 2, 4], d=[1, 2, 3])\n    1 : Tsd(t=[1, 5], d=[5, 6])\n})\n</code></pre> <p>will be saved as npz with the following keys:</p> <pre><code>{\n    't' : [0, 1, 2, 4, 5],\n    'd' : [1, 5, 2, 3, 5],\n    'index' : [0, 1, 0, 0, 1],\n    'start' : [0],\n    'end' : [5],\n    'type' : 'TsGroup'\n}\n</code></pre> <p>Metadata are saved by columns with the column name as the npz key. To avoid potential conflicts, make sure the columns name of the metadata are different from ['t', 'd', 'start', 'end', 'index']</p> <p>You can load the object with numpy.load. Default keys are 't', 'd'(optional), 'start', 'end', 'index' and 'type'. See the example below.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tsgroup = nap.TsGroup({\n    0 : nap.Ts(t=np.array([0.0, 2.0, 4.0])),\n    6 : nap.Ts(t=np.array([1.0, 5.0]))\n    },\n    group = np.array([0, 1]),\n    location = np.array(['right foot', 'left foot'])\n    )\n&gt;&gt;&gt; tsgroup\n  Index    rate    group  location\n-------  ------  -------  ----------\n      0     0.6        0  right foot\n      6     0.4        1  left foot\n&gt;&gt;&gt; tsgroup.save(\"my_tsgroup.npz\")\n</code></pre> <p>Here I can retrieve my data with numpy directly:</p> <pre><code>&gt;&gt;&gt; file = np.load(\"my_tsgroup.npz\")\n&gt;&gt;&gt; print(list(file.keys()))\n['rate', 'group', 'location', 't', 'index', 'start', 'end', 'type']\n&gt;&gt;&gt; print(file['index'])\n[0 6 0 0 6]\n</code></pre> <p>In the case where TsGroup is a set of Ts objects, it is very direct to recreate the TsGroup by using the function to_tsgroup :</p> <pre><code>&gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n&gt;&gt;&gt; tsd = nap.Tsd(t=file['t'], d=file['index'], time_support = time_support)\n&gt;&gt;&gt; tsgroup = tsd.to_tsgroup()\n&gt;&gt;&gt; tsgroup.set_info(group = file['group'], location = file['location'])\n&gt;&gt;&gt; tsgroup\n  Index    rate    group  location\n-------  ------  -------  ----------\n      0     0.6        0  right foot\n      6     0.4        1  left foot\n</code></pre> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If filename is not str, path does not exist or filename is a directory.</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def save(self, filename):\n    \"\"\"\n    Save TsGroup object in npz format. The file will contain the timestamps,\n    the data (if group of Tsd), group index, the time support and the metadata\n\n    The main purpose of this function is to save small/medium sized TsGroup\n    objects.\n\n    The function will \"flatten\" the TsGroup by sorting all the timestamps\n    and assigning to each the corresponding index. Typically, a TsGroup like\n    this :\n\n        TsGroup({\n            0 : Tsd(t=[0, 2, 4], d=[1, 2, 3])\n            1 : Tsd(t=[1, 5], d=[5, 6])\n        })\n\n    will be saved as npz with the following keys:\n\n        {\n            't' : [0, 1, 2, 4, 5],\n            'd' : [1, 5, 2, 3, 5],\n            'index' : [0, 1, 0, 0, 1],\n            'start' : [0],\n            'end' : [5],\n            'type' : 'TsGroup'\n        }\n\n    Metadata are saved by columns with the column name as the npz key. To avoid\n    potential conflicts, make sure the columns name of the metadata are different\n    from ['t', 'd', 'start', 'end', 'index']\n\n    You can load the object with numpy.load. Default keys are 't', 'd'(optional),\n    'start', 'end', 'index' and 'type'.\n    See the example below.\n\n    Parameters\n    ----------\n    filename : str\n        The filename\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; tsgroup = nap.TsGroup({\n        0 : nap.Ts(t=np.array([0.0, 2.0, 4.0])),\n        6 : nap.Ts(t=np.array([1.0, 5.0]))\n        },\n        group = np.array([0, 1]),\n        location = np.array(['right foot', 'left foot'])\n        )\n    &gt;&gt;&gt; tsgroup\n      Index    rate    group  location\n    -------  ------  -------  ----------\n          0     0.6        0  right foot\n          6     0.4        1  left foot\n    &gt;&gt;&gt; tsgroup.save(\"my_tsgroup.npz\")\n\n    Here I can retrieve my data with numpy directly:\n\n    &gt;&gt;&gt; file = np.load(\"my_tsgroup.npz\")\n    &gt;&gt;&gt; print(list(file.keys()))\n    ['rate', 'group', 'location', 't', 'index', 'start', 'end', 'type']\n    &gt;&gt;&gt; print(file['index'])\n    [0 6 0 0 6]\n\n    In the case where TsGroup is a set of Ts objects, it is very direct to\n    recreate the TsGroup by using the function to_tsgroup :\n\n    &gt;&gt;&gt; time_support = nap.IntervalSet(file['start'], file['end'])\n    &gt;&gt;&gt; tsd = nap.Tsd(t=file['t'], d=file['index'], time_support = time_support)\n    &gt;&gt;&gt; tsgroup = tsd.to_tsgroup()\n    &gt;&gt;&gt; tsgroup.set_info(group = file['group'], location = file['location'])\n    &gt;&gt;&gt; tsgroup\n      Index    rate    group  location\n    -------  ------  -------  ----------\n          0     0.6        0  right foot\n          6     0.4        1  left foot\n\n    Raises\n    ------\n    RuntimeError\n        If filename is not str, path does not exist or filename is a directory.\n    \"\"\"\n    if not isinstance(filename, str):\n        raise RuntimeError(\"Invalid type; please provide filename as string\")\n\n    if os.path.isdir(filename):\n        raise RuntimeError(\n            \"Invalid filename input. {} is directory.\".format(filename)\n        )\n\n    if not filename.lower().endswith(\".npz\"):\n        filename = filename + \".npz\"\n\n    dirname = os.path.dirname(filename)\n\n    if len(dirname) and not os.path.exists(dirname):\n        raise RuntimeError(\n            \"Path {} does not exist.\".format(os.path.dirname(filename))\n        )\n\n    dicttosave = {\"type\": np.array([\"TsGroup\"], dtype=np.str_)}\n    for k in self._metadata.columns:\n        if k not in [\"t\", \"d\", \"start\", \"end\", \"index\"]:\n            tmp = self._metadata[k].values\n            if tmp.dtype == np.dtype(\"O\"):\n                tmp = tmp.astype(np.str_)\n            dicttosave[k] = tmp\n\n    # We can't use to_tsd here in case tsgroup contains Tsd and not only Ts.\n    nt = 0\n    for n in self.index:\n        nt += len(self[n])\n\n    times = np.zeros(nt)\n    data = np.zeros(nt)\n    index = np.zeros(nt, dtype=np.int64)\n    k = 0\n    for n in self.index:\n        kl = len(self[n])\n        times[k : k + kl] = self[n].index\n        data[k : k + kl] = self[n].values\n        index[k : k + kl] = int(n)\n        k += kl\n\n    idx = np.argsort(times)\n    times = times[idx]\n    index = index[idx]\n\n    dicttosave[\"t\"] = times\n    dicttosave[\"index\"] = index\n    if not np.all(np.isnan(data)):\n        dicttosave[\"d\"] = data[idx]\n\n    dicttosave[\"start\"] = self.time_support.start.values\n    dicttosave[\"end\"] = self.time_support.end.values\n\n    np.savez(filename, **dicttosave)\n\n    return\n</code></pre>"},{"location":"reference/core/ts_group/#pynapple.core.ts_group.union_intervals","title":"union_intervals","text":"<pre><code>union_intervals(i_sets)\n</code></pre> <p>Helper to merge intervals from ts_group</p> Source code in <code>pynapple/core/ts_group.py</code> <pre><code>def union_intervals(i_sets):\n    \"\"\"\n    Helper to merge intervals from ts_group\n    \"\"\"\n    n = len(i_sets)\n\n    if n == 1:\n        return i_sets[0]\n\n    new_start = np.zeros(0)\n    new_end = np.zeros(0)\n\n    if n == 2:\n        new_start, new_end = jitunion(\n            i_sets[0].start.values,\n            i_sets[0].end.values,\n            i_sets[1].start.values,\n            i_sets[1].end.values,\n        )\n\n    if n &gt; 2:\n        sizes = np.array([i_sets[i].shape[0] for i in range(n)])\n        startends = np.zeros((np.sum(sizes), 2))\n        ct = 0\n        for i in range(sizes.shape[0]):\n            startends[ct : ct + sizes[i], :] = i_sets[i].values\n            ct += sizes[i]\n        new_start, new_end = jitunion_isets(startends[:, 0], startends[:, 1])\n\n    return IntervalSet(new_start, new_end)\n</code></pre>"},{"location":"reference/io/","title":"Io","text":"<ul> <li>interface_nwb</li> <li>interface_npz</li> <li>folder</li> <li>misc</li> <li>cnmfe (deprecated)</li> <li>neurosuite (deprecated)</li> <li>suite2p (deprecated)</li> <li>phy (deprecated)</li> <li>loader (deprecated)</li> </ul>"},{"location":"reference/io/cnmfe/","title":"Cnmfe","text":""},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe","title":"pynapple.io.cnmfe","text":"<p> DEPRECATED: This will be removed in version 1.0.0. Check nwbmatic or neuroconv instead.</p> <p>Loaders for calcium imaging data with miniscope. Support CNMF-E in matlab, inscopix-cnmfe and minian.</p>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.CNMF_E","title":"CNMF_E","text":"<p>             Bases: <code>BaseLoader</code></p> <p>Loader for data processed with matlab CNMF-E(https://github.com/zhoupc/CNMF_E). The path folder should contain a file ending in .mat when calling Source2d.save_neurons</p> <p>Attributes:</p> Name Type Description <code>A</code> <code>ndarray</code> <p>Spatial footprints</p> <code>C</code> <code>TsdFrame</code> <p>The calcium transients</p> <code>sampling_rate</code> <code>float</code> <p>Sampling rate of the data (default is 30 Hz).</p> Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>class CNMF_E(BaseLoader):\n    \"\"\"Loader for data processed with matlab CNMF-E(https://github.com/zhoupc/CNMF_E).\n    The path folder should contain a file ending in .mat\n    when calling Source2d.save_neurons\n\n    Attributes\n    ----------\n    A : numpy.ndarray\n        Spatial footprints\n    C : TsdFrame\n        The calcium transients\n    sampling_rate : float\n        Sampling rate of the data (default is 30 Hz).\n\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n\n        Parameters\n        ----------\n        path : str\n            The path to the data.\n        \"\"\"\n        self.basename = os.path.basename(path)\n\n        super().__init__(path)\n\n        self.load_cnmfe_nwb(path)\n\n    def load_cnmfe_nwb(self, path):\n        \"\"\"\n        Load the calcium transient and spatial footprint from nwb\n\n        Parameters\n        ----------\n        path : str\n            Path to the session\n        \"\"\"\n        self.nwb_path = os.path.join(path, \"pynapplenwb\")\n        if not os.path.exists(self.nwb_path):\n            raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n\n        self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n        self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n        io = NWBHDF5IO(self.nwbfilepath, \"r\")\n        nwbfile = io.read()\n\n        if \"ophys\" in nwbfile.processing.keys():\n            data = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n                \"RoiResponseSeries\"\n            ].data[:]\n            t = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n                \"RoiResponseSeries\"\n            ].timestamps[:]\n            self.C = nap.TsdFrame(t=t, d=data)\n            self.A = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n                \"PlaneSegmentation\"\n            ][\"image_mask\"].data[:]\n\n            io.close()\n            return True\n        else:\n            io.close()\n            return False\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.CNMF_E.load_data","title":"load_data","text":"<pre><code>load_data(path)\n</code></pre> <p>Load NWB data saved with pynapple in the pynapplenwb folder</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session folder</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_data(self, path):\n    \"\"\"\n    Load NWB data saved with pynapple in the pynapplenwb folder\n\n    Parameters\n    ----------\n    path : str\n        Path to the session folder\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    position = {}\n    acq_keys = nwbfile.acquisition.keys()\n    if \"CompassDirection\" in acq_keys:\n        compass = nwbfile.acquisition[\"CompassDirection\"]\n        for k in compass.spatial_series.keys():\n            position[k] = pd.Series(\n                index=compass.get_spatial_series(k).timestamps[:],\n                data=compass.get_spatial_series(k).data[:],\n            )\n    if \"Position\" in acq_keys:\n        tracking = nwbfile.acquisition[\"Position\"]\n        for k in tracking.spatial_series.keys():\n            position[k] = pd.Series(\n                index=tracking.get_spatial_series(k).timestamps[:],\n                data=tracking.get_spatial_series(k).data[:],\n            )\n    if len(position):\n        position = pd.DataFrame.from_dict(position)\n\n        # retrieveing time support position if in epochs\n        if \"position_time_support\" in nwbfile.intervals.keys():\n            epochs = nwbfile.intervals[\"position_time_support\"].to_dataframe()\n            time_support = nap.IntervalSet(\n                start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n            )\n\n        self.position = nap.TsdFrame(\n            position, time_units=\"s\", time_support=time_support\n        )\n\n    if nwbfile.epochs is not None:\n        epochs = nwbfile.epochs.to_dataframe()\n        # NWB is dumb and cannot take a single string for labels\n        epochs[\"label\"] = [epochs.loc[i, \"tags\"][0] for i in epochs.index]\n        epochs = epochs.drop(labels=\"tags\", axis=1)\n        epochs = epochs.rename(columns={\"start_time\": \"start\", \"stop_time\": \"end\"})\n        self.epochs = self._make_epochs(epochs)\n\n        self.time_support = self._join_epochs(epochs, \"s\")\n\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.CNMF_E.save_nwb_intervals","title":"save_nwb_intervals","text":"<pre><code>save_nwb_intervals(iset, name, description='')\n</code></pre> <p>Add epochs to the NWB file (e.g. ripples epochs) See pynwb.epoch.TimeIntervals</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>The intervalSet to save</p> required <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_intervals(self, iset, name, description=\"\"):\n    \"\"\"\n    Add epochs to the NWB file (e.g. ripples epochs)\n    See pynwb.epoch.TimeIntervals\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        The intervalSet to save\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    epochs = iset.as_units(\"s\")\n    time_intervals = TimeIntervals(name=name, description=description)\n    for i in epochs.index:\n        time_intervals.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n\n    nwbfile.add_time_intervals(time_intervals)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.CNMF_E.save_nwb_timeseries","title":"save_nwb_timeseries","text":"<pre><code>save_nwb_timeseries(tsd, name, description='')\n</code></pre> <p>Save timestamps in the NWB file (e.g. ripples time) with the time support. See pynwb.base.TimeSeries</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>TsdFrame</code> <p>_</p> required <code>name</code> <code>str</code> <p>_</p> required <code>description</code> <code>str</code> <p>_</p> <code>''</code> Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_timeseries(self, tsd, name, description=\"\"):\n    \"\"\"\n    Save timestamps in the NWB file (e.g. ripples time) with the time support.\n    See pynwb.base.TimeSeries\n\n\n    Parameters\n    ----------\n    tsd : TsdFrame\n        _\n    name : str\n        _\n    description : str, optional\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    ts = TimeSeries(\n        name=name,\n        unit=\"s\",\n        data=tsd.values,\n        timestamps=tsd.as_units(\"s\").index.values,\n    )\n\n    time_support = TimeIntervals(\n        name=name + \"_timesupport\", description=\"The time support of the object\"\n    )\n\n    epochs = tsd.time_support.as_units(\"s\")\n    for i in epochs.index:\n        time_support.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n    nwbfile.add_time_intervals(time_support)\n    nwbfile.add_acquisition(ts)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.CNMF_E.load_nwb_intervals","title":"load_nwb_intervals","text":"<pre><code>load_nwb_intervals(name)\n</code></pre> <p>Load epochs from the NWB file (e.g. 'ripples')</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_intervals(self, name):\n    \"\"\"\n    Load epochs from the NWB file (e.g. 'ripples')\n\n    Parameters\n    ----------\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if name in nwbfile.intervals.keys():\n        epochs = nwbfile.intervals[name].to_dataframe()\n        isets = nap.IntervalSet(\n            start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n        )\n        io.close()\n        return isets\n    else:\n        io.close()\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.CNMF_E.load_nwb_timeseries","title":"load_nwb_timeseries","text":"<pre><code>load_nwb_timeseries(name)\n</code></pre> <p>Load timestamps in the NWB file (e.g. ripples time)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>_</p> required <p>Returns:</p> Type Description <code>Tsd</code> <p>_</p> Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_timeseries(self, name):\n    \"\"\"\n    Load timestamps in the NWB file (e.g. ripples time)\n\n    Parameters\n    ----------\n    name : str\n        _\n\n    Returns\n    -------\n    Tsd\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    ts = nwbfile.acquisition[name]\n\n    time_support = self.load_nwb_intervals(name + \"_timesupport\")\n\n    tsd = nap.Tsd(\n        t=ts.timestamps[:], d=ts.data[:], time_units=\"s\", time_support=time_support\n    )\n\n    io.close()\n\n    return tsd\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.CNMF_E.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the data.</p> required Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>def __init__(self, path):\n    \"\"\"\n\n    Parameters\n    ----------\n    path : str\n        The path to the data.\n    \"\"\"\n    self.basename = os.path.basename(path)\n\n    super().__init__(path)\n\n    self.load_cnmfe_nwb(path)\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.CNMF_E.load_cnmfe_nwb","title":"load_cnmfe_nwb","text":"<pre><code>load_cnmfe_nwb(path)\n</code></pre> <p>Load the calcium transient and spatial footprint from nwb</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session</p> required Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>def load_cnmfe_nwb(self, path):\n    \"\"\"\n    Load the calcium transient and spatial footprint from nwb\n\n    Parameters\n    ----------\n    path : str\n        Path to the session\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if \"ophys\" in nwbfile.processing.keys():\n        data = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n            \"RoiResponseSeries\"\n        ].data[:]\n        t = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n            \"RoiResponseSeries\"\n        ].timestamps[:]\n        self.C = nap.TsdFrame(t=t, d=data)\n        self.A = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n            \"PlaneSegmentation\"\n        ][\"image_mask\"].data[:]\n\n        io.close()\n        return True\n    else:\n        io.close()\n        return False\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.Minian","title":"Minian","text":"<p>             Bases: <code>BaseLoader</code></p> <p>Loader for data processed with Minian (https://github.com/denisecailab/minian). The path folder should contain a subfolder name minian.</p> <p>Attributes:</p> Name Type Description <code>A</code> <code>ndarray</code> <p>Spatial footprints</p> <code>C</code> <code>TsdFrame</code> <p>The calcium transients</p> <code>sampling_rate</code> <code>float</code> <p>Sampling rate of the data (default is 30 Hz).</p> Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>class Minian(BaseLoader):\n    \"\"\"Loader for data processed with Minian (https://github.com/denisecailab/minian).\n    The path folder should contain a subfolder name minian.\n\n    Attributes\n    ----------\n    A : numpy.ndarray\n        Spatial footprints\n    C : TsdFrame\n        The calcium transients\n    sampling_rate : float\n        Sampling rate of the data (default is 30 Hz).\n\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n\n        Parameters\n        ----------\n        path : str\n            The path to the data.\n        \"\"\"\n        self.basename = os.path.basename(path)\n\n        super().__init__(path)\n\n        self.load_cnmfe_nwb(path)\n\n    def load_cnmfe_nwb(self, path):\n        \"\"\"\n        Load the calcium transient and spatial footprint from nwb\n\n        Parameters\n        ----------\n        path : str\n            Path to the session\n        \"\"\"\n        self.nwb_path = os.path.join(path, \"pynapplenwb\")\n        if not os.path.exists(self.nwb_path):\n            raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n\n        self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n        self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n        io = NWBHDF5IO(self.nwbfilepath, \"r\")\n        nwbfile = io.read()\n\n        if \"ophys\" in nwbfile.processing.keys():\n            data = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n                \"RoiResponseSeries\"\n            ].data[:]\n            t = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n                \"RoiResponseSeries\"\n            ].timestamps[:]\n            self.C = nap.TsdFrame(t=t, d=data)\n            self.A = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n                \"PlaneSegmentation\"\n            ][\"image_mask\"].data[:]\n\n            io.close()\n            return True\n        else:\n            io.close()\n            return False\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.Minian.load_data","title":"load_data","text":"<pre><code>load_data(path)\n</code></pre> <p>Load NWB data saved with pynapple in the pynapplenwb folder</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session folder</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_data(self, path):\n    \"\"\"\n    Load NWB data saved with pynapple in the pynapplenwb folder\n\n    Parameters\n    ----------\n    path : str\n        Path to the session folder\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    position = {}\n    acq_keys = nwbfile.acquisition.keys()\n    if \"CompassDirection\" in acq_keys:\n        compass = nwbfile.acquisition[\"CompassDirection\"]\n        for k in compass.spatial_series.keys():\n            position[k] = pd.Series(\n                index=compass.get_spatial_series(k).timestamps[:],\n                data=compass.get_spatial_series(k).data[:],\n            )\n    if \"Position\" in acq_keys:\n        tracking = nwbfile.acquisition[\"Position\"]\n        for k in tracking.spatial_series.keys():\n            position[k] = pd.Series(\n                index=tracking.get_spatial_series(k).timestamps[:],\n                data=tracking.get_spatial_series(k).data[:],\n            )\n    if len(position):\n        position = pd.DataFrame.from_dict(position)\n\n        # retrieveing time support position if in epochs\n        if \"position_time_support\" in nwbfile.intervals.keys():\n            epochs = nwbfile.intervals[\"position_time_support\"].to_dataframe()\n            time_support = nap.IntervalSet(\n                start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n            )\n\n        self.position = nap.TsdFrame(\n            position, time_units=\"s\", time_support=time_support\n        )\n\n    if nwbfile.epochs is not None:\n        epochs = nwbfile.epochs.to_dataframe()\n        # NWB is dumb and cannot take a single string for labels\n        epochs[\"label\"] = [epochs.loc[i, \"tags\"][0] for i in epochs.index]\n        epochs = epochs.drop(labels=\"tags\", axis=1)\n        epochs = epochs.rename(columns={\"start_time\": \"start\", \"stop_time\": \"end\"})\n        self.epochs = self._make_epochs(epochs)\n\n        self.time_support = self._join_epochs(epochs, \"s\")\n\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.Minian.save_nwb_intervals","title":"save_nwb_intervals","text":"<pre><code>save_nwb_intervals(iset, name, description='')\n</code></pre> <p>Add epochs to the NWB file (e.g. ripples epochs) See pynwb.epoch.TimeIntervals</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>The intervalSet to save</p> required <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_intervals(self, iset, name, description=\"\"):\n    \"\"\"\n    Add epochs to the NWB file (e.g. ripples epochs)\n    See pynwb.epoch.TimeIntervals\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        The intervalSet to save\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    epochs = iset.as_units(\"s\")\n    time_intervals = TimeIntervals(name=name, description=description)\n    for i in epochs.index:\n        time_intervals.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n\n    nwbfile.add_time_intervals(time_intervals)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.Minian.save_nwb_timeseries","title":"save_nwb_timeseries","text":"<pre><code>save_nwb_timeseries(tsd, name, description='')\n</code></pre> <p>Save timestamps in the NWB file (e.g. ripples time) with the time support. See pynwb.base.TimeSeries</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>TsdFrame</code> <p>_</p> required <code>name</code> <code>str</code> <p>_</p> required <code>description</code> <code>str</code> <p>_</p> <code>''</code> Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_timeseries(self, tsd, name, description=\"\"):\n    \"\"\"\n    Save timestamps in the NWB file (e.g. ripples time) with the time support.\n    See pynwb.base.TimeSeries\n\n\n    Parameters\n    ----------\n    tsd : TsdFrame\n        _\n    name : str\n        _\n    description : str, optional\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    ts = TimeSeries(\n        name=name,\n        unit=\"s\",\n        data=tsd.values,\n        timestamps=tsd.as_units(\"s\").index.values,\n    )\n\n    time_support = TimeIntervals(\n        name=name + \"_timesupport\", description=\"The time support of the object\"\n    )\n\n    epochs = tsd.time_support.as_units(\"s\")\n    for i in epochs.index:\n        time_support.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n    nwbfile.add_time_intervals(time_support)\n    nwbfile.add_acquisition(ts)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.Minian.load_nwb_intervals","title":"load_nwb_intervals","text":"<pre><code>load_nwb_intervals(name)\n</code></pre> <p>Load epochs from the NWB file (e.g. 'ripples')</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_intervals(self, name):\n    \"\"\"\n    Load epochs from the NWB file (e.g. 'ripples')\n\n    Parameters\n    ----------\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if name in nwbfile.intervals.keys():\n        epochs = nwbfile.intervals[name].to_dataframe()\n        isets = nap.IntervalSet(\n            start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n        )\n        io.close()\n        return isets\n    else:\n        io.close()\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.Minian.load_nwb_timeseries","title":"load_nwb_timeseries","text":"<pre><code>load_nwb_timeseries(name)\n</code></pre> <p>Load timestamps in the NWB file (e.g. ripples time)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>_</p> required <p>Returns:</p> Type Description <code>Tsd</code> <p>_</p> Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_timeseries(self, name):\n    \"\"\"\n    Load timestamps in the NWB file (e.g. ripples time)\n\n    Parameters\n    ----------\n    name : str\n        _\n\n    Returns\n    -------\n    Tsd\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    ts = nwbfile.acquisition[name]\n\n    time_support = self.load_nwb_intervals(name + \"_timesupport\")\n\n    tsd = nap.Tsd(\n        t=ts.timestamps[:], d=ts.data[:], time_units=\"s\", time_support=time_support\n    )\n\n    io.close()\n\n    return tsd\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.Minian.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the data.</p> required Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>def __init__(self, path):\n    \"\"\"\n\n    Parameters\n    ----------\n    path : str\n        The path to the data.\n    \"\"\"\n    self.basename = os.path.basename(path)\n\n    super().__init__(path)\n\n    self.load_cnmfe_nwb(path)\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.Minian.load_cnmfe_nwb","title":"load_cnmfe_nwb","text":"<pre><code>load_cnmfe_nwb(path)\n</code></pre> <p>Load the calcium transient and spatial footprint from nwb</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session</p> required Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>def load_cnmfe_nwb(self, path):\n    \"\"\"\n    Load the calcium transient and spatial footprint from nwb\n\n    Parameters\n    ----------\n    path : str\n        Path to the session\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if \"ophys\" in nwbfile.processing.keys():\n        data = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n            \"RoiResponseSeries\"\n        ].data[:]\n        t = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n            \"RoiResponseSeries\"\n        ].timestamps[:]\n        self.C = nap.TsdFrame(t=t, d=data)\n        self.A = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n            \"PlaneSegmentation\"\n        ][\"image_mask\"].data[:]\n\n        io.close()\n        return True\n    else:\n        io.close()\n        return False\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.InscopixCNMFE","title":"InscopixCNMFE","text":"<p>             Bases: <code>BaseLoader</code></p> <p>Loader for Inscopix-cnmfe (https://github.com/inscopix/inscopix-cnmfe). The folder should contain a file ending with '_traces.csv' and a tiff file for spatial footprints.</p> <p>Attributes:</p> Name Type Description <code>A</code> <code>ndarray</code> <p>The spatial footprints</p> <code>C</code> <code>TsdFrame</code> <p>The calcium transients</p> <code>sampling_rate</code> <code>float</code> <p>Sampling rate of the data (default is 30 Hz).</p> Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>class InscopixCNMFE(BaseLoader):\n    \"\"\"Loader for Inscopix-cnmfe (https://github.com/inscopix/inscopix-cnmfe).\n    The folder should contain a file ending with '_traces.csv'\n    and a tiff file for spatial footprints.\n\n    Attributes\n    ----------\n    A : np.ndarray\n        The spatial footprints\n    C : TsdFrame\n        The calcium transients\n    sampling_rate : float\n        Sampling rate of the data (default is 30 Hz).\n\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n\n        Parameters\n        ----------\n        path : str\n            The path to the data.\n        \"\"\"\n        self.basename = os.path.basename(path)\n\n        super().__init__(path)\n\n        self.load_cnmfe_nwb(path)\n\n    def load_cnmfe_nwb(self, path):\n        \"\"\"\n        Load the calcium transient and spatial footprint from nwb\n\n        Parameters\n        ----------\n        path : str\n            Path to the session\n        \"\"\"\n        self.nwb_path = os.path.join(path, \"pynapplenwb\")\n        if not os.path.exists(self.nwb_path):\n            raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n\n        self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n        self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n        io = NWBHDF5IO(self.nwbfilepath, \"r\")\n        nwbfile = io.read()\n\n        if \"ophys\" in nwbfile.processing.keys():\n            data = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n                \"RoiResponseSeries\"\n            ].data[:]\n            t = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n                \"RoiResponseSeries\"\n            ].timestamps[:]\n            self.C = nap.TsdFrame(t=t, d=data)\n            self.A = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n                \"PlaneSegmentation\"\n            ][\"image_mask\"].data[:]\n\n            io.close()\n            return True\n        else:\n            io.close()\n            return False\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.InscopixCNMFE.load_data","title":"load_data","text":"<pre><code>load_data(path)\n</code></pre> <p>Load NWB data saved with pynapple in the pynapplenwb folder</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session folder</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_data(self, path):\n    \"\"\"\n    Load NWB data saved with pynapple in the pynapplenwb folder\n\n    Parameters\n    ----------\n    path : str\n        Path to the session folder\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    position = {}\n    acq_keys = nwbfile.acquisition.keys()\n    if \"CompassDirection\" in acq_keys:\n        compass = nwbfile.acquisition[\"CompassDirection\"]\n        for k in compass.spatial_series.keys():\n            position[k] = pd.Series(\n                index=compass.get_spatial_series(k).timestamps[:],\n                data=compass.get_spatial_series(k).data[:],\n            )\n    if \"Position\" in acq_keys:\n        tracking = nwbfile.acquisition[\"Position\"]\n        for k in tracking.spatial_series.keys():\n            position[k] = pd.Series(\n                index=tracking.get_spatial_series(k).timestamps[:],\n                data=tracking.get_spatial_series(k).data[:],\n            )\n    if len(position):\n        position = pd.DataFrame.from_dict(position)\n\n        # retrieveing time support position if in epochs\n        if \"position_time_support\" in nwbfile.intervals.keys():\n            epochs = nwbfile.intervals[\"position_time_support\"].to_dataframe()\n            time_support = nap.IntervalSet(\n                start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n            )\n\n        self.position = nap.TsdFrame(\n            position, time_units=\"s\", time_support=time_support\n        )\n\n    if nwbfile.epochs is not None:\n        epochs = nwbfile.epochs.to_dataframe()\n        # NWB is dumb and cannot take a single string for labels\n        epochs[\"label\"] = [epochs.loc[i, \"tags\"][0] for i in epochs.index]\n        epochs = epochs.drop(labels=\"tags\", axis=1)\n        epochs = epochs.rename(columns={\"start_time\": \"start\", \"stop_time\": \"end\"})\n        self.epochs = self._make_epochs(epochs)\n\n        self.time_support = self._join_epochs(epochs, \"s\")\n\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.InscopixCNMFE.save_nwb_intervals","title":"save_nwb_intervals","text":"<pre><code>save_nwb_intervals(iset, name, description='')\n</code></pre> <p>Add epochs to the NWB file (e.g. ripples epochs) See pynwb.epoch.TimeIntervals</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>The intervalSet to save</p> required <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_intervals(self, iset, name, description=\"\"):\n    \"\"\"\n    Add epochs to the NWB file (e.g. ripples epochs)\n    See pynwb.epoch.TimeIntervals\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        The intervalSet to save\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    epochs = iset.as_units(\"s\")\n    time_intervals = TimeIntervals(name=name, description=description)\n    for i in epochs.index:\n        time_intervals.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n\n    nwbfile.add_time_intervals(time_intervals)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.InscopixCNMFE.save_nwb_timeseries","title":"save_nwb_timeseries","text":"<pre><code>save_nwb_timeseries(tsd, name, description='')\n</code></pre> <p>Save timestamps in the NWB file (e.g. ripples time) with the time support. See pynwb.base.TimeSeries</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>TsdFrame</code> <p>_</p> required <code>name</code> <code>str</code> <p>_</p> required <code>description</code> <code>str</code> <p>_</p> <code>''</code> Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_timeseries(self, tsd, name, description=\"\"):\n    \"\"\"\n    Save timestamps in the NWB file (e.g. ripples time) with the time support.\n    See pynwb.base.TimeSeries\n\n\n    Parameters\n    ----------\n    tsd : TsdFrame\n        _\n    name : str\n        _\n    description : str, optional\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    ts = TimeSeries(\n        name=name,\n        unit=\"s\",\n        data=tsd.values,\n        timestamps=tsd.as_units(\"s\").index.values,\n    )\n\n    time_support = TimeIntervals(\n        name=name + \"_timesupport\", description=\"The time support of the object\"\n    )\n\n    epochs = tsd.time_support.as_units(\"s\")\n    for i in epochs.index:\n        time_support.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n    nwbfile.add_time_intervals(time_support)\n    nwbfile.add_acquisition(ts)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.InscopixCNMFE.load_nwb_intervals","title":"load_nwb_intervals","text":"<pre><code>load_nwb_intervals(name)\n</code></pre> <p>Load epochs from the NWB file (e.g. 'ripples')</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_intervals(self, name):\n    \"\"\"\n    Load epochs from the NWB file (e.g. 'ripples')\n\n    Parameters\n    ----------\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if name in nwbfile.intervals.keys():\n        epochs = nwbfile.intervals[name].to_dataframe()\n        isets = nap.IntervalSet(\n            start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n        )\n        io.close()\n        return isets\n    else:\n        io.close()\n    return\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.InscopixCNMFE.load_nwb_timeseries","title":"load_nwb_timeseries","text":"<pre><code>load_nwb_timeseries(name)\n</code></pre> <p>Load timestamps in the NWB file (e.g. ripples time)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>_</p> required <p>Returns:</p> Type Description <code>Tsd</code> <p>_</p> Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_timeseries(self, name):\n    \"\"\"\n    Load timestamps in the NWB file (e.g. ripples time)\n\n    Parameters\n    ----------\n    name : str\n        _\n\n    Returns\n    -------\n    Tsd\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    ts = nwbfile.acquisition[name]\n\n    time_support = self.load_nwb_intervals(name + \"_timesupport\")\n\n    tsd = nap.Tsd(\n        t=ts.timestamps[:], d=ts.data[:], time_units=\"s\", time_support=time_support\n    )\n\n    io.close()\n\n    return tsd\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.InscopixCNMFE.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the data.</p> required Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>def __init__(self, path):\n    \"\"\"\n\n    Parameters\n    ----------\n    path : str\n        The path to the data.\n    \"\"\"\n    self.basename = os.path.basename(path)\n\n    super().__init__(path)\n\n    self.load_cnmfe_nwb(path)\n</code></pre>"},{"location":"reference/io/cnmfe/#pynapple.io.cnmfe.InscopixCNMFE.load_cnmfe_nwb","title":"load_cnmfe_nwb","text":"<pre><code>load_cnmfe_nwb(path)\n</code></pre> <p>Load the calcium transient and spatial footprint from nwb</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session</p> required Source code in <code>pynapple/io/cnmfe.py</code> <pre><code>def load_cnmfe_nwb(self, path):\n    \"\"\"\n    Load the calcium transient and spatial footprint from nwb\n\n    Parameters\n    ----------\n    path : str\n        Path to the session\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if \"ophys\" in nwbfile.processing.keys():\n        data = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n            \"RoiResponseSeries\"\n        ].data[:]\n        t = nwbfile.processing[\"ophys\"][\"Fluorescence\"][\n            \"RoiResponseSeries\"\n        ].timestamps[:]\n        self.C = nap.TsdFrame(t=t, d=data)\n        self.A = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n            \"PlaneSegmentation\"\n        ][\"image_mask\"].data[:]\n\n        io.close()\n        return True\n    else:\n        io.close()\n        return False\n</code></pre>"},{"location":"reference/io/folder/","title":"Folder","text":""},{"location":"reference/io/folder/#pynapple.io.folder","title":"pynapple.io.folder","text":"<p>The Folder class helps to navigate a hierarchical data tree.</p>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder","title":"Folder","text":"<p>             Bases: <code>UserDict</code></p> <p>Base class for all type of folders (i.e. Project, Subject, Sessions, ...). Handles files and sub-folders discovery</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict</code> <p>Dictionnary holidng all the pynapple objects found in the folder.</p> <code>name</code> <code>str</code> <p>Name of the folder</p> <code>npz_files</code> <code>list</code> <p>List of npz files found in the folder</p> <code>nwb_files</code> <code>list</code> <p>List of nwb files found in the folder</p> <code>path</code> <code>str</code> <p>Absolute path of the folder</p> <code>subfolds</code> <code>dict</code> <p>Dictionnary of all the subfolders</p> Source code in <code>pynapple/io/folder.py</code> <pre><code>class Folder(UserDict):\n    \"\"\"\n    Base class for all type of folders (i.e. Project, Subject, Sessions, ...).\n    Handles files and sub-folders discovery\n\n    Attributes\n    ----------\n    data : dict\n        Dictionnary holidng all the pynapple objects found in the folder.\n    name : str\n        Name of the folder\n    npz_files : list\n        List of npz files found in the folder\n    nwb_files : list\n        List of nwb files found in the folder\n    path : str\n        Absolute path of the folder\n    subfolds : dict\n        Dictionnary of all the subfolders\n\n    \"\"\"\n\n    def __init__(self, path):  # , exclude=(), max_depth=4):\n        \"\"\"Initialize the Folder object\n\n        Parameters\n        ----------\n        path : str\n            Path to the folder\n        \"\"\"\n        path = path.rstrip(\"/\")\n        self.path = path\n        self.name = os.path.basename(path)\n        self._basic_view = Tree(\n            \":open_file_folder: {}\".format(self.name), guide_style=\"blue\"\n        )\n        self._full_view = None\n\n        # Search sub-folders\n        subfolds = [\n            f.path\n            for f in os.scandir(path)\n            if f.is_dir() and not f.name.startswith(\".\")\n        ]\n        subfolds.sort()\n\n        self.subfolds = {}\n\n        for s in subfolds:\n            sub = os.path.basename(s)\n            self.subfolds[sub] = Folder(s)\n            self._basic_view.add(\":open_file_folder: [blue]\" + sub)\n\n        # Search files\n        self.npz_files = _find_files(path, \"npz\")\n        self.nwb_files = _find_files(path, \"nwb\")\n\n        for filename, file in self.npz_files.items():\n            self._basic_view.add(\"[green]\" + file.name + \" \\t|\\t \" + file.type)\n\n        for file in self.nwb_files.values():\n            self._basic_view.add(\"[magenta]\" + file.name + \" \\t|\\t NWB file\")\n\n        # Putting everything together\n        self.data = {**self.npz_files, **self.nwb_files, **self.subfolds}\n\n        UserDict.__init__(self, self.data)\n\n    def __str__(self):\n        \"\"\"View of the object\"\"\"\n        with Console() as console:\n            console.print(self._basic_view)\n        return \"\"\n\n    # def __repr__(self):\n    #     \"\"\"View of the object\"\"\"\n    #     print(self._basic_view)\n\n    def __getitem__(self, key):\n        \"\"\"Get subfolder or load file.\n\n        Parameters\n        ----------\n        key : str\n\n        Returns\n        -------\n        (Ts, Tsd, TsdFrame, TsGroup, IntervalSet, Folder or NWBFile)\n\n        Raises\n        ------\n        KeyError\n            If key is not in the dictionnary\n        \"\"\"\n        if key.__hash__:\n            if self.__contains__(key):\n                if isinstance(self.data[key], NPZFile):\n                    data = self.data[key].load()\n                    self.data[key] = data\n                    # setattr(self, key, data)\n                    return data\n                elif isinstance(self.data[key], NWBFile):\n                    return self.data[key]\n                else:\n                    return self.data[key]\n            else:\n                raise KeyError(\"Can't find key {} in group index.\".format(key))\n\n    # # # Gets called when an attribute is accessed\n    # def __getattribute__(self, item):\n    #     value = super(Folder, self).__getattribute__(item)\n\n    #     if isinstance(value, NPZFile):\n    #         data = value.load()\n    #         setattr(self, item, data)\n    #         self.data[item] = data\n    #         return data\n    #     else:\n    #         return value\n\n    def _generate_tree_view(self):\n        tree = Tree(\":open_file_folder: {}\".format(self.name), guide_style=\"blue\")\n\n        # Folder\n        for fold in self.subfolds.keys():\n            tree.add(\":open_file_folder: \" + fold)\n            _walk_folder(tree.children[-1], self.subfolds[fold])\n\n        # NPZ files\n        for file in self.npz_files.values():\n            tree.add(\"[green]\" + file.name + \" \\t|\\t \" + file.type)\n\n        # NWB files\n        for file in self.nwb_files.values():\n            tree.add(\"[magenta]\" + file.name + \" \\t|\\t NWB file\")\n\n        self._full_view = tree\n\n    def expand(self):\n        \"\"\"Display the full tree view. Equivalent to Folder.view\"\"\"\n        if not isinstance(self._full_view, Tree):\n            self._generate_tree_view()\n\n        with Console() as console:\n            console.print(self._full_view)\n\n        return None\n\n    @property\n    def view(self):\n        \"\"\"Summary\"\"\"\n        return self.expand()\n\n    def save(self, name, obj, description=\"\"):\n        \"\"\"Save a pynapple object in the folder in a single file in uncompressed ``.npz`` format.\n        By default, the save function overwrite previously save file with the same name.\n\n        Parameters\n        ----------\n        name : str\n            Filename\n        obj : Ts, Tsd, TsdFrame, TsGroup or IntervalSet\n            Pynapple object.\n        description : str, optional\n            Metainformation added as a json sidecar.\n        \"\"\"\n        filepath = os.path.join(self.path, name)\n        obj.save(filepath)\n        self.npz_files[name] = NPZFile(filepath + \".npz\")\n        self.data[name] = obj\n\n        metadata = {\"time\": str(datetime.now()), \"info\": str(description)}\n\n        with open(os.path.join(self.path, name + \".json\"), \"w\") as ff:\n            json.dump(metadata, ff, indent=2)\n\n        # regenerate the tree view\n        self._generate_tree_view()\n\n    def load(self):\n        \"\"\"Load all compatible NPZ files.\"\"\"\n        for k in self.npz_files.keys():\n            self[k] = self.npz_files[k].load()\n\n    # def add_metadata(self):\n    #     \"\"\"Summary\"\"\"\n    #     pass\n\n    def info(self, name):\n        \"\"\"Display the metadata within the json sidecar of a NPZ file\n\n        Parameters\n        ----------\n        name : str\n            Name of the npz file\n        \"\"\"\n        self.metadata(name)\n\n    def doc(self, name):\n        \"\"\"Display the metadata within the json sidecar of a NPZ file\n\n        Parameters\n        ----------\n        name : str\n            Name of the npz file\n        \"\"\"\n        self.metadata(name)\n\n    def metadata(self, name):\n        \"\"\"Display the metadata within the json sidecar of a NPZ file\n\n        Parameters\n        ----------\n        name : str\n            Name of the npz file\n        \"\"\"\n        # Search for json first\n        json_filename = os.path.join(self.path, name + \".json\")\n        if os.path.isfile(json_filename):\n            with open(json_filename, \"r\") as ff:\n                metadata = json.load(ff)\n                text = \"\\n\".join([\" : \".join(it) for it in metadata.items()])\n            panel = Panel.fit(\n                text, border_style=\"green\", title=os.path.join(self.path, name + \".npz\")\n            )\n        else:\n            panel = Panel.fit(\n                \"No metadata\",\n                border_style=\"red\",\n                title=os.path.join(self.path, name + \".npz\"),\n            )\n        with Console() as console:\n            console.print(panel)\n\n        return None\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.view","title":"view  <code>property</code>","text":"<pre><code>view\n</code></pre> <p>Summary</p>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Initialize the Folder object</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the folder</p> required Source code in <code>pynapple/io/folder.py</code> <pre><code>def __init__(self, path):  # , exclude=(), max_depth=4):\n    \"\"\"Initialize the Folder object\n\n    Parameters\n    ----------\n    path : str\n        Path to the folder\n    \"\"\"\n    path = path.rstrip(\"/\")\n    self.path = path\n    self.name = os.path.basename(path)\n    self._basic_view = Tree(\n        \":open_file_folder: {}\".format(self.name), guide_style=\"blue\"\n    )\n    self._full_view = None\n\n    # Search sub-folders\n    subfolds = [\n        f.path\n        for f in os.scandir(path)\n        if f.is_dir() and not f.name.startswith(\".\")\n    ]\n    subfolds.sort()\n\n    self.subfolds = {}\n\n    for s in subfolds:\n        sub = os.path.basename(s)\n        self.subfolds[sub] = Folder(s)\n        self._basic_view.add(\":open_file_folder: [blue]\" + sub)\n\n    # Search files\n    self.npz_files = _find_files(path, \"npz\")\n    self.nwb_files = _find_files(path, \"nwb\")\n\n    for filename, file in self.npz_files.items():\n        self._basic_view.add(\"[green]\" + file.name + \" \\t|\\t \" + file.type)\n\n    for file in self.nwb_files.values():\n        self._basic_view.add(\"[magenta]\" + file.name + \" \\t|\\t NWB file\")\n\n    # Putting everything together\n    self.data = {**self.npz_files, **self.nwb_files, **self.subfolds}\n\n    UserDict.__init__(self, self.data)\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>View of the object</p> Source code in <code>pynapple/io/folder.py</code> <pre><code>def __str__(self):\n    \"\"\"View of the object\"\"\"\n    with Console() as console:\n        console.print(self._basic_view)\n    return \"\"\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Get subfolder or load file.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> required <p>Returns:</p> Type Description <code>(Ts, Tsd, TsdFrame, TsGroup, IntervalSet, Folder or NWBFile)</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If key is not in the dictionnary</p> Source code in <code>pynapple/io/folder.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Get subfolder or load file.\n\n    Parameters\n    ----------\n    key : str\n\n    Returns\n    -------\n    (Ts, Tsd, TsdFrame, TsGroup, IntervalSet, Folder or NWBFile)\n\n    Raises\n    ------\n    KeyError\n        If key is not in the dictionnary\n    \"\"\"\n    if key.__hash__:\n        if self.__contains__(key):\n            if isinstance(self.data[key], NPZFile):\n                data = self.data[key].load()\n                self.data[key] = data\n                # setattr(self, key, data)\n                return data\n            elif isinstance(self.data[key], NWBFile):\n                return self.data[key]\n            else:\n                return self.data[key]\n        else:\n            raise KeyError(\"Can't find key {} in group index.\".format(key))\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.expand","title":"expand","text":"<pre><code>expand()\n</code></pre> <p>Display the full tree view. Equivalent to Folder.view</p> Source code in <code>pynapple/io/folder.py</code> <pre><code>def expand(self):\n    \"\"\"Display the full tree view. Equivalent to Folder.view\"\"\"\n    if not isinstance(self._full_view, Tree):\n        self._generate_tree_view()\n\n    with Console() as console:\n        console.print(self._full_view)\n\n    return None\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.save","title":"save","text":"<pre><code>save(name, obj, description='')\n</code></pre> <p>Save a pynapple object in the folder in a single file in uncompressed <code>.npz</code> format. By default, the save function overwrite previously save file with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Filename</p> required <code>obj</code> <code>(Ts, Tsd, TsdFrame, TsGroup or IntervalSet)</code> <p>Pynapple object.</p> required <code>description</code> <code>str</code> <p>Metainformation added as a json sidecar.</p> <code>''</code> Source code in <code>pynapple/io/folder.py</code> <pre><code>def save(self, name, obj, description=\"\"):\n    \"\"\"Save a pynapple object in the folder in a single file in uncompressed ``.npz`` format.\n    By default, the save function overwrite previously save file with the same name.\n\n    Parameters\n    ----------\n    name : str\n        Filename\n    obj : Ts, Tsd, TsdFrame, TsGroup or IntervalSet\n        Pynapple object.\n    description : str, optional\n        Metainformation added as a json sidecar.\n    \"\"\"\n    filepath = os.path.join(self.path, name)\n    obj.save(filepath)\n    self.npz_files[name] = NPZFile(filepath + \".npz\")\n    self.data[name] = obj\n\n    metadata = {\"time\": str(datetime.now()), \"info\": str(description)}\n\n    with open(os.path.join(self.path, name + \".json\"), \"w\") as ff:\n        json.dump(metadata, ff, indent=2)\n\n    # regenerate the tree view\n    self._generate_tree_view()\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load all compatible NPZ files.</p> Source code in <code>pynapple/io/folder.py</code> <pre><code>def load(self):\n    \"\"\"Load all compatible NPZ files.\"\"\"\n    for k in self.npz_files.keys():\n        self[k] = self.npz_files[k].load()\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.info","title":"info","text":"<pre><code>info(name)\n</code></pre> <p>Display the metadata within the json sidecar of a NPZ file</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the npz file</p> required Source code in <code>pynapple/io/folder.py</code> <pre><code>def info(self, name):\n    \"\"\"Display the metadata within the json sidecar of a NPZ file\n\n    Parameters\n    ----------\n    name : str\n        Name of the npz file\n    \"\"\"\n    self.metadata(name)\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.doc","title":"doc","text":"<pre><code>doc(name)\n</code></pre> <p>Display the metadata within the json sidecar of a NPZ file</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the npz file</p> required Source code in <code>pynapple/io/folder.py</code> <pre><code>def doc(self, name):\n    \"\"\"Display the metadata within the json sidecar of a NPZ file\n\n    Parameters\n    ----------\n    name : str\n        Name of the npz file\n    \"\"\"\n    self.metadata(name)\n</code></pre>"},{"location":"reference/io/folder/#pynapple.io.folder.Folder.metadata","title":"metadata","text":"<pre><code>metadata(name)\n</code></pre> <p>Display the metadata within the json sidecar of a NPZ file</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the npz file</p> required Source code in <code>pynapple/io/folder.py</code> <pre><code>def metadata(self, name):\n    \"\"\"Display the metadata within the json sidecar of a NPZ file\n\n    Parameters\n    ----------\n    name : str\n        Name of the npz file\n    \"\"\"\n    # Search for json first\n    json_filename = os.path.join(self.path, name + \".json\")\n    if os.path.isfile(json_filename):\n        with open(json_filename, \"r\") as ff:\n            metadata = json.load(ff)\n            text = \"\\n\".join([\" : \".join(it) for it in metadata.items()])\n        panel = Panel.fit(\n            text, border_style=\"green\", title=os.path.join(self.path, name + \".npz\")\n        )\n    else:\n        panel = Panel.fit(\n            \"No metadata\",\n            border_style=\"red\",\n            title=os.path.join(self.path, name + \".npz\"),\n        )\n    with Console() as console:\n        console.print(panel)\n\n    return None\n</code></pre>"},{"location":"reference/io/interface_npz/","title":"Interface npz","text":""},{"location":"reference/io/interface_npz/#pynapple.io.interface_npz","title":"pynapple.io.interface_npz","text":"<p>File classes help to validate and load pynapple objects or NWB files. Data are always lazy-loaded. Both classes behaves like dictionnary.</p>"},{"location":"reference/io/interface_npz/#pynapple.io.interface_npz.NPZFile","title":"NPZFile","text":"<p>             Bases: <code>object</code></p> <p>Class that points to a NPZ file that can be loaded as a pynapple object. Objects have a save function in npz format as well as the Folder class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; tsd = nap.load_file(\"path/to/my_tsd.npz\")\n&gt;&gt;&gt; tsd\nTime (s)\n0.0    0\n0.1    1\n0.2    2\ndtype: int64\n</code></pre> Source code in <code>pynapple/io/interface_npz.py</code> <pre><code>class NPZFile(object):\n    \"\"\"Class that points to a NPZ file that can be loaded as a pynapple object.\n    Objects have a save function in npz format as well as the Folder class.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; tsd = nap.load_file(\"path/to/my_tsd.npz\")\n    &gt;&gt;&gt; tsd\n    Time (s)\n    0.0    0\n    0.1    1\n    0.2    2\n    dtype: int64\n\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"Initialization of the NPZ file\n\n        Parameters\n        ----------\n        path : str\n            Valid path to a NPZ file\n        \"\"\"\n        self.path = path\n        self.name = os.path.basename(path)\n        self.file = np.load(self.path, allow_pickle=True)\n        self.type = \"\"\n\n        # First check if type is explicitely defined\n        possible = [\"Ts\", \"Tsd\", \"TsdFrame\", \"TsdTensor\", \"TsGroup\", \"IntervalSet\"]\n        if \"type\" in self.file.keys():\n            if len(self.file[\"type\"]) == 1:\n                if isinstance(self.file[\"type\"][0], np.str_):\n                    if self.file[\"type\"] in possible:\n                        self.type = self.file[\"type\"][0]\n\n        # Second check manually\n        if self.type == \"\":\n            k = set(self.file.keys())\n            if {\"t\", \"start\", \"end\", \"index\"}.issubset(k):\n                self.type = \"TsGroup\"\n            elif {\"t\", \"d\", \"start\", \"end\", \"columns\"}.issubset(k):\n                self.type = \"TsdFrame\"\n            elif {\"t\", \"d\", \"start\", \"end\"}.issubset(k):\n                if self.file[\"d\"].ndim == 1:\n                    self.type = \"Tsd\"\n                else:\n                    self.type = \"TsdTensor\"\n            elif {\"t\", \"start\", \"end\"}.issubset(k):\n                self.type = \"Ts\"\n            elif {\"start\", \"end\"}.issubset(k):\n                self.type = \"IntervalSet\"\n            else:\n                self.type = \"npz\"\n\n    def load(self):\n        \"\"\"Load the NPZ file\n\n        Returns\n        -------\n        (Tsd, Ts, TsdFrame, TsdTensor, TsGroup, IntervalSet)\n            A pynapple object\n        \"\"\"\n        if self.type == \"npz\":\n            return self.file\n        else:\n            time_support = nap.IntervalSet(self.file[\"start\"], self.file[\"end\"])\n            if self.type == \"TsGroup\":\n                tsd = nap.Tsd(\n                    t=self.file[\"t\"], d=self.file[\"index\"], time_support=time_support\n                )\n                tsgroup = tsd.to_tsgroup()\n                if \"d\" in self.file.keys():\n                    print(\"TODO\")\n\n                metainfo = {}\n                for k in set(self.file.keys()) - {\n                    \"start\",\n                    \"end\",\n                    \"t\",\n                    \"index\",\n                    \"d\",\n                    \"rate\",\n                }:\n                    tmp = self.file[k]\n                    if len(tmp) == len(tsgroup):\n                        metainfo[k] = tmp\n                tsgroup.set_info(**metainfo)\n                return tsgroup\n\n            elif self.type == \"TsdFrame\":\n                return nap.TsdFrame(\n                    t=self.file[\"t\"],\n                    d=self.file[\"d\"],\n                    time_support=time_support,\n                    columns=self.file[\"columns\"],\n                )\n            elif self.type == \"TsdTensor\":\n                return nap.TsdTensor(\n                    t=self.file[\"t\"], d=self.file[\"d\"], time_support=time_support\n                )\n            elif self.type == \"Tsd\":\n                return nap.Tsd(\n                    t=self.file[\"t\"], d=self.file[\"d\"], time_support=time_support\n                )\n            elif self.type == \"Ts\":\n                return nap.Ts(t=self.file[\"t\"], time_support=time_support)\n            elif self.type == \"IntervalSet\":\n                return time_support\n            else:\n                return self.file\n</code></pre>"},{"location":"reference/io/interface_npz/#pynapple.io.interface_npz.NPZFile.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Initialization of the NPZ file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Valid path to a NPZ file</p> required Source code in <code>pynapple/io/interface_npz.py</code> <pre><code>def __init__(self, path):\n    \"\"\"Initialization of the NPZ file\n\n    Parameters\n    ----------\n    path : str\n        Valid path to a NPZ file\n    \"\"\"\n    self.path = path\n    self.name = os.path.basename(path)\n    self.file = np.load(self.path, allow_pickle=True)\n    self.type = \"\"\n\n    # First check if type is explicitely defined\n    possible = [\"Ts\", \"Tsd\", \"TsdFrame\", \"TsdTensor\", \"TsGroup\", \"IntervalSet\"]\n    if \"type\" in self.file.keys():\n        if len(self.file[\"type\"]) == 1:\n            if isinstance(self.file[\"type\"][0], np.str_):\n                if self.file[\"type\"] in possible:\n                    self.type = self.file[\"type\"][0]\n\n    # Second check manually\n    if self.type == \"\":\n        k = set(self.file.keys())\n        if {\"t\", \"start\", \"end\", \"index\"}.issubset(k):\n            self.type = \"TsGroup\"\n        elif {\"t\", \"d\", \"start\", \"end\", \"columns\"}.issubset(k):\n            self.type = \"TsdFrame\"\n        elif {\"t\", \"d\", \"start\", \"end\"}.issubset(k):\n            if self.file[\"d\"].ndim == 1:\n                self.type = \"Tsd\"\n            else:\n                self.type = \"TsdTensor\"\n        elif {\"t\", \"start\", \"end\"}.issubset(k):\n            self.type = \"Ts\"\n        elif {\"start\", \"end\"}.issubset(k):\n            self.type = \"IntervalSet\"\n        else:\n            self.type = \"npz\"\n</code></pre>"},{"location":"reference/io/interface_npz/#pynapple.io.interface_npz.NPZFile.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load the NPZ file</p> <p>Returns:</p> Type Description <code>(Tsd, Ts, TsdFrame, TsdTensor, TsGroup, IntervalSet)</code> <p>A pynapple object</p> Source code in <code>pynapple/io/interface_npz.py</code> <pre><code>def load(self):\n    \"\"\"Load the NPZ file\n\n    Returns\n    -------\n    (Tsd, Ts, TsdFrame, TsdTensor, TsGroup, IntervalSet)\n        A pynapple object\n    \"\"\"\n    if self.type == \"npz\":\n        return self.file\n    else:\n        time_support = nap.IntervalSet(self.file[\"start\"], self.file[\"end\"])\n        if self.type == \"TsGroup\":\n            tsd = nap.Tsd(\n                t=self.file[\"t\"], d=self.file[\"index\"], time_support=time_support\n            )\n            tsgroup = tsd.to_tsgroup()\n            if \"d\" in self.file.keys():\n                print(\"TODO\")\n\n            metainfo = {}\n            for k in set(self.file.keys()) - {\n                \"start\",\n                \"end\",\n                \"t\",\n                \"index\",\n                \"d\",\n                \"rate\",\n            }:\n                tmp = self.file[k]\n                if len(tmp) == len(tsgroup):\n                    metainfo[k] = tmp\n            tsgroup.set_info(**metainfo)\n            return tsgroup\n\n        elif self.type == \"TsdFrame\":\n            return nap.TsdFrame(\n                t=self.file[\"t\"],\n                d=self.file[\"d\"],\n                time_support=time_support,\n                columns=self.file[\"columns\"],\n            )\n        elif self.type == \"TsdTensor\":\n            return nap.TsdTensor(\n                t=self.file[\"t\"], d=self.file[\"d\"], time_support=time_support\n            )\n        elif self.type == \"Tsd\":\n            return nap.Tsd(\n                t=self.file[\"t\"], d=self.file[\"d\"], time_support=time_support\n            )\n        elif self.type == \"Ts\":\n            return nap.Ts(t=self.file[\"t\"], time_support=time_support)\n        elif self.type == \"IntervalSet\":\n            return time_support\n        else:\n            return self.file\n</code></pre>"},{"location":"reference/io/interface_nwb/","title":"Interface nwb","text":""},{"location":"reference/io/interface_nwb/#pynapple.io.interface_nwb","title":"pynapple.io.interface_nwb","text":"<p>Pynapple class to interface with NWB files. Data are always lazy-loaded. Object behaves like dictionary.</p>"},{"location":"reference/io/interface_nwb/#pynapple.io.interface_nwb.NWBFile","title":"NWBFile","text":"<p>             Bases: <code>UserDict</code></p> <p>Class for reading NWB Files.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pynapple as nap\n&gt;&gt;&gt; data = nap.load_file(\"my_file.nwb\")\n&gt;&gt;&gt; data[\"units\"]\n  Index    rate  location      group\n-------  ------  ----------  -------\n      0    1.0  brain        0\n      1    1.0  brain        0\n      2    1.0  brain        0\n</code></pre> Source code in <code>pynapple/io/interface_nwb.py</code> <pre><code>class NWBFile(UserDict):\n    \"\"\"Class for reading NWB Files.\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pynapple as nap\n    &gt;&gt;&gt; data = nap.load_file(\"my_file.nwb\")\n    &gt;&gt;&gt; data[\"units\"]\n      Index    rate  location      group\n    -------  ------  ----------  -------\n          0    1.0  brain        0\n          1    1.0  brain        0\n          2    1.0  brain        0\n\n    \"\"\"\n\n    _f_eval = {\n        \"IntervalSet\": _make_interval_set,\n        \"Tsd\": _make_tsd,\n        \"Ts\": _make_ts,\n        \"TsdFrame\": _make_tsd_frame,\n        \"TsdTensor\": _make_tsd_tensor,\n        \"TsGroup\": _make_tsgroup,\n    }\n\n    def __init__(self, file):\n        \"\"\"\n        Parameters\n        ----------\n        file : str or pynwb.file.NWBFile\n            Valid file to a NWB file\n\n        Raises\n        ------\n        FileNotFoundError\n            If path is invalid\n        RuntimeError\n            If file is not an instance of NWBFile\n        \"\"\"\n        if isinstance(file, str):\n            if os.path.exists(file):\n                self.path = file\n                self.name = os.path.basename(file).split(\".\")[0]\n                self.io = NWBHDF5IO(file, \"r\")\n                self.nwb = self.io.read()\n            else:\n                raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), file)\n        elif isinstance(file, pynwb.file.NWBFile):\n            self.nwb = file\n            self.name = self.nwb.session_id\n\n        else:\n            raise RuntimeError(\n                \"unrecognized argument. Please provide path to a valid NWB file or open NWB file.\"\n            )\n\n        self.data = _extract_compatible_data_from_nwbfile(self.nwb)\n        self.key_to_id = {k: self.data[k][\"id\"] for k in self.data.keys()}\n\n        self._view = [[k, self.data[k][\"type\"]] for k in self.data.keys()]\n\n        UserDict.__init__(self, self.data)\n\n    def __str__(self):\n        title = self.name if isinstance(self.name, str) else \"-\"\n        headers = [\"Keys\", \"Type\"]\n        return (\n            title\n            + \"\\n\"\n            + tabulate(self._view, headers=headers, tablefmt=\"mixed_outline\")\n        )\n\n        # self._view = Table(title=self.name)\n        # self._view.add_column(\"Keys\", justify=\"left\", style=\"cyan\", no_wrap=True)\n        # self._view.add_column(\"Type\", style=\"green\")\n        # for k in self.data.keys():\n        #     self._view.add_row(\n        #         k,\n        #         self.data[k][\"type\"],\n        #     )\n\n        # \"\"\"View of the object\"\"\"\n        # with Console() as console:\n        #     console.print(self._view)\n        # return \"\"\n\n    def __repr__(self):\n        \"\"\"View of the object\"\"\"\n        return self.__str__()\n\n    def __getitem__(self, key):\n        \"\"\"Get object from NWB\n\n        Parameters\n        ----------\n        key : str\n\n\n        Returns\n        -------\n        (Ts, Tsd, TsdFrame, TsGroup, IntervalSet or dict of IntervalSet)\n\n\n        Raises\n        ------\n        KeyError\n            If key is not in the dictionary\n        \"\"\"\n        if key.__hash__:\n            if self.__contains__(key):\n                if isinstance(self.data[key], dict) and \"id\" in self.data[key]:\n                    obj = self.nwb.objects[self.data[key][\"id\"]]\n                    try:\n                        data = self._f_eval[self.data[key][\"type\"]](obj)\n                    except Exception:\n                        warnings.warn(\n                            \"Failed to build {}.\\n Returning the NWB object for manual inspection\".format(\n                                self.data[key][\"type\"]\n                            ),\n                            stacklevel=2,\n                        )\n                        data = obj\n\n                    self.data[key] = data\n                    return data\n                else:\n                    return self.data[key]\n            else:\n                raise KeyError(\"Can't find key {} in group index.\".format(key))\n</code></pre>"},{"location":"reference/io/interface_nwb/#pynapple.io.interface_nwb.NWBFile.__init__","title":"__init__","text":"<pre><code>__init__(file)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str or NWBFile</code> <p>Valid file to a NWB file</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If path is invalid</p> <code>RuntimeError</code> <p>If file is not an instance of NWBFile</p> Source code in <code>pynapple/io/interface_nwb.py</code> <pre><code>def __init__(self, file):\n    \"\"\"\n    Parameters\n    ----------\n    file : str or pynwb.file.NWBFile\n        Valid file to a NWB file\n\n    Raises\n    ------\n    FileNotFoundError\n        If path is invalid\n    RuntimeError\n        If file is not an instance of NWBFile\n    \"\"\"\n    if isinstance(file, str):\n        if os.path.exists(file):\n            self.path = file\n            self.name = os.path.basename(file).split(\".\")[0]\n            self.io = NWBHDF5IO(file, \"r\")\n            self.nwb = self.io.read()\n        else:\n            raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), file)\n    elif isinstance(file, pynwb.file.NWBFile):\n        self.nwb = file\n        self.name = self.nwb.session_id\n\n    else:\n        raise RuntimeError(\n            \"unrecognized argument. Please provide path to a valid NWB file or open NWB file.\"\n        )\n\n    self.data = _extract_compatible_data_from_nwbfile(self.nwb)\n    self.key_to_id = {k: self.data[k][\"id\"] for k in self.data.keys()}\n\n    self._view = [[k, self.data[k][\"type\"]] for k in self.data.keys()]\n\n    UserDict.__init__(self, self.data)\n</code></pre>"},{"location":"reference/io/interface_nwb/#pynapple.io.interface_nwb.NWBFile.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>View of the object</p> Source code in <code>pynapple/io/interface_nwb.py</code> <pre><code>def __repr__(self):\n    \"\"\"View of the object\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"reference/io/interface_nwb/#pynapple.io.interface_nwb.NWBFile.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Get object from NWB</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> required <p>Returns:</p> Type Description <code>(Ts, Tsd, TsdFrame, TsGroup, IntervalSet or dict of IntervalSet)</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If key is not in the dictionary</p> Source code in <code>pynapple/io/interface_nwb.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Get object from NWB\n\n    Parameters\n    ----------\n    key : str\n\n\n    Returns\n    -------\n    (Ts, Tsd, TsdFrame, TsGroup, IntervalSet or dict of IntervalSet)\n\n\n    Raises\n    ------\n    KeyError\n        If key is not in the dictionary\n    \"\"\"\n    if key.__hash__:\n        if self.__contains__(key):\n            if isinstance(self.data[key], dict) and \"id\" in self.data[key]:\n                obj = self.nwb.objects[self.data[key][\"id\"]]\n                try:\n                    data = self._f_eval[self.data[key][\"type\"]](obj)\n                except Exception:\n                    warnings.warn(\n                        \"Failed to build {}.\\n Returning the NWB object for manual inspection\".format(\n                            self.data[key][\"type\"]\n                        ),\n                        stacklevel=2,\n                    )\n                    data = obj\n\n                self.data[key] = data\n                return data\n            else:\n                return self.data[key]\n        else:\n            raise KeyError(\"Can't find key {} in group index.\".format(key))\n</code></pre>"},{"location":"reference/io/loader/","title":"Loader","text":""},{"location":"reference/io/loader/#pynapple.io.loader","title":"pynapple.io.loader","text":"<p>BaseLoader is the general class for loading session with pynapple.</p> <p>@author: Guillaume Viejo</p>"},{"location":"reference/io/loader/#pynapple.io.loader.BaseLoader","title":"BaseLoader","text":"<p>             Bases: <code>object</code></p> <p>General loader for epochs and tracking data</p> Source code in <code>pynapple/io/loader.py</code> <pre><code>class BaseLoader(object):\n    \"\"\"\n    General loader for epochs and tracking data\n    \"\"\"\n\n    def __init__(self, path=None):\n        self.path = path\n\n        file_found = False\n        # Check if a pynapplenwb folder exist\n        if self.path is not None:\n            nwb_path = os.path.join(self.path, \"pynapplenwb\")\n            if os.path.exists(nwb_path):\n                files = os.listdir(nwb_path)\n                if len([f for f in files if f.endswith(\".nwb\")]):\n                    file_found = True\n                    self.load_data(path)\n\n        # Starting the GUI\n        if not file_found:\n            raise RuntimeError(get_error_text(path))\n\n    def load_data(self, path):\n        \"\"\"\n        Load NWB data saved with pynapple in the pynapplenwb folder\n\n        Parameters\n        ----------\n        path : str\n            Path to the session folder\n        \"\"\"\n        self.nwb_path = os.path.join(path, \"pynapplenwb\")\n        if not os.path.exists(self.nwb_path):\n            raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n        self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n        self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n        io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n        nwbfile = io.read()\n\n        position = {}\n        acq_keys = nwbfile.acquisition.keys()\n        if \"CompassDirection\" in acq_keys:\n            compass = nwbfile.acquisition[\"CompassDirection\"]\n            for k in compass.spatial_series.keys():\n                position[k] = pd.Series(\n                    index=compass.get_spatial_series(k).timestamps[:],\n                    data=compass.get_spatial_series(k).data[:],\n                )\n        if \"Position\" in acq_keys:\n            tracking = nwbfile.acquisition[\"Position\"]\n            for k in tracking.spatial_series.keys():\n                position[k] = pd.Series(\n                    index=tracking.get_spatial_series(k).timestamps[:],\n                    data=tracking.get_spatial_series(k).data[:],\n                )\n        if len(position):\n            position = pd.DataFrame.from_dict(position)\n\n            # retrieveing time support position if in epochs\n            if \"position_time_support\" in nwbfile.intervals.keys():\n                epochs = nwbfile.intervals[\"position_time_support\"].to_dataframe()\n                time_support = nap.IntervalSet(\n                    start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n                )\n\n            self.position = nap.TsdFrame(\n                position, time_units=\"s\", time_support=time_support\n            )\n\n        if nwbfile.epochs is not None:\n            epochs = nwbfile.epochs.to_dataframe()\n            # NWB is dumb and cannot take a single string for labels\n            epochs[\"label\"] = [epochs.loc[i, \"tags\"][0] for i in epochs.index]\n            epochs = epochs.drop(labels=\"tags\", axis=1)\n            epochs = epochs.rename(columns={\"start_time\": \"start\", \"stop_time\": \"end\"})\n            self.epochs = self._make_epochs(epochs)\n\n            self.time_support = self._join_epochs(epochs, \"s\")\n\n        io.close()\n\n        return\n\n    def _make_epochs(self, epochs, time_units=\"s\"):\n        \"\"\"\n        Split GUI epochs into dict of epochs\n        \"\"\"\n        labels = epochs.groupby(\"label\").groups\n        isets = {}\n        for lbs in labels.keys():\n            tmp = epochs.loc[labels[lbs]]\n            isets[lbs] = nap.IntervalSet(\n                start=tmp[\"start\"], end=tmp[\"end\"], time_units=time_units\n            )\n        return isets\n\n    def _join_epochs(self, epochs, time_units=\"s\"):\n        \"\"\"\n        To create the global time support of the data\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            isets = nap.IntervalSet(\n                start=epochs[\"start\"].sort_values(),\n                end=epochs[\"end\"].sort_values(),\n                time_units=time_units,\n            )\n            iset = isets.merge_close_intervals(1, time_units=\"us\")\n        if len(iset):\n            return iset\n        else:\n            return None\n\n    def save_nwb_intervals(self, iset, name, description=\"\"):\n        \"\"\"\n        Add epochs to the NWB file (e.g. ripples epochs)\n        See pynwb.epoch.TimeIntervals\n\n        Parameters\n        ----------\n        iset : IntervalSet\n            The intervalSet to save\n        name : str\n            The name in the nwb file\n        \"\"\"\n        io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n        nwbfile = io.read()\n\n        epochs = iset.as_units(\"s\")\n        time_intervals = TimeIntervals(name=name, description=description)\n        for i in epochs.index:\n            time_intervals.add_interval(\n                start_time=epochs.loc[i, \"start\"],\n                stop_time=epochs.loc[i, \"end\"],\n                tags=str(i),\n            )\n\n        nwbfile.add_time_intervals(time_intervals)\n        io.write(nwbfile)\n        io.close()\n\n        return\n\n    def save_nwb_timeseries(self, tsd, name, description=\"\"):\n        \"\"\"\n        Save timestamps in the NWB file (e.g. ripples time) with the time support.\n        See pynwb.base.TimeSeries\n\n\n        Parameters\n        ----------\n        tsd : TsdFrame\n            _\n        name : str\n            _\n        description : str, optional\n            _\n        \"\"\"\n        io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n        nwbfile = io.read()\n\n        ts = TimeSeries(\n            name=name,\n            unit=\"s\",\n            data=tsd.values,\n            timestamps=tsd.as_units(\"s\").index.values,\n        )\n\n        time_support = TimeIntervals(\n            name=name + \"_timesupport\", description=\"The time support of the object\"\n        )\n\n        epochs = tsd.time_support.as_units(\"s\")\n        for i in epochs.index:\n            time_support.add_interval(\n                start_time=epochs.loc[i, \"start\"],\n                stop_time=epochs.loc[i, \"end\"],\n                tags=str(i),\n            )\n        nwbfile.add_time_intervals(time_support)\n        nwbfile.add_acquisition(ts)\n        io.write(nwbfile)\n        io.close()\n\n        return\n\n    def load_nwb_intervals(self, name):\n        \"\"\"\n        Load epochs from the NWB file (e.g. 'ripples')\n\n        Parameters\n        ----------\n        name : str\n            The name in the nwb file\n        \"\"\"\n        io = NWBHDF5IO(self.nwbfilepath, \"r\")\n        nwbfile = io.read()\n\n        if name in nwbfile.intervals.keys():\n            epochs = nwbfile.intervals[name].to_dataframe()\n            isets = nap.IntervalSet(\n                start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n            )\n            io.close()\n            return isets\n        else:\n            io.close()\n        return\n\n    def load_nwb_timeseries(self, name):\n        \"\"\"\n        Load timestamps in the NWB file (e.g. ripples time)\n\n        Parameters\n        ----------\n        name : str\n            _\n\n        Returns\n        -------\n        Tsd\n            _\n        \"\"\"\n        io = NWBHDF5IO(self.nwbfilepath, \"r\")\n        nwbfile = io.read()\n\n        ts = nwbfile.acquisition[name]\n\n        time_support = self.load_nwb_intervals(name + \"_timesupport\")\n\n        tsd = nap.Tsd(\n            t=ts.timestamps[:], d=ts.data[:], time_units=\"s\", time_support=time_support\n        )\n\n        io.close()\n\n        return tsd\n</code></pre>"},{"location":"reference/io/loader/#pynapple.io.loader.BaseLoader.load_data","title":"load_data","text":"<pre><code>load_data(path)\n</code></pre> <p>Load NWB data saved with pynapple in the pynapplenwb folder</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session folder</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_data(self, path):\n    \"\"\"\n    Load NWB data saved with pynapple in the pynapplenwb folder\n\n    Parameters\n    ----------\n    path : str\n        Path to the session folder\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    position = {}\n    acq_keys = nwbfile.acquisition.keys()\n    if \"CompassDirection\" in acq_keys:\n        compass = nwbfile.acquisition[\"CompassDirection\"]\n        for k in compass.spatial_series.keys():\n            position[k] = pd.Series(\n                index=compass.get_spatial_series(k).timestamps[:],\n                data=compass.get_spatial_series(k).data[:],\n            )\n    if \"Position\" in acq_keys:\n        tracking = nwbfile.acquisition[\"Position\"]\n        for k in tracking.spatial_series.keys():\n            position[k] = pd.Series(\n                index=tracking.get_spatial_series(k).timestamps[:],\n                data=tracking.get_spatial_series(k).data[:],\n            )\n    if len(position):\n        position = pd.DataFrame.from_dict(position)\n\n        # retrieveing time support position if in epochs\n        if \"position_time_support\" in nwbfile.intervals.keys():\n            epochs = nwbfile.intervals[\"position_time_support\"].to_dataframe()\n            time_support = nap.IntervalSet(\n                start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n            )\n\n        self.position = nap.TsdFrame(\n            position, time_units=\"s\", time_support=time_support\n        )\n\n    if nwbfile.epochs is not None:\n        epochs = nwbfile.epochs.to_dataframe()\n        # NWB is dumb and cannot take a single string for labels\n        epochs[\"label\"] = [epochs.loc[i, \"tags\"][0] for i in epochs.index]\n        epochs = epochs.drop(labels=\"tags\", axis=1)\n        epochs = epochs.rename(columns={\"start_time\": \"start\", \"stop_time\": \"end\"})\n        self.epochs = self._make_epochs(epochs)\n\n        self.time_support = self._join_epochs(epochs, \"s\")\n\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/loader/#pynapple.io.loader.BaseLoader.save_nwb_intervals","title":"save_nwb_intervals","text":"<pre><code>save_nwb_intervals(iset, name, description='')\n</code></pre> <p>Add epochs to the NWB file (e.g. ripples epochs) See pynwb.epoch.TimeIntervals</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>The intervalSet to save</p> required <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_intervals(self, iset, name, description=\"\"):\n    \"\"\"\n    Add epochs to the NWB file (e.g. ripples epochs)\n    See pynwb.epoch.TimeIntervals\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        The intervalSet to save\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    epochs = iset.as_units(\"s\")\n    time_intervals = TimeIntervals(name=name, description=description)\n    for i in epochs.index:\n        time_intervals.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n\n    nwbfile.add_time_intervals(time_intervals)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/loader/#pynapple.io.loader.BaseLoader.save_nwb_timeseries","title":"save_nwb_timeseries","text":"<pre><code>save_nwb_timeseries(tsd, name, description='')\n</code></pre> <p>Save timestamps in the NWB file (e.g. ripples time) with the time support. See pynwb.base.TimeSeries</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>TsdFrame</code> <p>_</p> required <code>name</code> <code>str</code> <p>_</p> required <code>description</code> <code>str</code> <p>_</p> <code>''</code> Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_timeseries(self, tsd, name, description=\"\"):\n    \"\"\"\n    Save timestamps in the NWB file (e.g. ripples time) with the time support.\n    See pynwb.base.TimeSeries\n\n\n    Parameters\n    ----------\n    tsd : TsdFrame\n        _\n    name : str\n        _\n    description : str, optional\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    ts = TimeSeries(\n        name=name,\n        unit=\"s\",\n        data=tsd.values,\n        timestamps=tsd.as_units(\"s\").index.values,\n    )\n\n    time_support = TimeIntervals(\n        name=name + \"_timesupport\", description=\"The time support of the object\"\n    )\n\n    epochs = tsd.time_support.as_units(\"s\")\n    for i in epochs.index:\n        time_support.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n    nwbfile.add_time_intervals(time_support)\n    nwbfile.add_acquisition(ts)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/loader/#pynapple.io.loader.BaseLoader.load_nwb_intervals","title":"load_nwb_intervals","text":"<pre><code>load_nwb_intervals(name)\n</code></pre> <p>Load epochs from the NWB file (e.g. 'ripples')</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_intervals(self, name):\n    \"\"\"\n    Load epochs from the NWB file (e.g. 'ripples')\n\n    Parameters\n    ----------\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if name in nwbfile.intervals.keys():\n        epochs = nwbfile.intervals[name].to_dataframe()\n        isets = nap.IntervalSet(\n            start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n        )\n        io.close()\n        return isets\n    else:\n        io.close()\n    return\n</code></pre>"},{"location":"reference/io/loader/#pynapple.io.loader.BaseLoader.load_nwb_timeseries","title":"load_nwb_timeseries","text":"<pre><code>load_nwb_timeseries(name)\n</code></pre> <p>Load timestamps in the NWB file (e.g. ripples time)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>_</p> required <p>Returns:</p> Type Description <code>Tsd</code> <p>_</p> Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_timeseries(self, name):\n    \"\"\"\n    Load timestamps in the NWB file (e.g. ripples time)\n\n    Parameters\n    ----------\n    name : str\n        _\n\n    Returns\n    -------\n    Tsd\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    ts = nwbfile.acquisition[name]\n\n    time_support = self.load_nwb_intervals(name + \"_timesupport\")\n\n    tsd = nap.Tsd(\n        t=ts.timestamps[:], d=ts.data[:], time_units=\"s\", time_support=time_support\n    )\n\n    io.close()\n\n    return tsd\n</code></pre>"},{"location":"reference/io/misc/","title":"Misc","text":""},{"location":"reference/io/misc/#pynapple.io.misc","title":"pynapple.io.misc","text":"<p>Various io functions</p>"},{"location":"reference/io/misc/#pynapple.io.misc.load_file","title":"load_file","text":"<pre><code>load_file(path)\n</code></pre> <p>Load file. Current format supported is (npz,nwb,)</p> <p>.npz -&gt; If the file is compatible with a pynapple format, the function will return a pynapple object. Otherwise, the function will return the output of numpy.load</p> <p>.nwb -&gt; Return the pynapple.io.NWBFile class wrapping the NWBFile</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>(Tsd, TsdFrame, Ts, IntervalSet, TsGroup, NWBFile)</code> <p>One of the 5 pynapple objects or pynapple.io.NWBFile</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file is missing</p> Source code in <code>pynapple/io/misc.py</code> <pre><code>def load_file(path):\n    \"\"\"Load file. Current format supported is (npz,nwb,)\n\n    .npz -&gt; If the file is compatible with a pynapple format, the function will return a pynapple object.\n    Otherwise, the function will return the output of numpy.load\n\n    .nwb -&gt; Return the pynapple.io.NWBFile class wrapping the NWBFile\n\n    Parameters\n    ----------\n    path : str\n        Path to the file\n\n    Returns\n    -------\n    (Tsd, TsdFrame, Ts, IntervalSet, TsGroup, pynapple.io.NWBFile)\n        One of the 5 pynapple objects or pynapple.io.NWBFile\n\n    Raises\n    ------\n    FileNotFoundError\n        If file is missing\n    \"\"\"\n    if os.path.isfile(path):\n        if path.endswith(\".npz\"):\n            return NPZFile(path).load()\n        elif path.endswith(\".nwb\"):\n            return NWBFile(path)\n        else:\n            raise RuntimeError(\"File format not supported\")\n    else:\n        raise FileNotFoundError(\"File {} does not exist\".format(path))\n</code></pre>"},{"location":"reference/io/misc/#pynapple.io.misc.load_folder","title":"load_folder","text":"<pre><code>load_folder(path)\n</code></pre> <p>Load folder containing files or other folder. Pynapple will walk throught the subfolders to detect compatible npz files or nwb files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the folder</p> required <p>Returns:</p> Type Description <code>Folder</code> <p>A dictionnary-like class containing all the sub-folders and compatible files (i.e. npz, nwb)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If folder is missing</p> Source code in <code>pynapple/io/misc.py</code> <pre><code>def load_folder(path):\n    \"\"\"Load folder containing files or other folder.\n    Pynapple will walk throught the subfolders to detect compatible npz files\n    or nwb files.\n\n    Parameters\n    ----------\n    path : str\n        Path to the folder\n\n    Returns\n    -------\n    Folder\n        A dictionnary-like class containing all the sub-folders and compatible files (i.e. npz, nwb)\n\n    Raises\n    ------\n    RuntimeError\n        If folder is missing\n    \"\"\"\n    if os.path.isdir(path):\n        return Folder(path)\n    else:\n        raise RuntimeError(\"Folder {} does not exist\".format(path))\n</code></pre>"},{"location":"reference/io/misc/#pynapple.io.misc.load_session","title":"load_session","text":"<pre><code>load_session(path=None, session_type=None)\n</code></pre> <p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % WARNING : THIS FUNCTION IS DEPRECATED % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% General Loader for</p> <ul> <li> <p>Neurosuite</p> </li> <li> <p>Phy</p> </li> <li> <p>Minian</p> </li> <li> <p>Inscopix-cnmfe</p> </li> <li> <p>Matlab-cnmfe</p> </li> <li> <p>Suite2p</p> </li> <li>None for default session.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the data</p> <code>None</code> <code>session_type</code> <code>str</code> <p>Can be 'neurosuite', 'phy', 'minian', 'inscopix-cnmfe', 'cnmfe-matlab', 'suite2p' or None for default loader.</p> <code>None</code> <p>Returns:</p> Type Description <code>Session</code> <p>A class holding all the data from the session.</p> Source code in <code>pynapple/io/misc.py</code> <pre><code>def load_session(path=None, session_type=None):\n    \"\"\"\n    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n    % WARNING : THIS FUNCTION IS DEPRECATED %\n    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n    General Loader for\n\n    - Neurosuite\\n\n    - Phy\\n\n    - Minian\\n\n    - Inscopix-cnmfe\\n\n    - Matlab-cnmfe\\n\n    - Suite2p\n    - None for default session.\n\n    Parameters\n    ----------\n    path : str, optional\n        The path to load the data\n    session_type : str, optional\n        Can be 'neurosuite', 'phy',\n        'minian', 'inscopix-cnmfe', 'cnmfe-matlab',\n        'suite2p' or None for default loader.\n\n    Returns\n    -------\n    Session\n        A class holding all the data from the session.\n\n    \"\"\"\n    if path:\n        if not os.path.isdir(path):\n            raise RuntimeError(\"Path {} is not found.\".format(path))\n\n    if isinstance(session_type, str):\n        session_type = session_type.lower()\n\n    if session_type == \"neurosuite\":\n        return NeuroSuite(path)\n\n    elif session_type == \"phy\":\n        return Phy(path)\n\n    elif session_type == \"inscopix-cnmfe\":\n        return InscopixCNMFE(path)\n\n    elif session_type == \"minian\":\n        return Minian(path)\n\n    elif session_type == \"cnmfe-matlab\":\n        return CNMF_E(path)\n\n    elif session_type == \"suite2p\":\n        return Suite2P(path)\n\n    else:\n        return BaseLoader(path)\n</code></pre>"},{"location":"reference/io/misc/#pynapple.io.misc.load_eeg","title":"load_eeg","text":"<pre><code>load_eeg(\n    filepath,\n    channel=None,\n    n_channels=None,\n    frequency=None,\n    precision=\"int16\",\n    bytes_size=2,\n)\n</code></pre> <p>Standalone function to load eeg/lfp/dat file in binary format.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the eeg file</p> required <code>channel</code> <code>int or list of int</code> <p>The channel(s) to load. If None return a memory map of the dat file to avoid memory error</p> <code>None</code> <code>n_channels</code> <code>int</code> <p>Number of channels</p> <code>None</code> <code>frequency</code> <code>float</code> <p>Sampling rate of the file</p> <code>None</code> <code>precision</code> <code>str</code> <p>The precision of the binary file</p> <code>'int16'</code> <code>bytes_size</code> <code>int</code> <p>Bytes size of the binary file</p> <code>2</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If can't find the lfp/eeg/dat file</p> <p>Returns:</p> Type Description <code>Tsd or TsdFrame</code> <p>The lfp in a time series format</p>"},{"location":"reference/io/misc/#pynapple.io.misc.load_eeg--deleted-parameters","title":"Deleted Parameters","text":"<p>extension : str, optional     The file extenstion (.eeg, .dat, .lfp). Make sure the frequency match</p> Source code in <code>pynapple/io/misc.py</code> <pre><code>def load_eeg(\n    filepath,\n    channel=None,\n    n_channels=None,\n    frequency=None,\n    precision=\"int16\",\n    bytes_size=2,\n):\n    \"\"\"\n    Standalone function to load eeg/lfp/dat file in binary format.\n\n    Parameters\n    ----------\n    filepath : str\n        The path to the eeg file\n    channel : int or list of int, optional\n        The channel(s) to load. If None return a memory map of the dat file to avoid memory error\n    n_channels : int, optional\n        Number of channels\n    frequency : float, optional\n        Sampling rate of the file\n    precision : str, optional\n        The precision of the binary file\n    bytes_size : int, optional\n        Bytes size of the binary file\n\n    Raises\n    ------\n    RuntimeError\n        If can't find the lfp/eeg/dat file\n\n    Returns\n    -------\n    Tsd or TsdFrame\n        The lfp in a time series format\n\n    Deleted Parameters\n    ------------------\n    extension : str, optional\n        The file extenstion (.eeg, .dat, .lfp). Make sure the frequency match\n\n    \"\"\"\n    # Need to check if a xml file exists\n    path = os.path.dirname(filepath)\n    basename = os.path.basename(filepath).split(\".\")[0]\n    listdir = os.listdir(path)\n\n    if frequency is None or n_channels is None:\n        if basename + \".xml\" in listdir:\n            xmlpath = os.path.join(path, basename + \".xml\")\n            xmldoc = minidom.parse(xmlpath)\n        else:\n            raise RuntimeError(\n                \"Can't find xml file; please specify sampling frequency or number of channels\"\n            )\n\n        if frequency is None:\n            if filepath.endswith(\".dat\"):\n                fs_dat = int(\n                    xmldoc.getElementsByTagName(\"acquisitionSystem\")[0]\n                    .getElementsByTagName(\"samplingRate\")[0]\n                    .firstChild.data\n                )\n                frequency = fs_dat\n            elif filepath.endswith((\".lfp\", \".eeg\")):\n                fs_eeg = int(\n                    xmldoc.getElementsByTagName(\"fieldPotentials\")[0]\n                    .getElementsByTagName(\"lfpSamplingRate\")[0]\n                    .firstChild.data\n                )\n                frequency = fs_eeg\n\n        if n_channels is None:\n            n_channels = int(\n                xmldoc.getElementsByTagName(\"acquisitionSystem\")[0]\n                .getElementsByTagName(\"nChannels\")[0]\n                .firstChild.data\n            )\n\n    f = open(filepath, \"rb\")\n    startoffile = f.seek(0, 0)\n    endoffile = f.seek(0, 2)\n    bytes_size = 2\n    n_samples = int((endoffile - startoffile) / n_channels / bytes_size)\n    duration = n_samples / frequency\n    f.close()\n    fp = np.memmap(filepath, np.int16, \"r\", shape=(n_samples, n_channels))\n    timestep = np.arange(0, n_samples) / frequency\n\n    time_support = nap.IntervalSet(start=0, end=duration, time_units=\"s\")\n\n    if channel is None:\n        return fp\n    elif type(channel) is int:\n        return nap.Tsd(\n            t=timestep, d=fp[:, channel], time_units=\"s\", time_support=time_support\n        )\n    elif type(channel) is list:\n        return nap.TsdFrame(\n            t=timestep,\n            d=fp[:, channel],\n            time_units=\"s\",\n            time_support=time_support,\n            columns=channel,\n        )\n</code></pre>"},{"location":"reference/io/misc/#pynapple.io.misc.append_NWB_LFP","title":"append_NWB_LFP","text":"<pre><code>append_NWB_LFP(path, lfp, channel=None)\n</code></pre> <p>Standalone function for adding lfp/eeg to already existing nwb files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the data. The function will looks for a nwb file in path or in path/pynapplenwb.</p> required <code>lfp</code> <code>Tsd or TsdFrame</code> <p>Description</p> required <code>channel</code> <code>None</code> <p>channel number in int ff lfp is a Tsd</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If can't find the nwb file </p> <p>If no channel is specify when passing a Tsd</p> Source code in <code>pynapple/io/misc.py</code> <pre><code>def append_NWB_LFP(path, lfp, channel=None):\n    \"\"\"Standalone function for adding lfp/eeg to already existing nwb files.\n\n    Parameters\n    ----------\n    path : str\n        The path to the data. The function will looks for a nwb file in path\n        or in path/pynapplenwb.\n    lfp : Tsd or TsdFrame\n        Description\n    channel : None, optional\n        channel number in int ff lfp is a Tsd\n\n    Raises\n    ------\n    RuntimeError\n        If can't find the nwb file \\n\n        If no channel is specify when passing a Tsd\n\n    \"\"\"\n    new_path = os.path.join(path, \"pynapplenwb\")\n    nwb_path = \"\"\n    if os.path.exists(new_path):\n        nwbfilename = [f for f in os.listdir(new_path) if f.endswith(\".nwb\")]\n        if len(nwbfilename):\n            nwb_path = os.path.join(path, \"pynapplenwb\", nwbfilename[0])\n    else:\n        nwbfilename = [f for f in os.listdir(path) if f.endswith(\".nwb\")]\n        if len(nwbfilename):\n            nwb_path = os.path.join(path, \"pynapplenwb\", nwbfilename[0])\n\n    if len(nwb_path) == 0:\n        raise RuntimeError(\"Can't find nwb file in {}\".format(path))\n\n    if isinstance(lfp, nap.TsdFrame):\n        channels = lfp.columns.values\n    elif isinstance(lfp, nap.Tsd):\n        if isinstance(channel, int):\n            channels = [channel]\n        else:\n            raise RuntimeError(\"Please specify which channel it is.\")\n\n    io = NWBHDF5IO(nwb_path, \"r+\")\n    nwbfile = io.read()\n\n    all_table_region = nwbfile.create_electrode_table_region(\n        region=channels, description=\"\", name=\"electrodes\"\n    )\n\n    lfp_electrical_series = ElectricalSeries(\n        name=\"ElectricalSeries\",\n        data=lfp.values,\n        timestamps=lfp.index.values,\n        electrodes=all_table_region,\n    )\n\n    lfp = LFP(electrical_series=lfp_electrical_series)\n\n    ecephys_module = nwbfile.create_processing_module(\n        name=\"ecephys\", description=\"processed extracellular electrophysiology data\"\n    )\n    ecephys_module.add(lfp)\n\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/neurosuite/","title":"Neurosuite","text":""},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite","title":"pynapple.io.neurosuite","text":"<p> DEPRECATED: This will be removed in version 1.0.0. Check nwbmatic or neuroconv instead.</p> <p>Class and functions for loading data processed with the Neurosuite (Klusters, Neuroscope, NDmanager)</p> <p>@author: Guillaume Viejo</p>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite","title":"NeuroSuite","text":"<p>             Bases: <code>BaseLoader</code></p> <p>Loader for kluster data</p> Source code in <code>pynapple/io/neurosuite.py</code> <pre><code>class NeuroSuite(BaseLoader):\n    \"\"\"\n    Loader for kluster data\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n        Instantiate the data class from a neurosuite folder.\n\n        Parameters\n        ----------\n        path : str\n            The path to the data.\n        \"\"\"\n        self.basename = os.path.basename(path)\n        self.time_support = None\n\n        super().__init__(path)\n\n        self.load_nwb_spikes(path)\n\n    def load_nwb_spikes(self, path):\n        \"\"\"\n        Read the NWB spikes to extract the spike times.\n\n        Parameters\n        ----------\n        path : str\n            The path to the data\n\n        Returns\n        -------\n        TYPE\n            Description\n        \"\"\"\n        self.nwb_path = os.path.join(path, \"pynapplenwb\")\n        if not os.path.exists(self.nwb_path):\n            raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n        self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n        self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n        io = NWBHDF5IO(self.nwbfilepath, \"r\")\n        nwbfile = io.read()\n\n        if nwbfile.units is None:\n            io.close()\n            return False\n        else:\n            units = nwbfile.units.to_dataframe()\n            spikes = {\n                n: nap.Ts(t=units.loc[n, \"spike_times\"], time_units=\"s\")\n                for n in units.index\n            }\n\n            self.spikes = nap.TsGroup(\n                spikes,\n                time_support=self.time_support,\n                time_units=\"s\",\n                group=units[\"group\"],\n            )\n\n            if ~np.all(units[\"location\"] == \"\"):\n                self.spikes.set_info(location=units[\"location\"])\n\n            io.close()\n            return True\n\n    def load_lfp(\n        self,\n        filename=None,\n        channel=None,\n        extension=\".eeg\",\n        frequency=1250.0,\n        precision=\"int16\",\n        bytes_size=2,\n    ):\n        \"\"\"\n        Load the LFP.\n\n        Parameters\n        ----------\n        filename : str, optional\n            The filename of the lfp file.\n            It can be useful it multiple dat files are present in the data directory\n        channel : int or list of int, optional\n            The channel(s) to load. If None return a memory map of the dat file to avoid memory error\n        extension : str, optional\n            The file extenstion (.eeg, .dat, .lfp). Make sure the frequency match\n        frequency : float, optional\n            Default 1250 Hz for the eeg file\n        precision : str, optional\n            The precision of the binary file\n        bytes_size : int, optional\n            Bytes size of the lfp file\n\n        Raises\n        ------\n        RuntimeError\n            If can't find the lfp/eeg/dat file\n\n        Returns\n        -------\n        Tsd or TsdFrame\n            The lfp in a time series format\n        \"\"\"\n        if filename is not None:\n            filepath = os.path.join(self.path, filename)\n        else:\n            listdir = os.listdir(self.path)\n            eegfile = [f for f in listdir if f.endswith(extension)]\n            if not len(eegfile):\n                raise RuntimeError(\n                    \"Path {} contains no {} files;\".format(self.path, extension)\n                )\n\n            filepath = os.path.join(self.path, eegfile[0])\n\n        self.load_neurosuite_xml(self.path)\n\n        n_channels = int(self.nChannels)\n\n        f = open(filepath, \"rb\")\n        startoffile = f.seek(0, 0)\n        endoffile = f.seek(0, 2)\n        bytes_size = 2\n        n_samples = int((endoffile - startoffile) / n_channels / bytes_size)\n        duration = n_samples / frequency\n        f.close()\n        fp = np.memmap(filepath, np.int16, \"r\", shape=(n_samples, n_channels))\n        timestep = np.arange(0, n_samples) / frequency\n\n        time_support = nap.IntervalSet(start=0, end=duration, time_units=\"s\")\n\n        if channel is None:\n            return nap.TsdFrame(\n                t=timestep, d=fp, time_units=\"s\", time_support=time_support\n            )\n        elif type(channel) is int:\n            return nap.Tsd(\n                t=timestep, d=fp[:, channel], time_units=\"s\", time_support=time_support\n            )\n        elif type(channel) is list:\n            return nap.TsdFrame(\n                t=timestep,\n                d=fp[:, channel],\n                time_units=\"s\",\n                time_support=time_support,\n                columns=channel,\n            )\n\n    def read_neuroscope_intervals(self, name=None, path2file=None):\n        \"\"\"\n        This function reads .evt files in which odd raws indicate the beginning\n        of the time series and the even raws are the ends.\n        If the file is present in the nwb, provide the just the name. If the file\n        is not present in the nwb, it loads the events from the nwb directory.\n        If just the path is provided but not the name, it takes the name from the file.\n\n        Parameters\n        ----------\n        name: str\n            name of the epoch in the nwb file, e.g. \"rem\" or desired name save\n            the data in the nwb.\n\n        path2file: str\n            Path of the file you want to load.\n\n        Returns\n        -------\n        IntervalSet\n            Contains two columns corresponding to the start and end of the intervals.\n\n        \"\"\"\n        if name:\n            isets = self.load_nwb_intervals(name)\n            if isinstance(isets, nap.IntervalSet):\n                return isets\n        if name is not None and path2file is None:\n            path2file = os.path.join(self.path, self.basename + \".\" + name + \".evt\")\n        if path2file is not None:\n            try:\n                # df = pd.read_csv(path2file, delimiter=' ', usecols = [0], header = None)\n                tmp = np.genfromtxt(path2file)[:, 0]\n                df = tmp.reshape(len(tmp) // 2, 2)\n            except ValueError:\n                print(\"specify a valid name\")\n            isets = nap.IntervalSet(df[:, 0], df[:, 1], time_units=\"ms\")\n            if name is None:\n                name = path2file.split(\".\")[-2]\n                print(\"*** saving file in the nwb as\", name)\n            self.save_nwb_intervals(isets, name)\n        else:\n            raise ValueError(\"specify a valid path\")\n        return isets\n\n    def write_neuroscope_intervals(self, extension, isets, name):\n        \"\"\"Write events to load with neuroscope (e.g. ripples start and ends)\n\n        Parameters\n        ----------\n        extension : str\n            The extension of the file (e.g. basename.evt.py.rip)\n        isets : IntervalSet\n            The IntervalSet to write\n        name : str\n            The name of the events (e.g. Ripples)\n        \"\"\"\n        start = isets.as_units(\"ms\")[\"start\"].values\n        ends = isets.as_units(\"ms\")[\"end\"].values\n\n        datatowrite = np.vstack((start, ends)).T.flatten()\n\n        n = len(isets)\n\n        texttowrite = np.vstack(\n            (\n                (np.repeat(np.array([name + \" start\"]), n)),\n                (np.repeat(np.array([name + \" end\"]), n)),\n            )\n        ).T.flatten()\n\n        evt_file = os.path.join(self.path, self.basename + extension)\n\n        f = open(evt_file, \"w\")\n        for t, n in zip(datatowrite, texttowrite):\n            f.writelines(\"{:1.6f}\".format(t) + \"\\t\" + n + \"\\n\")\n        f.close()\n\n        return\n\n    def load_mean_waveforms(self, epoch=None, waveform_window=None, spike_count=1000):\n        \"\"\"\n        Load the mean waveforms from a dat file.\n\n        Parameters\n        ----------\n        epoch : IntervalSet\n            default = None\n            Restrict spikes to an epoch.\n        waveform_window : IntervalSet\n            default interval nap.IntervalSet(start = -0.0005, end = 0.001, time_units = 'ms')\n            Limit waveform extraction before and after spike time\n        spike_count : int\n            default = 1000\n            Number of spikes used per neuron for the calculation of waveforms\n\n        Returns\n        -------\n        dictionary\n            the waveforms for all neurons\n        pandas.Series\n            the channel with the maximum waveform for each neuron\n\n        \"\"\"\n        if not isinstance(waveform_window, nap.IntervalSet):\n            waveform_window = nap.IntervalSet(start=-0.5, end=1, time_units=\"ms\")\n\n        spikes = self.spikes\n        if not os.path.exists(self.path):  # check if path exists\n            print(\"The path \" + self.path + \" doesn't exist; Exiting ...\")\n            sys.exit()\n\n        # Load XML INFO\n        self.load_neurosuite_xml(self.path)\n        n_channels = self.nChannels\n        fs = self.fs_dat\n        group_to_channel = self.group_to_channel\n        group = spikes.get_info(\"group\")\n\n        # Check if there is an epoch, restrict spike times to epoch\n        if epoch is not None:\n            if type(epoch) is not nap.IntervalSet:\n                print(\"Epoch must be an IntervalSet\")\n                sys.exit()\n            else:\n                print(\"Restricting spikes to epoch\")\n                spikes = spikes.restrict(epoch)\n                epstart = int(epoch.as_units(\"s\")[\"start\"].values[0] * fs)\n                epend = int(epoch.as_units(\"s\")[\"end\"].values[0] * fs)\n\n        # Find dat file\n        files = os.listdir(self.path)\n        dat_files = np.sort([f for f in files if \"dat\" in f and f[0] != \".\"])\n\n        # Need n_samples collected in the entire recording from dat file to load\n        file = os.path.join(self.path, dat_files[0])\n        f = open(\n            file, \"rb\"\n        )  # open file to get number of samples collected in the entire recording\n        startoffile = f.seek(0, 0)\n        endoffile = f.seek(0, 2)\n        bytes_size = 2\n        n_samples = int((endoffile - startoffile) / n_channels / bytes_size)\n        f.close()\n        # map to memory all samples for all channels, channels are numbered according to neuroscope number\n        fp = np.memmap(file, np.int16, \"r\", shape=(n_samples, n_channels))\n\n        # convert spike times to spikes in sample number\n        sample_spikes = {\n            neuron: (spikes[neuron].as_units(\"s\").index.values * fs).astype(\"int\")\n            for neuron in spikes\n        }\n\n        # prep for waveforms\n        overlap = int(\n            waveform_window.tot_length(time_units=\"s\")\n        )  # one spike's worth of overlap between windows\n        waveform_window = abs(np.array(waveform_window.as_units(\"s\"))[0] * fs).astype(\n            int\n        )  # convert time to sample number\n        neuron_waveforms = {\n            n: np.zeros([np.sum(waveform_window), len(group_to_channel[group[n]])])\n            for n in sample_spikes\n        }\n\n        # divide dat file into batches that slightly overlap for faster loading\n        batch_size = 3000000\n        windows = np.arange(0, int(endoffile / n_channels / bytes_size), batch_size)\n        if epoch is not None:\n            print(\"Restricting dat file to epoch\")\n            windows = windows[(windows &gt;= epstart) &amp; (windows &lt;= epend)]\n        batches = []\n        for (\n            i\n        ) in windows:  # make overlapping batches from the beginning to end of recording\n            if i == windows[-1]:  # the last batch cannot overlap with the next one\n                batches.append([i, n_samples])\n            else:\n                batches.append([i, i + batch_size + overlap])\n        batches = [np.int32(batch) for batch in batches]\n\n        sample_counted_spikes = {}\n        for index, neuron in enumerate(sample_spikes):\n            if len(sample_spikes[neuron]) &gt;= spike_count:\n                sample_counted_spikes[neuron] = np.array(\n                    np.random.choice(list(sample_spikes[neuron]), spike_count)\n                )\n            elif len(sample_spikes[neuron]) &lt; spike_count:\n                print(\n                    \"Not enough spikes in neuron \" + str(index) + \"... using all spikes\"\n                )\n                sample_counted_spikes[neuron] = sample_spikes[neuron]\n\n        # Make one array containing all selected spike times of all neurons - will be used to check for spikes before loading dat file\n        spike_check = np.array(\n            [\n                int(spikes_neuron)\n                for spikes_neuron in sample_counted_spikes[neuron]\n                for neuron in sample_counted_spikes\n            ]\n        )\n\n        for index, timestep in enumerate(batches):\n            print(\n                f\"Extracting waveforms from dat file: window {index+1} / {len(windows)}\",\n                end=\"\\r\",\n            )\n\n            if (\n                len(\n                    spike_check[\n                        (timestep[0] &lt; spike_check) &amp; (timestep[1] &gt; spike_check)\n                    ]\n                )\n                == 0\n            ):\n                continue  # if there are no spikes for any neurons in this batch, skip and go to the next one\n\n            # Load dat file for timestep\n            tmp = pd.DataFrame(\n                data=fp[timestep[0] : timestep[1], :],\n                columns=np.arange(n_channels),\n                index=range(timestep[0], timestep[1]),\n            )  # load dat file\n\n            # Check if any spikes are present\n            for neuron in sample_counted_spikes:\n                neurontmp = sample_counted_spikes[neuron]\n                tmp2 = neurontmp[(timestep[0] &lt; neurontmp) &amp; (timestep[1] &gt; neurontmp)]\n                if len(neurontmp) == 0:\n                    continue  # skip neuron if it has no spikes in this batch\n                tmpn = tmp[\n                    group_to_channel[group[neuron]]\n                ]  # restrict dat file to the channel group of the neuron\n\n                for time in tmp2:  # add each spike waveform to neuron_waveform\n                    spikewindow = tmpn.loc[\n                        time - waveform_window[0] : time + waveform_window[1] - 1\n                    ]  # waveform for this spike time\n                    try:\n                        neuron_waveforms[neuron] += spikewindow.values\n                    except (\n                        Exception\n                    ):  # ignore if full waveform is not present in this batch\n                        pass\n\n        meanwf = {\n            n: pd.DataFrame(\n                data=np.array(neuron_waveforms[n]) / spike_count,\n                columns=np.arange(len(group_to_channel[group[n]])),\n                index=np.array(np.arange(-waveform_window[0], waveform_window[1])) / fs,\n            )\n            for n in sample_counted_spikes\n        }\n\n        # find the max channel for each neuron\n        maxch = pd.Series(\n            data=[meanwf[n][meanwf[n].loc[0].idxmin()].name for n in meanwf],\n            index=spikes.keys(),\n        )\n\n        return meanwf, maxch\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.load_data","title":"load_data","text":"<pre><code>load_data(path)\n</code></pre> <p>Load NWB data saved with pynapple in the pynapplenwb folder</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session folder</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_data(self, path):\n    \"\"\"\n    Load NWB data saved with pynapple in the pynapplenwb folder\n\n    Parameters\n    ----------\n    path : str\n        Path to the session folder\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    position = {}\n    acq_keys = nwbfile.acquisition.keys()\n    if \"CompassDirection\" in acq_keys:\n        compass = nwbfile.acquisition[\"CompassDirection\"]\n        for k in compass.spatial_series.keys():\n            position[k] = pd.Series(\n                index=compass.get_spatial_series(k).timestamps[:],\n                data=compass.get_spatial_series(k).data[:],\n            )\n    if \"Position\" in acq_keys:\n        tracking = nwbfile.acquisition[\"Position\"]\n        for k in tracking.spatial_series.keys():\n            position[k] = pd.Series(\n                index=tracking.get_spatial_series(k).timestamps[:],\n                data=tracking.get_spatial_series(k).data[:],\n            )\n    if len(position):\n        position = pd.DataFrame.from_dict(position)\n\n        # retrieveing time support position if in epochs\n        if \"position_time_support\" in nwbfile.intervals.keys():\n            epochs = nwbfile.intervals[\"position_time_support\"].to_dataframe()\n            time_support = nap.IntervalSet(\n                start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n            )\n\n        self.position = nap.TsdFrame(\n            position, time_units=\"s\", time_support=time_support\n        )\n\n    if nwbfile.epochs is not None:\n        epochs = nwbfile.epochs.to_dataframe()\n        # NWB is dumb and cannot take a single string for labels\n        epochs[\"label\"] = [epochs.loc[i, \"tags\"][0] for i in epochs.index]\n        epochs = epochs.drop(labels=\"tags\", axis=1)\n        epochs = epochs.rename(columns={\"start_time\": \"start\", \"stop_time\": \"end\"})\n        self.epochs = self._make_epochs(epochs)\n\n        self.time_support = self._join_epochs(epochs, \"s\")\n\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.save_nwb_intervals","title":"save_nwb_intervals","text":"<pre><code>save_nwb_intervals(iset, name, description='')\n</code></pre> <p>Add epochs to the NWB file (e.g. ripples epochs) See pynwb.epoch.TimeIntervals</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>The intervalSet to save</p> required <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_intervals(self, iset, name, description=\"\"):\n    \"\"\"\n    Add epochs to the NWB file (e.g. ripples epochs)\n    See pynwb.epoch.TimeIntervals\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        The intervalSet to save\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    epochs = iset.as_units(\"s\")\n    time_intervals = TimeIntervals(name=name, description=description)\n    for i in epochs.index:\n        time_intervals.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n\n    nwbfile.add_time_intervals(time_intervals)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.save_nwb_timeseries","title":"save_nwb_timeseries","text":"<pre><code>save_nwb_timeseries(tsd, name, description='')\n</code></pre> <p>Save timestamps in the NWB file (e.g. ripples time) with the time support. See pynwb.base.TimeSeries</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>TsdFrame</code> <p>_</p> required <code>name</code> <code>str</code> <p>_</p> required <code>description</code> <code>str</code> <p>_</p> <code>''</code> Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_timeseries(self, tsd, name, description=\"\"):\n    \"\"\"\n    Save timestamps in the NWB file (e.g. ripples time) with the time support.\n    See pynwb.base.TimeSeries\n\n\n    Parameters\n    ----------\n    tsd : TsdFrame\n        _\n    name : str\n        _\n    description : str, optional\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    ts = TimeSeries(\n        name=name,\n        unit=\"s\",\n        data=tsd.values,\n        timestamps=tsd.as_units(\"s\").index.values,\n    )\n\n    time_support = TimeIntervals(\n        name=name + \"_timesupport\", description=\"The time support of the object\"\n    )\n\n    epochs = tsd.time_support.as_units(\"s\")\n    for i in epochs.index:\n        time_support.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n    nwbfile.add_time_intervals(time_support)\n    nwbfile.add_acquisition(ts)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.load_nwb_intervals","title":"load_nwb_intervals","text":"<pre><code>load_nwb_intervals(name)\n</code></pre> <p>Load epochs from the NWB file (e.g. 'ripples')</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_intervals(self, name):\n    \"\"\"\n    Load epochs from the NWB file (e.g. 'ripples')\n\n    Parameters\n    ----------\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if name in nwbfile.intervals.keys():\n        epochs = nwbfile.intervals[name].to_dataframe()\n        isets = nap.IntervalSet(\n            start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n        )\n        io.close()\n        return isets\n    else:\n        io.close()\n    return\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.load_nwb_timeseries","title":"load_nwb_timeseries","text":"<pre><code>load_nwb_timeseries(name)\n</code></pre> <p>Load timestamps in the NWB file (e.g. ripples time)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>_</p> required <p>Returns:</p> Type Description <code>Tsd</code> <p>_</p> Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_timeseries(self, name):\n    \"\"\"\n    Load timestamps in the NWB file (e.g. ripples time)\n\n    Parameters\n    ----------\n    name : str\n        _\n\n    Returns\n    -------\n    Tsd\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    ts = nwbfile.acquisition[name]\n\n    time_support = self.load_nwb_intervals(name + \"_timesupport\")\n\n    tsd = nap.Tsd(\n        t=ts.timestamps[:], d=ts.data[:], time_units=\"s\", time_support=time_support\n    )\n\n    io.close()\n\n    return tsd\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Instantiate the data class from a neurosuite folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the data.</p> required Source code in <code>pynapple/io/neurosuite.py</code> <pre><code>def __init__(self, path):\n    \"\"\"\n    Instantiate the data class from a neurosuite folder.\n\n    Parameters\n    ----------\n    path : str\n        The path to the data.\n    \"\"\"\n    self.basename = os.path.basename(path)\n    self.time_support = None\n\n    super().__init__(path)\n\n    self.load_nwb_spikes(path)\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.load_nwb_spikes","title":"load_nwb_spikes","text":"<pre><code>load_nwb_spikes(path)\n</code></pre> <p>Read the NWB spikes to extract the spike times.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the data</p> required <p>Returns:</p> Type Description <code>TYPE</code> <p>Description</p> Source code in <code>pynapple/io/neurosuite.py</code> <pre><code>def load_nwb_spikes(self, path):\n    \"\"\"\n    Read the NWB spikes to extract the spike times.\n\n    Parameters\n    ----------\n    path : str\n        The path to the data\n\n    Returns\n    -------\n    TYPE\n        Description\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if nwbfile.units is None:\n        io.close()\n        return False\n    else:\n        units = nwbfile.units.to_dataframe()\n        spikes = {\n            n: nap.Ts(t=units.loc[n, \"spike_times\"], time_units=\"s\")\n            for n in units.index\n        }\n\n        self.spikes = nap.TsGroup(\n            spikes,\n            time_support=self.time_support,\n            time_units=\"s\",\n            group=units[\"group\"],\n        )\n\n        if ~np.all(units[\"location\"] == \"\"):\n            self.spikes.set_info(location=units[\"location\"])\n\n        io.close()\n        return True\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.load_lfp","title":"load_lfp","text":"<pre><code>load_lfp(\n    filename=None,\n    channel=None,\n    extension=\".eeg\",\n    frequency=1250.0,\n    precision=\"int16\",\n    bytes_size=2,\n)\n</code></pre> <p>Load the LFP.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the lfp file. It can be useful it multiple dat files are present in the data directory</p> <code>None</code> <code>channel</code> <code>int or list of int</code> <p>The channel(s) to load. If None return a memory map of the dat file to avoid memory error</p> <code>None</code> <code>extension</code> <code>str</code> <p>The file extenstion (.eeg, .dat, .lfp). Make sure the frequency match</p> <code>'.eeg'</code> <code>frequency</code> <code>float</code> <p>Default 1250 Hz for the eeg file</p> <code>1250.0</code> <code>precision</code> <code>str</code> <p>The precision of the binary file</p> <code>'int16'</code> <code>bytes_size</code> <code>int</code> <p>Bytes size of the lfp file</p> <code>2</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If can't find the lfp/eeg/dat file</p> <p>Returns:</p> Type Description <code>Tsd or TsdFrame</code> <p>The lfp in a time series format</p> Source code in <code>pynapple/io/neurosuite.py</code> <pre><code>def load_lfp(\n    self,\n    filename=None,\n    channel=None,\n    extension=\".eeg\",\n    frequency=1250.0,\n    precision=\"int16\",\n    bytes_size=2,\n):\n    \"\"\"\n    Load the LFP.\n\n    Parameters\n    ----------\n    filename : str, optional\n        The filename of the lfp file.\n        It can be useful it multiple dat files are present in the data directory\n    channel : int or list of int, optional\n        The channel(s) to load. If None return a memory map of the dat file to avoid memory error\n    extension : str, optional\n        The file extenstion (.eeg, .dat, .lfp). Make sure the frequency match\n    frequency : float, optional\n        Default 1250 Hz for the eeg file\n    precision : str, optional\n        The precision of the binary file\n    bytes_size : int, optional\n        Bytes size of the lfp file\n\n    Raises\n    ------\n    RuntimeError\n        If can't find the lfp/eeg/dat file\n\n    Returns\n    -------\n    Tsd or TsdFrame\n        The lfp in a time series format\n    \"\"\"\n    if filename is not None:\n        filepath = os.path.join(self.path, filename)\n    else:\n        listdir = os.listdir(self.path)\n        eegfile = [f for f in listdir if f.endswith(extension)]\n        if not len(eegfile):\n            raise RuntimeError(\n                \"Path {} contains no {} files;\".format(self.path, extension)\n            )\n\n        filepath = os.path.join(self.path, eegfile[0])\n\n    self.load_neurosuite_xml(self.path)\n\n    n_channels = int(self.nChannels)\n\n    f = open(filepath, \"rb\")\n    startoffile = f.seek(0, 0)\n    endoffile = f.seek(0, 2)\n    bytes_size = 2\n    n_samples = int((endoffile - startoffile) / n_channels / bytes_size)\n    duration = n_samples / frequency\n    f.close()\n    fp = np.memmap(filepath, np.int16, \"r\", shape=(n_samples, n_channels))\n    timestep = np.arange(0, n_samples) / frequency\n\n    time_support = nap.IntervalSet(start=0, end=duration, time_units=\"s\")\n\n    if channel is None:\n        return nap.TsdFrame(\n            t=timestep, d=fp, time_units=\"s\", time_support=time_support\n        )\n    elif type(channel) is int:\n        return nap.Tsd(\n            t=timestep, d=fp[:, channel], time_units=\"s\", time_support=time_support\n        )\n    elif type(channel) is list:\n        return nap.TsdFrame(\n            t=timestep,\n            d=fp[:, channel],\n            time_units=\"s\",\n            time_support=time_support,\n            columns=channel,\n        )\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.read_neuroscope_intervals","title":"read_neuroscope_intervals","text":"<pre><code>read_neuroscope_intervals(name=None, path2file=None)\n</code></pre> <p>This function reads .evt files in which odd raws indicate the beginning of the time series and the even raws are the ends. If the file is present in the nwb, provide the just the name. If the file is not present in the nwb, it loads the events from the nwb directory. If just the path is provided but not the name, it takes the name from the file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>name of the epoch in the nwb file, e.g. \"rem\" or desired name save the data in the nwb.</p> <code>None</code> <p>path2file: str     Path of the file you want to load.</p> <p>Returns:</p> Type Description <code>IntervalSet</code> <p>Contains two columns corresponding to the start and end of the intervals.</p> Source code in <code>pynapple/io/neurosuite.py</code> <pre><code>def read_neuroscope_intervals(self, name=None, path2file=None):\n    \"\"\"\n    This function reads .evt files in which odd raws indicate the beginning\n    of the time series and the even raws are the ends.\n    If the file is present in the nwb, provide the just the name. If the file\n    is not present in the nwb, it loads the events from the nwb directory.\n    If just the path is provided but not the name, it takes the name from the file.\n\n    Parameters\n    ----------\n    name: str\n        name of the epoch in the nwb file, e.g. \"rem\" or desired name save\n        the data in the nwb.\n\n    path2file: str\n        Path of the file you want to load.\n\n    Returns\n    -------\n    IntervalSet\n        Contains two columns corresponding to the start and end of the intervals.\n\n    \"\"\"\n    if name:\n        isets = self.load_nwb_intervals(name)\n        if isinstance(isets, nap.IntervalSet):\n            return isets\n    if name is not None and path2file is None:\n        path2file = os.path.join(self.path, self.basename + \".\" + name + \".evt\")\n    if path2file is not None:\n        try:\n            # df = pd.read_csv(path2file, delimiter=' ', usecols = [0], header = None)\n            tmp = np.genfromtxt(path2file)[:, 0]\n            df = tmp.reshape(len(tmp) // 2, 2)\n        except ValueError:\n            print(\"specify a valid name\")\n        isets = nap.IntervalSet(df[:, 0], df[:, 1], time_units=\"ms\")\n        if name is None:\n            name = path2file.split(\".\")[-2]\n            print(\"*** saving file in the nwb as\", name)\n        self.save_nwb_intervals(isets, name)\n    else:\n        raise ValueError(\"specify a valid path\")\n    return isets\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.write_neuroscope_intervals","title":"write_neuroscope_intervals","text":"<pre><code>write_neuroscope_intervals(extension, isets, name)\n</code></pre> <p>Write events to load with neuroscope (e.g. ripples start and ends)</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The extension of the file (e.g. basename.evt.py.rip)</p> required <code>isets</code> <code>IntervalSet</code> <p>The IntervalSet to write</p> required <code>name</code> <code>str</code> <p>The name of the events (e.g. Ripples)</p> required Source code in <code>pynapple/io/neurosuite.py</code> <pre><code>def write_neuroscope_intervals(self, extension, isets, name):\n    \"\"\"Write events to load with neuroscope (e.g. ripples start and ends)\n\n    Parameters\n    ----------\n    extension : str\n        The extension of the file (e.g. basename.evt.py.rip)\n    isets : IntervalSet\n        The IntervalSet to write\n    name : str\n        The name of the events (e.g. Ripples)\n    \"\"\"\n    start = isets.as_units(\"ms\")[\"start\"].values\n    ends = isets.as_units(\"ms\")[\"end\"].values\n\n    datatowrite = np.vstack((start, ends)).T.flatten()\n\n    n = len(isets)\n\n    texttowrite = np.vstack(\n        (\n            (np.repeat(np.array([name + \" start\"]), n)),\n            (np.repeat(np.array([name + \" end\"]), n)),\n        )\n    ).T.flatten()\n\n    evt_file = os.path.join(self.path, self.basename + extension)\n\n    f = open(evt_file, \"w\")\n    for t, n in zip(datatowrite, texttowrite):\n        f.writelines(\"{:1.6f}\".format(t) + \"\\t\" + n + \"\\n\")\n    f.close()\n\n    return\n</code></pre>"},{"location":"reference/io/neurosuite/#pynapple.io.neurosuite.NeuroSuite.load_mean_waveforms","title":"load_mean_waveforms","text":"<pre><code>load_mean_waveforms(\n    epoch=None, waveform_window=None, spike_count=1000\n)\n</code></pre> <p>Load the mean waveforms from a dat file.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>IntervalSet</code> <p>default = None Restrict spikes to an epoch.</p> <code>None</code> <code>waveform_window</code> <code>IntervalSet</code> <p>default interval nap.IntervalSet(start = -0.0005, end = 0.001, time_units = 'ms') Limit waveform extraction before and after spike time</p> <code>None</code> <code>spike_count</code> <code>int</code> <p>default = 1000 Number of spikes used per neuron for the calculation of waveforms</p> <code>1000</code> <p>Returns:</p> Type Description <code>dictionary</code> <p>the waveforms for all neurons</p> <code>Series</code> <p>the channel with the maximum waveform for each neuron</p> Source code in <code>pynapple/io/neurosuite.py</code> <pre><code>def load_mean_waveforms(self, epoch=None, waveform_window=None, spike_count=1000):\n    \"\"\"\n    Load the mean waveforms from a dat file.\n\n    Parameters\n    ----------\n    epoch : IntervalSet\n        default = None\n        Restrict spikes to an epoch.\n    waveform_window : IntervalSet\n        default interval nap.IntervalSet(start = -0.0005, end = 0.001, time_units = 'ms')\n        Limit waveform extraction before and after spike time\n    spike_count : int\n        default = 1000\n        Number of spikes used per neuron for the calculation of waveforms\n\n    Returns\n    -------\n    dictionary\n        the waveforms for all neurons\n    pandas.Series\n        the channel with the maximum waveform for each neuron\n\n    \"\"\"\n    if not isinstance(waveform_window, nap.IntervalSet):\n        waveform_window = nap.IntervalSet(start=-0.5, end=1, time_units=\"ms\")\n\n    spikes = self.spikes\n    if not os.path.exists(self.path):  # check if path exists\n        print(\"The path \" + self.path + \" doesn't exist; Exiting ...\")\n        sys.exit()\n\n    # Load XML INFO\n    self.load_neurosuite_xml(self.path)\n    n_channels = self.nChannels\n    fs = self.fs_dat\n    group_to_channel = self.group_to_channel\n    group = spikes.get_info(\"group\")\n\n    # Check if there is an epoch, restrict spike times to epoch\n    if epoch is not None:\n        if type(epoch) is not nap.IntervalSet:\n            print(\"Epoch must be an IntervalSet\")\n            sys.exit()\n        else:\n            print(\"Restricting spikes to epoch\")\n            spikes = spikes.restrict(epoch)\n            epstart = int(epoch.as_units(\"s\")[\"start\"].values[0] * fs)\n            epend = int(epoch.as_units(\"s\")[\"end\"].values[0] * fs)\n\n    # Find dat file\n    files = os.listdir(self.path)\n    dat_files = np.sort([f for f in files if \"dat\" in f and f[0] != \".\"])\n\n    # Need n_samples collected in the entire recording from dat file to load\n    file = os.path.join(self.path, dat_files[0])\n    f = open(\n        file, \"rb\"\n    )  # open file to get number of samples collected in the entire recording\n    startoffile = f.seek(0, 0)\n    endoffile = f.seek(0, 2)\n    bytes_size = 2\n    n_samples = int((endoffile - startoffile) / n_channels / bytes_size)\n    f.close()\n    # map to memory all samples for all channels, channels are numbered according to neuroscope number\n    fp = np.memmap(file, np.int16, \"r\", shape=(n_samples, n_channels))\n\n    # convert spike times to spikes in sample number\n    sample_spikes = {\n        neuron: (spikes[neuron].as_units(\"s\").index.values * fs).astype(\"int\")\n        for neuron in spikes\n    }\n\n    # prep for waveforms\n    overlap = int(\n        waveform_window.tot_length(time_units=\"s\")\n    )  # one spike's worth of overlap between windows\n    waveform_window = abs(np.array(waveform_window.as_units(\"s\"))[0] * fs).astype(\n        int\n    )  # convert time to sample number\n    neuron_waveforms = {\n        n: np.zeros([np.sum(waveform_window), len(group_to_channel[group[n]])])\n        for n in sample_spikes\n    }\n\n    # divide dat file into batches that slightly overlap for faster loading\n    batch_size = 3000000\n    windows = np.arange(0, int(endoffile / n_channels / bytes_size), batch_size)\n    if epoch is not None:\n        print(\"Restricting dat file to epoch\")\n        windows = windows[(windows &gt;= epstart) &amp; (windows &lt;= epend)]\n    batches = []\n    for (\n        i\n    ) in windows:  # make overlapping batches from the beginning to end of recording\n        if i == windows[-1]:  # the last batch cannot overlap with the next one\n            batches.append([i, n_samples])\n        else:\n            batches.append([i, i + batch_size + overlap])\n    batches = [np.int32(batch) for batch in batches]\n\n    sample_counted_spikes = {}\n    for index, neuron in enumerate(sample_spikes):\n        if len(sample_spikes[neuron]) &gt;= spike_count:\n            sample_counted_spikes[neuron] = np.array(\n                np.random.choice(list(sample_spikes[neuron]), spike_count)\n            )\n        elif len(sample_spikes[neuron]) &lt; spike_count:\n            print(\n                \"Not enough spikes in neuron \" + str(index) + \"... using all spikes\"\n            )\n            sample_counted_spikes[neuron] = sample_spikes[neuron]\n\n    # Make one array containing all selected spike times of all neurons - will be used to check for spikes before loading dat file\n    spike_check = np.array(\n        [\n            int(spikes_neuron)\n            for spikes_neuron in sample_counted_spikes[neuron]\n            for neuron in sample_counted_spikes\n        ]\n    )\n\n    for index, timestep in enumerate(batches):\n        print(\n            f\"Extracting waveforms from dat file: window {index+1} / {len(windows)}\",\n            end=\"\\r\",\n        )\n\n        if (\n            len(\n                spike_check[\n                    (timestep[0] &lt; spike_check) &amp; (timestep[1] &gt; spike_check)\n                ]\n            )\n            == 0\n        ):\n            continue  # if there are no spikes for any neurons in this batch, skip and go to the next one\n\n        # Load dat file for timestep\n        tmp = pd.DataFrame(\n            data=fp[timestep[0] : timestep[1], :],\n            columns=np.arange(n_channels),\n            index=range(timestep[0], timestep[1]),\n        )  # load dat file\n\n        # Check if any spikes are present\n        for neuron in sample_counted_spikes:\n            neurontmp = sample_counted_spikes[neuron]\n            tmp2 = neurontmp[(timestep[0] &lt; neurontmp) &amp; (timestep[1] &gt; neurontmp)]\n            if len(neurontmp) == 0:\n                continue  # skip neuron if it has no spikes in this batch\n            tmpn = tmp[\n                group_to_channel[group[neuron]]\n            ]  # restrict dat file to the channel group of the neuron\n\n            for time in tmp2:  # add each spike waveform to neuron_waveform\n                spikewindow = tmpn.loc[\n                    time - waveform_window[0] : time + waveform_window[1] - 1\n                ]  # waveform for this spike time\n                try:\n                    neuron_waveforms[neuron] += spikewindow.values\n                except (\n                    Exception\n                ):  # ignore if full waveform is not present in this batch\n                    pass\n\n    meanwf = {\n        n: pd.DataFrame(\n            data=np.array(neuron_waveforms[n]) / spike_count,\n            columns=np.arange(len(group_to_channel[group[n]])),\n            index=np.array(np.arange(-waveform_window[0], waveform_window[1])) / fs,\n        )\n        for n in sample_counted_spikes\n    }\n\n    # find the max channel for each neuron\n    maxch = pd.Series(\n        data=[meanwf[n][meanwf[n].loc[0].idxmin()].name for n in meanwf],\n        index=spikes.keys(),\n    )\n\n    return meanwf, maxch\n</code></pre>"},{"location":"reference/io/phy/","title":"Phy","text":""},{"location":"reference/io/phy/#pynapple.io.phy","title":"pynapple.io.phy","text":"<p> DEPRECATED: This will be removed in version 1.0.0. Check nwbmatic or neuroconv instead.</p> <p>Class and functions for loading data processed with Phy2</p> <p>@author: Sara Mahallati, Guillaume Viejo</p>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy","title":"Phy","text":"<p>             Bases: <code>BaseLoader</code></p> <p>Loader for Phy data</p> Source code in <code>pynapple/io/phy.py</code> <pre><code>class Phy(BaseLoader):\n    \"\"\"\n    Loader for Phy data\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n        Instantiate the data class from a Phy folder.\n\n        Parameters\n        ----------\n        path : str or Path object\n            The path to the data.\n        \"\"\"\n        self.basename = os.path.basename(path)\n        self.time_support = None\n\n        super().__init__(path)\n\n        self.load_nwb_spikes(path)\n\n    def load_nwb_spikes(self, path):\n        \"\"\"Read the NWB spikes to extract the spike times.\n\n        Returns\n        -------\n        TYPE\n            Description\n        \"\"\"\n        self.nwb_path = os.path.join(path, \"pynapplenwb\")\n        if not os.path.exists(self.nwb_path):\n            raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n        self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n        self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n        io = NWBHDF5IO(self.nwbfilepath, \"r\")\n        nwbfile = io.read()\n\n        if nwbfile.units is None:\n            io.close()\n            return None\n        else:\n            units = nwbfile.units.to_dataframe()\n            spikes = {\n                n: nap.Ts(t=units.loc[n, \"spike_times\"], time_units=\"s\")\n                for n in units.index\n            }\n\n            self.spikes = nap.TsGroup(\n                spikes,\n                time_support=self.time_support,\n                time_units=\"s\",\n                group=units[\"group\"],\n            )\n\n            if ~np.all(units[\"location\"] == \"\"):\n                self.spikes.set_info(location=units[\"location\"])\n\n            io.close()\n            return True\n\n    def load_lfp(\n        self,\n        filename=None,\n        channel=None,\n        extension=\".eeg\",\n        frequency=1250.0,\n        precision=\"int16\",\n        bytes_size=2,\n    ):\n        \"\"\"\n        Load the LFP.\n\n        Parameters\n        ----------\n        filename : str, optional\n            The filename of the lfp file.\n            It can be useful it multiple dat files are present in the data directory\n        channel : int or list of int, optional\n            The channel(s) to load. If None return a memory map of the dat file to avoid memory error\n        extension : str, optional\n            The file extenstion (.eeg, .dat, .lfp). Make sure the frequency match\n        frequency : float, optional\n            Default 1250 Hz for the eeg file\n        precision : str, optional\n            The precision of the binary file\n        bytes_size : int, optional\n            Bytes size of the lfp file\n\n        Raises\n        ------\n        RuntimeError\n            If can't find the lfp/eeg/dat file\n\n        Returns\n        -------\n        Tsd or TsdFrame\n            The lfp in a time series format\n        \"\"\"\n        if filename is not None:\n            filepath = self.path / filename\n        else:\n            try:\n                filepath = list(self.path.glob(f\"*{extension}\"))[0]\n            except IndexError:\n                raise RuntimeError(f\"Path {self.path} contains no {extension} files;\")\n\n        # is it possible that this is a leftover from neurosuite data?\n        # This is not implemented for this class.\n        self.load_neurosuite_xml(self.path)\n\n        n_channels = int(self.nChannels)\n\n        f = open(filepath, \"rb\")\n        startoffile = f.seek(0, 0)\n        endoffile = f.seek(0, 2)\n        bytes_size = 2\n        n_samples = int((endoffile - startoffile) / n_channels / bytes_size)\n        duration = n_samples / frequency\n        f.close()\n        fp = np.memmap(filepath, np.int16, \"r\", shape=(n_samples, n_channels))\n        timestep = np.arange(0, n_samples) / frequency\n\n        time_support = nap.IntervalSet(start=0, end=duration, time_units=\"s\")\n\n        if channel is None:\n            return nap.TsdFrame(\n                t=timestep, d=fp, time_units=\"s\", time_support=time_support\n            )\n        elif type(channel) is int:\n            return nap.Tsd(\n                t=timestep, d=fp[:, channel], time_units=\"s\", time_support=time_support\n            )\n        elif type(channel) is list:\n            return nap.TsdFrame(\n                t=timestep,\n                d=fp[:, channel],\n                time_units=\"s\",\n                time_support=time_support,\n                columns=channel,\n            )\n</code></pre>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy.load_data","title":"load_data","text":"<pre><code>load_data(path)\n</code></pre> <p>Load NWB data saved with pynapple in the pynapplenwb folder</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session folder</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_data(self, path):\n    \"\"\"\n    Load NWB data saved with pynapple in the pynapplenwb folder\n\n    Parameters\n    ----------\n    path : str\n        Path to the session folder\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    position = {}\n    acq_keys = nwbfile.acquisition.keys()\n    if \"CompassDirection\" in acq_keys:\n        compass = nwbfile.acquisition[\"CompassDirection\"]\n        for k in compass.spatial_series.keys():\n            position[k] = pd.Series(\n                index=compass.get_spatial_series(k).timestamps[:],\n                data=compass.get_spatial_series(k).data[:],\n            )\n    if \"Position\" in acq_keys:\n        tracking = nwbfile.acquisition[\"Position\"]\n        for k in tracking.spatial_series.keys():\n            position[k] = pd.Series(\n                index=tracking.get_spatial_series(k).timestamps[:],\n                data=tracking.get_spatial_series(k).data[:],\n            )\n    if len(position):\n        position = pd.DataFrame.from_dict(position)\n\n        # retrieveing time support position if in epochs\n        if \"position_time_support\" in nwbfile.intervals.keys():\n            epochs = nwbfile.intervals[\"position_time_support\"].to_dataframe()\n            time_support = nap.IntervalSet(\n                start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n            )\n\n        self.position = nap.TsdFrame(\n            position, time_units=\"s\", time_support=time_support\n        )\n\n    if nwbfile.epochs is not None:\n        epochs = nwbfile.epochs.to_dataframe()\n        # NWB is dumb and cannot take a single string for labels\n        epochs[\"label\"] = [epochs.loc[i, \"tags\"][0] for i in epochs.index]\n        epochs = epochs.drop(labels=\"tags\", axis=1)\n        epochs = epochs.rename(columns={\"start_time\": \"start\", \"stop_time\": \"end\"})\n        self.epochs = self._make_epochs(epochs)\n\n        self.time_support = self._join_epochs(epochs, \"s\")\n\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy.save_nwb_intervals","title":"save_nwb_intervals","text":"<pre><code>save_nwb_intervals(iset, name, description='')\n</code></pre> <p>Add epochs to the NWB file (e.g. ripples epochs) See pynwb.epoch.TimeIntervals</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>The intervalSet to save</p> required <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_intervals(self, iset, name, description=\"\"):\n    \"\"\"\n    Add epochs to the NWB file (e.g. ripples epochs)\n    See pynwb.epoch.TimeIntervals\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        The intervalSet to save\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    epochs = iset.as_units(\"s\")\n    time_intervals = TimeIntervals(name=name, description=description)\n    for i in epochs.index:\n        time_intervals.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n\n    nwbfile.add_time_intervals(time_intervals)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy.save_nwb_timeseries","title":"save_nwb_timeseries","text":"<pre><code>save_nwb_timeseries(tsd, name, description='')\n</code></pre> <p>Save timestamps in the NWB file (e.g. ripples time) with the time support. See pynwb.base.TimeSeries</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>TsdFrame</code> <p>_</p> required <code>name</code> <code>str</code> <p>_</p> required <code>description</code> <code>str</code> <p>_</p> <code>''</code> Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_timeseries(self, tsd, name, description=\"\"):\n    \"\"\"\n    Save timestamps in the NWB file (e.g. ripples time) with the time support.\n    See pynwb.base.TimeSeries\n\n\n    Parameters\n    ----------\n    tsd : TsdFrame\n        _\n    name : str\n        _\n    description : str, optional\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    ts = TimeSeries(\n        name=name,\n        unit=\"s\",\n        data=tsd.values,\n        timestamps=tsd.as_units(\"s\").index.values,\n    )\n\n    time_support = TimeIntervals(\n        name=name + \"_timesupport\", description=\"The time support of the object\"\n    )\n\n    epochs = tsd.time_support.as_units(\"s\")\n    for i in epochs.index:\n        time_support.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n    nwbfile.add_time_intervals(time_support)\n    nwbfile.add_acquisition(ts)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy.load_nwb_intervals","title":"load_nwb_intervals","text":"<pre><code>load_nwb_intervals(name)\n</code></pre> <p>Load epochs from the NWB file (e.g. 'ripples')</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_intervals(self, name):\n    \"\"\"\n    Load epochs from the NWB file (e.g. 'ripples')\n\n    Parameters\n    ----------\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if name in nwbfile.intervals.keys():\n        epochs = nwbfile.intervals[name].to_dataframe()\n        isets = nap.IntervalSet(\n            start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n        )\n        io.close()\n        return isets\n    else:\n        io.close()\n    return\n</code></pre>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy.load_nwb_timeseries","title":"load_nwb_timeseries","text":"<pre><code>load_nwb_timeseries(name)\n</code></pre> <p>Load timestamps in the NWB file (e.g. ripples time)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>_</p> required <p>Returns:</p> Type Description <code>Tsd</code> <p>_</p> Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_timeseries(self, name):\n    \"\"\"\n    Load timestamps in the NWB file (e.g. ripples time)\n\n    Parameters\n    ----------\n    name : str\n        _\n\n    Returns\n    -------\n    Tsd\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    ts = nwbfile.acquisition[name]\n\n    time_support = self.load_nwb_intervals(name + \"_timesupport\")\n\n    tsd = nap.Tsd(\n        t=ts.timestamps[:], d=ts.data[:], time_units=\"s\", time_support=time_support\n    )\n\n    io.close()\n\n    return tsd\n</code></pre>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Instantiate the data class from a Phy folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path object</code> <p>The path to the data.</p> required Source code in <code>pynapple/io/phy.py</code> <pre><code>def __init__(self, path):\n    \"\"\"\n    Instantiate the data class from a Phy folder.\n\n    Parameters\n    ----------\n    path : str or Path object\n        The path to the data.\n    \"\"\"\n    self.basename = os.path.basename(path)\n    self.time_support = None\n\n    super().__init__(path)\n\n    self.load_nwb_spikes(path)\n</code></pre>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy.load_nwb_spikes","title":"load_nwb_spikes","text":"<pre><code>load_nwb_spikes(path)\n</code></pre> <p>Read the NWB spikes to extract the spike times.</p> <p>Returns:</p> Type Description <code>TYPE</code> <p>Description</p> Source code in <code>pynapple/io/phy.py</code> <pre><code>def load_nwb_spikes(self, path):\n    \"\"\"Read the NWB spikes to extract the spike times.\n\n    Returns\n    -------\n    TYPE\n        Description\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if nwbfile.units is None:\n        io.close()\n        return None\n    else:\n        units = nwbfile.units.to_dataframe()\n        spikes = {\n            n: nap.Ts(t=units.loc[n, \"spike_times\"], time_units=\"s\")\n            for n in units.index\n        }\n\n        self.spikes = nap.TsGroup(\n            spikes,\n            time_support=self.time_support,\n            time_units=\"s\",\n            group=units[\"group\"],\n        )\n\n        if ~np.all(units[\"location\"] == \"\"):\n            self.spikes.set_info(location=units[\"location\"])\n\n        io.close()\n        return True\n</code></pre>"},{"location":"reference/io/phy/#pynapple.io.phy.Phy.load_lfp","title":"load_lfp","text":"<pre><code>load_lfp(\n    filename=None,\n    channel=None,\n    extension=\".eeg\",\n    frequency=1250.0,\n    precision=\"int16\",\n    bytes_size=2,\n)\n</code></pre> <p>Load the LFP.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the lfp file. It can be useful it multiple dat files are present in the data directory</p> <code>None</code> <code>channel</code> <code>int or list of int</code> <p>The channel(s) to load. If None return a memory map of the dat file to avoid memory error</p> <code>None</code> <code>extension</code> <code>str</code> <p>The file extenstion (.eeg, .dat, .lfp). Make sure the frequency match</p> <code>'.eeg'</code> <code>frequency</code> <code>float</code> <p>Default 1250 Hz for the eeg file</p> <code>1250.0</code> <code>precision</code> <code>str</code> <p>The precision of the binary file</p> <code>'int16'</code> <code>bytes_size</code> <code>int</code> <p>Bytes size of the lfp file</p> <code>2</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If can't find the lfp/eeg/dat file</p> <p>Returns:</p> Type Description <code>Tsd or TsdFrame</code> <p>The lfp in a time series format</p> Source code in <code>pynapple/io/phy.py</code> <pre><code>def load_lfp(\n    self,\n    filename=None,\n    channel=None,\n    extension=\".eeg\",\n    frequency=1250.0,\n    precision=\"int16\",\n    bytes_size=2,\n):\n    \"\"\"\n    Load the LFP.\n\n    Parameters\n    ----------\n    filename : str, optional\n        The filename of the lfp file.\n        It can be useful it multiple dat files are present in the data directory\n    channel : int or list of int, optional\n        The channel(s) to load. If None return a memory map of the dat file to avoid memory error\n    extension : str, optional\n        The file extenstion (.eeg, .dat, .lfp). Make sure the frequency match\n    frequency : float, optional\n        Default 1250 Hz for the eeg file\n    precision : str, optional\n        The precision of the binary file\n    bytes_size : int, optional\n        Bytes size of the lfp file\n\n    Raises\n    ------\n    RuntimeError\n        If can't find the lfp/eeg/dat file\n\n    Returns\n    -------\n    Tsd or TsdFrame\n        The lfp in a time series format\n    \"\"\"\n    if filename is not None:\n        filepath = self.path / filename\n    else:\n        try:\n            filepath = list(self.path.glob(f\"*{extension}\"))[0]\n        except IndexError:\n            raise RuntimeError(f\"Path {self.path} contains no {extension} files;\")\n\n    # is it possible that this is a leftover from neurosuite data?\n    # This is not implemented for this class.\n    self.load_neurosuite_xml(self.path)\n\n    n_channels = int(self.nChannels)\n\n    f = open(filepath, \"rb\")\n    startoffile = f.seek(0, 0)\n    endoffile = f.seek(0, 2)\n    bytes_size = 2\n    n_samples = int((endoffile - startoffile) / n_channels / bytes_size)\n    duration = n_samples / frequency\n    f.close()\n    fp = np.memmap(filepath, np.int16, \"r\", shape=(n_samples, n_channels))\n    timestep = np.arange(0, n_samples) / frequency\n\n    time_support = nap.IntervalSet(start=0, end=duration, time_units=\"s\")\n\n    if channel is None:\n        return nap.TsdFrame(\n            t=timestep, d=fp, time_units=\"s\", time_support=time_support\n        )\n    elif type(channel) is int:\n        return nap.Tsd(\n            t=timestep, d=fp[:, channel], time_units=\"s\", time_support=time_support\n        )\n    elif type(channel) is list:\n        return nap.TsdFrame(\n            t=timestep,\n            d=fp[:, channel],\n            time_units=\"s\",\n            time_support=time_support,\n            columns=channel,\n        )\n</code></pre>"},{"location":"reference/io/suite2p/","title":"Suite2p","text":""},{"location":"reference/io/suite2p/#pynapple.io.suite2p","title":"pynapple.io.suite2p","text":"<p> DEPRECATED: This will be removed in version 1.0.0. Check nwbmatic or neuroconv instead.</p> <p>Loader for Suite2P https://github.com/MouseLand/suite2p</p>"},{"location":"reference/io/suite2p/#pynapple.io.suite2p.Suite2P","title":"Suite2P","text":"<p>             Bases: <code>BaseLoader</code></p> <p>Loader for data processed with Suite2P.</p> <p>Pynapple will try to look for data in this order :</p> <ol> <li> <p>pynapplenwb/session_name.nwb</p> </li> <li> <p>suite2p/plane/.npy</p> </li> </ol> <p>Attributes:</p> Name Type Description <code>F</code> <code>TsdFrame</code> <p>Fluorescence traces (timepoints x ROIs) for all planes</p> <code>Fneu</code> <code>TsdFrame</code> <p>Neuropil fluorescence traces (timepoints x ROIs) for all planes</p> <code>spks</code> <code>TsdFrame</code> <p>Deconvolved traces (timepoints x ROIS) for all planes</p> <code>plane_info</code> <code>DataFrame</code> <p>Contains plane identity of each cell</p> <code>stats</code> <code>dict</code> <p>dictionnay of statistics from stat.npy for each planes only for the neurons that were classified as cells (Can be smaller when loading from the NWB file)</p> <code>ops</code> <code>dict</code> <p>Parameters from Suite2p. (Can be smaller when loading from the NWB file)</p> <code>iscell</code> <code>ndarray</code> <p>Cell classification</p> Source code in <code>pynapple/io/suite2p.py</code> <pre><code>class Suite2P(BaseLoader):\n    \"\"\"Loader for data processed with Suite2P.\n\n    Pynapple will try to look for data in this order :\n\n    1. pynapplenwb/session_name.nwb\n\n    2. suite2p/plane*/*.npy\n\n\n    Attributes\n    ----------\n    F : TsdFrame\n        Fluorescence traces (timepoints x ROIs) for all planes\n    Fneu : TsdFrame\n        Neuropil fluorescence traces (timepoints x ROIs) for all planes\n    spks : TsdFrame\n        Deconvolved traces (timepoints x ROIS) for all planes\n    plane_info : pandas.DataFrame\n        Contains plane identity of each cell\n    stats : dict\n        dictionnay of statistics from stat.npy for each planes only for the neurons that were classified as cells\n        (Can be smaller when loading from the NWB file)\n    ops : dict\n        Parameters from Suite2p. (Can be smaller when loading from the NWB file)\n    iscell : numpy.ndarray\n        Cell classification\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n\n        Parameters\n        ----------\n        path : str\n            The path of the session\n        \"\"\"\n        self.basename = os.path.basename(path)\n\n        super().__init__(path)\n\n        self.load_suite2p_nwb(path)\n\n    def load_suite2p_nwb(self, path):\n        \"\"\"\n        Load suite2p data from NWB\n\n        Parameters\n        ----------\n        path : str\n            Path to the session\n        \"\"\"\n        self.nwb_path = os.path.join(path, \"pynapplenwb\")\n        if not os.path.exists(self.nwb_path):\n            raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n\n        self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n        self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n        io = NWBHDF5IO(self.nwbfilepath, \"r\")\n        nwbfile = io.read()\n\n        if \"ophys\" in nwbfile.processing.keys():\n            ophys = nwbfile.processing[\"ophys\"]\n\n            #################################################################\n            # STATS, OPS and ISCELL\n            #################################################################\n            dims = nwbfile.acquisition[\"TwoPhotonSeries\"].dimension[:]\n            self.ops = {\"Ly\": dims[0], \"Lx\": dims[1]}\n            self.rate = nwbfile.acquisition[\n                \"TwoPhotonSeries\"\n            ].imaging_plane.imaging_rate\n\n            self.stats = {0: {}}\n            self.iscell = ophys[\"ImageSegmentation\"][\"PlaneSegmentation\"][\n                \"iscell\"\n            ].data[:]\n\n            info = pd.DataFrame(\n                data=self.iscell[:, 0].astype(\"int\"), columns=[\"iscell\"]\n            )\n\n            #################################################################\n            # ROIS\n            #################################################################\n            try:\n                rois = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n                    \"PlaneSegmentation\"\n                ][\"pixel_mask\"]\n                multiplane = False\n            except Exception:\n                rois = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n                    \"PlaneSegmentation\"\n                ][\"voxel_mask\"]\n                multiplane = True\n\n            idx = np.where(self.iscell[:, 0])[0]\n            info[\"plane\"] = 0\n\n            for n in range(len(rois)):\n                roi = pd.DataFrame(rois[n])\n                if \"z\" in roi.columns:\n                    pl = roi[\"z\"][0]\n                else:\n                    pl = 0\n\n                info.loc[n, \"plane\"] = pl\n\n                if pl not in self.stats.keys():\n                    self.stats[pl] = {}\n\n                if n in idx:\n                    self.stats[pl][n] = {\n                        \"xpix\": roi[\"y\"].values,\n                        \"ypix\": roi[\"x\"].values,\n                        \"lam\": roi[\"weight\"].values,\n                    }\n\n            #################################################################\n            # Time Series\n            #################################################################\n            fields = np.intersect1d(\n                [\"Fluorescence\", \"Neuropil\", \"Deconvolved\"],\n                list(ophys.fields[\"data_interfaces\"].keys()),\n            )\n\n            if len(fields) == 0:\n                print(\n                    \"No \" + \" or \".join([\"Fluorescence\", \"Neuropil\", \"Deconvolved\"]),\n                    \"found in nwb {}\".format(self.nwbfilepath),\n                )\n                return False\n\n            keys = ophys[fields[0]].roi_response_series.keys()\n\n            planes = [int(k[-1]) for k in keys if \"plane\" in k]\n\n            data = {}\n\n            if multiplane:\n                keys = ophys[fields[0]].roi_response_series.keys()\n                planes = [int(k[-1]) for k in keys if \"plane\" in k]\n            else:\n                planes = [0]\n\n            for k, name in zip(\n                [\"F\", \"Fneu\", \"spks\"], [\"Fluorescence\", \"Neuropil\", \"Deconvolved\"]\n            ):\n                tmp = []\n                timestamps = []\n\n                for i, n in enumerate(planes):\n                    if multiplane:\n                        pl = \"plane{}\".format(n)\n                    else:\n                        pl = name  # This doesn't make sense\n\n                    tokeep = info[\"iscell\"][info[\"plane\"] == n].values == 1\n\n                    d = np.transpose(ophys[name][pl].data[:][tokeep])\n\n                    if ophys[name][pl].timestamps is not None:\n                        t = ophys[name][pl].timestamps[:]\n                    else:\n                        t = (np.arange(0, len(d)) / self.rate) + ophys[name][\n                            pl\n                        ].starting_time\n\n                    tmp.append(d)\n                    timestamps.append(t)\n\n                data[k] = nap.TsdFrame(t=timestamps[0], d=np.hstack(tmp))\n\n            if \"F\" in data.keys():\n                self.F = data[\"F\"]\n            if \"Fneu\" in data.keys():\n                self.Fneu = data[\"Fneu\"]\n            if \"spks\" in data.keys():\n                self.spks = data[\"spks\"]\n\n            self.plane_info = pd.DataFrame(\n                data=info[\"plane\"][info[\"iscell\"] == 1].values, columns=[\"plane\"]\n            )\n\n            io.close()\n            return True\n        else:\n            io.close()\n            return False\n</code></pre>"},{"location":"reference/io/suite2p/#pynapple.io.suite2p.Suite2P.load_data","title":"load_data","text":"<pre><code>load_data(path)\n</code></pre> <p>Load NWB data saved with pynapple in the pynapplenwb folder</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session folder</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_data(self, path):\n    \"\"\"\n    Load NWB data saved with pynapple in the pynapplenwb folder\n\n    Parameters\n    ----------\n    path : str\n        Path to the session folder\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    position = {}\n    acq_keys = nwbfile.acquisition.keys()\n    if \"CompassDirection\" in acq_keys:\n        compass = nwbfile.acquisition[\"CompassDirection\"]\n        for k in compass.spatial_series.keys():\n            position[k] = pd.Series(\n                index=compass.get_spatial_series(k).timestamps[:],\n                data=compass.get_spatial_series(k).data[:],\n            )\n    if \"Position\" in acq_keys:\n        tracking = nwbfile.acquisition[\"Position\"]\n        for k in tracking.spatial_series.keys():\n            position[k] = pd.Series(\n                index=tracking.get_spatial_series(k).timestamps[:],\n                data=tracking.get_spatial_series(k).data[:],\n            )\n    if len(position):\n        position = pd.DataFrame.from_dict(position)\n\n        # retrieveing time support position if in epochs\n        if \"position_time_support\" in nwbfile.intervals.keys():\n            epochs = nwbfile.intervals[\"position_time_support\"].to_dataframe()\n            time_support = nap.IntervalSet(\n                start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n            )\n\n        self.position = nap.TsdFrame(\n            position, time_units=\"s\", time_support=time_support\n        )\n\n    if nwbfile.epochs is not None:\n        epochs = nwbfile.epochs.to_dataframe()\n        # NWB is dumb and cannot take a single string for labels\n        epochs[\"label\"] = [epochs.loc[i, \"tags\"][0] for i in epochs.index]\n        epochs = epochs.drop(labels=\"tags\", axis=1)\n        epochs = epochs.rename(columns={\"start_time\": \"start\", \"stop_time\": \"end\"})\n        self.epochs = self._make_epochs(epochs)\n\n        self.time_support = self._join_epochs(epochs, \"s\")\n\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/suite2p/#pynapple.io.suite2p.Suite2P.save_nwb_intervals","title":"save_nwb_intervals","text":"<pre><code>save_nwb_intervals(iset, name, description='')\n</code></pre> <p>Add epochs to the NWB file (e.g. ripples epochs) See pynwb.epoch.TimeIntervals</p> <p>Parameters:</p> Name Type Description Default <code>iset</code> <code>IntervalSet</code> <p>The intervalSet to save</p> required <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_intervals(self, iset, name, description=\"\"):\n    \"\"\"\n    Add epochs to the NWB file (e.g. ripples epochs)\n    See pynwb.epoch.TimeIntervals\n\n    Parameters\n    ----------\n    iset : IntervalSet\n        The intervalSet to save\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    epochs = iset.as_units(\"s\")\n    time_intervals = TimeIntervals(name=name, description=description)\n    for i in epochs.index:\n        time_intervals.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n\n    nwbfile.add_time_intervals(time_intervals)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/suite2p/#pynapple.io.suite2p.Suite2P.save_nwb_timeseries","title":"save_nwb_timeseries","text":"<pre><code>save_nwb_timeseries(tsd, name, description='')\n</code></pre> <p>Save timestamps in the NWB file (e.g. ripples time) with the time support. See pynwb.base.TimeSeries</p> <p>Parameters:</p> Name Type Description Default <code>tsd</code> <code>TsdFrame</code> <p>_</p> required <code>name</code> <code>str</code> <p>_</p> required <code>description</code> <code>str</code> <p>_</p> <code>''</code> Source code in <code>pynapple/io/loader.py</code> <pre><code>def save_nwb_timeseries(self, tsd, name, description=\"\"):\n    \"\"\"\n    Save timestamps in the NWB file (e.g. ripples time) with the time support.\n    See pynwb.base.TimeSeries\n\n\n    Parameters\n    ----------\n    tsd : TsdFrame\n        _\n    name : str\n        _\n    description : str, optional\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r+\")\n    nwbfile = io.read()\n\n    ts = TimeSeries(\n        name=name,\n        unit=\"s\",\n        data=tsd.values,\n        timestamps=tsd.as_units(\"s\").index.values,\n    )\n\n    time_support = TimeIntervals(\n        name=name + \"_timesupport\", description=\"The time support of the object\"\n    )\n\n    epochs = tsd.time_support.as_units(\"s\")\n    for i in epochs.index:\n        time_support.add_interval(\n            start_time=epochs.loc[i, \"start\"],\n            stop_time=epochs.loc[i, \"end\"],\n            tags=str(i),\n        )\n    nwbfile.add_time_intervals(time_support)\n    nwbfile.add_acquisition(ts)\n    io.write(nwbfile)\n    io.close()\n\n    return\n</code></pre>"},{"location":"reference/io/suite2p/#pynapple.io.suite2p.Suite2P.load_nwb_intervals","title":"load_nwb_intervals","text":"<pre><code>load_nwb_intervals(name)\n</code></pre> <p>Load epochs from the NWB file (e.g. 'ripples')</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name in the nwb file</p> required Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_intervals(self, name):\n    \"\"\"\n    Load epochs from the NWB file (e.g. 'ripples')\n\n    Parameters\n    ----------\n    name : str\n        The name in the nwb file\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if name in nwbfile.intervals.keys():\n        epochs = nwbfile.intervals[name].to_dataframe()\n        isets = nap.IntervalSet(\n            start=epochs[\"start_time\"], end=epochs[\"stop_time\"], time_units=\"s\"\n        )\n        io.close()\n        return isets\n    else:\n        io.close()\n    return\n</code></pre>"},{"location":"reference/io/suite2p/#pynapple.io.suite2p.Suite2P.load_nwb_timeseries","title":"load_nwb_timeseries","text":"<pre><code>load_nwb_timeseries(name)\n</code></pre> <p>Load timestamps in the NWB file (e.g. ripples time)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>_</p> required <p>Returns:</p> Type Description <code>Tsd</code> <p>_</p> Source code in <code>pynapple/io/loader.py</code> <pre><code>def load_nwb_timeseries(self, name):\n    \"\"\"\n    Load timestamps in the NWB file (e.g. ripples time)\n\n    Parameters\n    ----------\n    name : str\n        _\n\n    Returns\n    -------\n    Tsd\n        _\n    \"\"\"\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    ts = nwbfile.acquisition[name]\n\n    time_support = self.load_nwb_intervals(name + \"_timesupport\")\n\n    tsd = nap.Tsd(\n        t=ts.timestamps[:], d=ts.data[:], time_units=\"s\", time_support=time_support\n    )\n\n    io.close()\n\n    return tsd\n</code></pre>"},{"location":"reference/io/suite2p/#pynapple.io.suite2p.Suite2P.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the session</p> required Source code in <code>pynapple/io/suite2p.py</code> <pre><code>def __init__(self, path):\n    \"\"\"\n\n    Parameters\n    ----------\n    path : str\n        The path of the session\n    \"\"\"\n    self.basename = os.path.basename(path)\n\n    super().__init__(path)\n\n    self.load_suite2p_nwb(path)\n</code></pre>"},{"location":"reference/io/suite2p/#pynapple.io.suite2p.Suite2P.load_suite2p_nwb","title":"load_suite2p_nwb","text":"<pre><code>load_suite2p_nwb(path)\n</code></pre> <p>Load suite2p data from NWB</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the session</p> required Source code in <code>pynapple/io/suite2p.py</code> <pre><code>def load_suite2p_nwb(self, path):\n    \"\"\"\n    Load suite2p data from NWB\n\n    Parameters\n    ----------\n    path : str\n        Path to the session\n    \"\"\"\n    self.nwb_path = os.path.join(path, \"pynapplenwb\")\n    if not os.path.exists(self.nwb_path):\n        raise RuntimeError(\"Path {} does not exist.\".format(self.nwb_path))\n\n    self.nwbfilename = [f for f in os.listdir(self.nwb_path) if \"nwb\" in f][0]\n    self.nwbfilepath = os.path.join(self.nwb_path, self.nwbfilename)\n\n    io = NWBHDF5IO(self.nwbfilepath, \"r\")\n    nwbfile = io.read()\n\n    if \"ophys\" in nwbfile.processing.keys():\n        ophys = nwbfile.processing[\"ophys\"]\n\n        #################################################################\n        # STATS, OPS and ISCELL\n        #################################################################\n        dims = nwbfile.acquisition[\"TwoPhotonSeries\"].dimension[:]\n        self.ops = {\"Ly\": dims[0], \"Lx\": dims[1]}\n        self.rate = nwbfile.acquisition[\n            \"TwoPhotonSeries\"\n        ].imaging_plane.imaging_rate\n\n        self.stats = {0: {}}\n        self.iscell = ophys[\"ImageSegmentation\"][\"PlaneSegmentation\"][\n            \"iscell\"\n        ].data[:]\n\n        info = pd.DataFrame(\n            data=self.iscell[:, 0].astype(\"int\"), columns=[\"iscell\"]\n        )\n\n        #################################################################\n        # ROIS\n        #################################################################\n        try:\n            rois = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n                \"PlaneSegmentation\"\n            ][\"pixel_mask\"]\n            multiplane = False\n        except Exception:\n            rois = nwbfile.processing[\"ophys\"][\"ImageSegmentation\"][\n                \"PlaneSegmentation\"\n            ][\"voxel_mask\"]\n            multiplane = True\n\n        idx = np.where(self.iscell[:, 0])[0]\n        info[\"plane\"] = 0\n\n        for n in range(len(rois)):\n            roi = pd.DataFrame(rois[n])\n            if \"z\" in roi.columns:\n                pl = roi[\"z\"][0]\n            else:\n                pl = 0\n\n            info.loc[n, \"plane\"] = pl\n\n            if pl not in self.stats.keys():\n                self.stats[pl] = {}\n\n            if n in idx:\n                self.stats[pl][n] = {\n                    \"xpix\": roi[\"y\"].values,\n                    \"ypix\": roi[\"x\"].values,\n                    \"lam\": roi[\"weight\"].values,\n                }\n\n        #################################################################\n        # Time Series\n        #################################################################\n        fields = np.intersect1d(\n            [\"Fluorescence\", \"Neuropil\", \"Deconvolved\"],\n            list(ophys.fields[\"data_interfaces\"].keys()),\n        )\n\n        if len(fields) == 0:\n            print(\n                \"No \" + \" or \".join([\"Fluorescence\", \"Neuropil\", \"Deconvolved\"]),\n                \"found in nwb {}\".format(self.nwbfilepath),\n            )\n            return False\n\n        keys = ophys[fields[0]].roi_response_series.keys()\n\n        planes = [int(k[-1]) for k in keys if \"plane\" in k]\n\n        data = {}\n\n        if multiplane:\n            keys = ophys[fields[0]].roi_response_series.keys()\n            planes = [int(k[-1]) for k in keys if \"plane\" in k]\n        else:\n            planes = [0]\n\n        for k, name in zip(\n            [\"F\", \"Fneu\", \"spks\"], [\"Fluorescence\", \"Neuropil\", \"Deconvolved\"]\n        ):\n            tmp = []\n            timestamps = []\n\n            for i, n in enumerate(planes):\n                if multiplane:\n                    pl = \"plane{}\".format(n)\n                else:\n                    pl = name  # This doesn't make sense\n\n                tokeep = info[\"iscell\"][info[\"plane\"] == n].values == 1\n\n                d = np.transpose(ophys[name][pl].data[:][tokeep])\n\n                if ophys[name][pl].timestamps is not None:\n                    t = ophys[name][pl].timestamps[:]\n                else:\n                    t = (np.arange(0, len(d)) / self.rate) + ophys[name][\n                        pl\n                    ].starting_time\n\n                tmp.append(d)\n                timestamps.append(t)\n\n            data[k] = nap.TsdFrame(t=timestamps[0], d=np.hstack(tmp))\n\n        if \"F\" in data.keys():\n            self.F = data[\"F\"]\n        if \"Fneu\" in data.keys():\n            self.Fneu = data[\"Fneu\"]\n        if \"spks\" in data.keys():\n            self.spks = data[\"spks\"]\n\n        self.plane_info = pd.DataFrame(\n            data=info[\"plane\"][info[\"iscell\"] == 1].values, columns=[\"plane\"]\n        )\n\n        io.close()\n        return True\n    else:\n        io.close()\n        return False\n</code></pre>"},{"location":"reference/process/","title":"Process","text":"<ul> <li>correlograms</li> <li>decoding</li> <li>perievent</li> <li>randomize</li> <li>tuning_curves</li> </ul>"},{"location":"reference/process/correlograms/","title":"Correlograms","text":""},{"location":"reference/process/correlograms/#pynapple.process.correlograms","title":"pynapple.process.correlograms","text":""},{"location":"reference/process/correlograms/#pynapple.process.correlograms.cross_correlogram","title":"cross_correlogram","text":"<pre><code>cross_correlogram(t1, t2, binsize, windowsize)\n</code></pre> <p>Performs the discrete cross-correlogram of two time series. The units should be in s for all arguments. Return the firing rate of the series t2 relative to the timings of t1. See compute_crosscorrelogram, compute_autocorrelogram and compute_eventcorrelogram for wrappers of this function.</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <code>ndarray</code> <p>The timestamps of the reference time series (in seconds)</p> required <code>t2</code> <code>ndarray</code> <p>The timestamps of the target time series (in seconds)</p> required <code>binsize</code> <code>float</code> <p>The bin size (in seconds)</p> required <code>windowsize</code> <code>float</code> <p>The window size (in seconds)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The cross-correlogram</p> <code>ndarray</code> <p>Center of the bins (in s)</p> Source code in <code>pynapple/process/correlograms.py</code> <pre><code>@jit(nopython=True)\ndef cross_correlogram(t1, t2, binsize, windowsize):\n    \"\"\"\n    Performs the discrete cross-correlogram of two time series.\n    The units should be in s for all arguments.\n    Return the firing rate of the series t2 relative to the timings of t1.\n    See compute_crosscorrelogram, compute_autocorrelogram and compute_eventcorrelogram\n    for wrappers of this function.\n\n    Parameters\n    ----------\n    t1 : numpy.ndarray\n        The timestamps of the reference time series (in seconds)\n    t2 : numpy.ndarray\n        The timestamps of the target time series (in seconds)\n    binsize : float\n        The bin size (in seconds)\n    windowsize : float\n        The window size (in seconds)\n\n    Returns\n    -------\n    numpy.ndarray\n        The cross-correlogram\n    numpy.ndarray\n        Center of the bins (in s)\n\n    \"\"\"\n    # nbins = ((windowsize//binsize)*2)\n\n    nt1 = len(t1)\n    nt2 = len(t2)\n\n    nbins = int((windowsize * 2) // binsize)\n    if np.floor(nbins / 2) * 2 == nbins:\n        nbins = nbins + 1\n\n    w = (nbins / 2) * binsize\n    C = np.zeros(nbins)\n    i2 = 0\n\n    for i1 in range(nt1):\n        lbound = t1[i1] - w\n        while i2 &lt; nt2 and t2[i2] &lt; lbound:\n            i2 = i2 + 1\n        while i2 &gt; 0 and t2[i2 - 1] &gt; lbound:\n            i2 = i2 - 1\n\n        rbound = lbound\n        leftb = i2\n        for j in range(nbins):\n            k = 0\n            rbound = rbound + binsize\n            while leftb &lt; nt2 and t2[leftb] &lt; rbound:\n                leftb = leftb + 1\n                k = k + 1\n\n            C[j] += k\n\n    C = C / (nt1 * binsize)\n\n    m = -w + binsize / 2\n    B = np.zeros(nbins)\n    for j in range(nbins):\n        B[j] = m + j * binsize\n\n    return C, B\n</code></pre>"},{"location":"reference/process/correlograms/#pynapple.process.correlograms.compute_autocorrelogram","title":"compute_autocorrelogram","text":"<pre><code>compute_autocorrelogram(\n    group,\n    binsize,\n    windowsize,\n    ep=None,\n    norm=True,\n    time_units=\"s\",\n)\n</code></pre> <p>Computes the autocorrelogram of a group of Ts/Tsd objects. The group can be passed directly as a TsGroup object.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>TsGroup</code> <p>The group of Ts/Tsd objects to auto-correlate</p> required <code>binsize</code> <code>float</code> <p>The bin size. Default is second. If different, specify with the parameter time_units ('s' [default], 'ms', 'us').</p> required <code>windowsize</code> <code>float</code> <p>The window size. Default is second. If different, specify with the parameter time_units ('s' [default], 'ms', 'us').</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch on which auto-corrs are computed. If None, the epoch is the time support of the group.</p> <code>None</code> <code>norm</code> <code>bool</code> <p>If True, autocorrelograms are normalized to baseline (i.e. divided by the average rate)  If False, autoorrelograms are returned as the rate (Hz) of the time series (relative to itself)</p> <code>True</code> <code>time_units</code> <code>str</code> <p>The time units of the parameters. They have to be consistent for binsize and windowsize. ('s' [default], 'ms', 'us').</p> <code>'s'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>_</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>group must be TsGroup</p> Source code in <code>pynapple/process/correlograms.py</code> <pre><code>def compute_autocorrelogram(\n    group, binsize, windowsize, ep=None, norm=True, time_units=\"s\"\n):\n    \"\"\"\n    Computes the autocorrelogram of a group of Ts/Tsd objects.\n    The group can be passed directly as a TsGroup object.\n\n    Parameters\n    ----------\n    group : TsGroup\n        The group of Ts/Tsd objects to auto-correlate\n    binsize : float\n        The bin size. Default is second.\n        If different, specify with the parameter time_units ('s' [default], 'ms', 'us').\n    windowsize : float\n        The window size. Default is second.\n        If different, specify with the parameter time_units ('s' [default], 'ms', 'us').\n    ep : IntervalSet\n        The epoch on which auto-corrs are computed.\n        If None, the epoch is the time support of the group.\n    norm : bool, optional\n         If True, autocorrelograms are normalized to baseline (i.e. divided by the average rate)\n         If False, autoorrelograms are returned as the rate (Hz) of the time series (relative to itself)\n    time_units : str, optional\n        The time units of the parameters. They have to be consistent for binsize and windowsize.\n        ('s' [default], 'ms', 'us').\n\n    Returns\n    -------\n    pandas.DataFrame\n        _\n\n    Raises\n    ------\n    RuntimeError\n        group must be TsGroup\n    \"\"\"\n    if type(group) is nap.TsGroup:\n        if isinstance(ep, nap.IntervalSet):\n            newgroup = group.restrict(ep)\n        else:\n            newgroup = group\n    else:\n        raise RuntimeError(\"Unknown format for group\")\n\n    autocorrs = {}\n\n    binsize = nap.TsIndex.format_timestamps(\n        np.array([binsize], dtype=np.float64), time_units\n    )[0]\n    windowsize = nap.TsIndex.format_timestamps(\n        np.array([windowsize], dtype=np.float64), time_units\n    )[0]\n\n    for n in newgroup.keys():\n        spk_time = newgroup[n].index\n        auc, times = cross_correlogram(spk_time, spk_time, binsize, windowsize)\n        autocorrs[n] = pd.Series(index=np.round(times, 6), data=auc, dtype=\"float\")\n\n    autocorrs = pd.DataFrame.from_dict(autocorrs)\n\n    if norm:\n        autocorrs = autocorrs / newgroup.get_info(\"rate\")\n\n    # Bug here\n    if 0 in autocorrs.index:\n        autocorrs.loc[0] = 0.0\n\n    return autocorrs.astype(\"float\")\n</code></pre>"},{"location":"reference/process/correlograms/#pynapple.process.correlograms.compute_crosscorrelogram","title":"compute_crosscorrelogram","text":"<pre><code>compute_crosscorrelogram(\n    group,\n    binsize,\n    windowsize,\n    ep=None,\n    norm=True,\n    time_units=\"s\",\n    reverse=False,\n)\n</code></pre> <p>Computes all the pairwise cross-correlograms for TsGroup or list/tuple of two TsGroup.</p> <p>If input is TsGroup only, the reference Ts/Tsd and target are chosen based on the builtin itertools.combinations function. For example if indexes are [0,1,2], the function computes cross-correlograms for the pairs (0,1), (0, 2), and (1, 2). The left index gives the reference time series. To reverse the order, set reverse=True.</p> <p>If input is tuple/list of TsGroup, for example group=(group1, group2), the reference for each pairs comes from group1.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>TsGroup or tuple/list of two TsGroups</code> required <p>binsize : float     The bin size. Default is second.     If different, specify with the parameter time_units ('s' [default], 'ms', 'us'). windowsize : float     The window size. Default is second.     If different, specify with the parameter time_units ('s' [default], 'ms', 'us'). ep : IntervalSet     The epoch on which cross-corrs are computed.     If None, the epoch is the time support of the group. norm : bool, optional     If True (default), cross-correlograms are normalized to baseline (i.e. divided by the average rate of the target time series)     If False, cross-orrelograms are returned as the rate (Hz) of the target time series ((relative to the reference time series) time_units : str, optional     The time units of the parameters. They have to be consistent for binsize and windowsize.     ('s' [default], 'ms', 'us'). reverse : bool, optional     To reverse the pair order if input is TsGroup</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>_</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>group must be TsGroup or tuple/list of two TsGroups</p> Source code in <code>pynapple/process/correlograms.py</code> <pre><code>def compute_crosscorrelogram(\n    group, binsize, windowsize, ep=None, norm=True, time_units=\"s\", reverse=False\n):\n    \"\"\"\n    Computes all the pairwise cross-correlograms for TsGroup or list/tuple of two TsGroup.\n\n    If input is TsGroup only, the reference Ts/Tsd and target are chosen based on the builtin itertools.combinations function.\n    For example if indexes are [0,1,2], the function computes cross-correlograms\n    for the pairs (0,1), (0, 2), and (1, 2). The left index gives the reference time series.\n    To reverse the order, set reverse=True.\n\n    If input is tuple/list of TsGroup, for example group=(group1, group2), the reference for each pairs comes from group1.\n\n    Parameters\n    ----------\n    group : TsGroup or tuple/list of two TsGroups\n\n    binsize : float\n        The bin size. Default is second.\n        If different, specify with the parameter time_units ('s' [default], 'ms', 'us').\n    windowsize : float\n        The window size. Default is second.\n        If different, specify with the parameter time_units ('s' [default], 'ms', 'us').\n    ep : IntervalSet\n        The epoch on which cross-corrs are computed.\n        If None, the epoch is the time support of the group.\n    norm : bool, optional\n        If True (default), cross-correlograms are normalized to baseline (i.e. divided by the average rate of the target time series)\n        If False, cross-orrelograms are returned as the rate (Hz) of the target time series ((relative to the reference time series)\n    time_units : str, optional\n        The time units of the parameters. They have to be consistent for binsize and windowsize.\n        ('s' [default], 'ms', 'us').\n    reverse : bool, optional\n        To reverse the pair order if input is TsGroup\n\n    Returns\n    -------\n    pandas.DataFrame\n        _\n\n    Raises\n    ------\n    RuntimeError\n        group must be TsGroup or tuple/list of two TsGroups\n\n    \"\"\"\n    crosscorrs = {}\n\n    binsize = nap.TsIndex.format_timestamps(\n        np.array([binsize], dtype=np.float64), time_units\n    )[0]\n    windowsize = nap.TsIndex.format_timestamps(\n        np.array([windowsize], dtype=np.float64), time_units\n    )[0]\n\n    if isinstance(group, nap.TsGroup):\n        if isinstance(ep, nap.IntervalSet):\n            newgroup = group.restrict(ep)\n        else:\n            newgroup = group\n        neurons = list(newgroup.keys())\n        pairs = list(combinations(neurons, 2))\n        if reverse:\n            pairs = list(map(lambda n: (n[1], n[0]), pairs))\n\n        for i, j in pairs:\n            spk1 = newgroup[i].index\n            spk2 = newgroup[j].index\n            auc, times = cross_correlogram(spk1, spk2, binsize, windowsize)\n            crosscorrs[(i, j)] = pd.Series(index=times, data=auc, dtype=\"float\")\n\n        crosscorrs = pd.DataFrame.from_dict(crosscorrs)\n\n        if norm:\n            freq = newgroup.get_info(\"rate\")\n            freq2 = pd.Series(\n                index=pairs, data=list(map(lambda n: freq.loc[n[1]], pairs))\n            )\n            crosscorrs = crosscorrs / freq2\n\n    elif (\n        isinstance(group, (tuple, list))\n        and len(group) == 2\n        and all(map(lambda g: isinstance(g, nap.TsGroup), group))\n    ):\n        if isinstance(ep, nap.IntervalSet):\n            newgroup = [group[i].restrict(ep) for i in range(2)]\n        else:\n            newgroup = group\n\n        pairs = product(list(newgroup[0].keys()), list(newgroup[1].keys()))\n\n        for i, j in pairs:\n            spk1 = newgroup[0][i].index\n            spk2 = newgroup[1][j].index\n            auc, times = cross_correlogram(spk1, spk2, binsize, windowsize)\n            if norm:\n                auc /= newgroup[1][j].rate\n            crosscorrs[(i, j)] = pd.Series(index=times, data=auc, dtype=\"float\")\n\n        crosscorrs = pd.DataFrame.from_dict(crosscorrs)\n\n    else:\n        raise RuntimeError(\"Unknown format for group\")\n\n    return crosscorrs.astype(\"float\")\n</code></pre>"},{"location":"reference/process/correlograms/#pynapple.process.correlograms.compute_eventcorrelogram","title":"compute_eventcorrelogram","text":"<pre><code>compute_eventcorrelogram(\n    group,\n    event,\n    binsize,\n    windowsize,\n    ep=None,\n    norm=True,\n    time_units=\"s\",\n)\n</code></pre> <p>Computes the correlograms of a group of Ts/Tsd objects with another single Ts/Tsd object The time of reference is the event times.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>TsGroup</code> <p>The group of Ts/Tsd objects to correlate with the event</p> required <code>event</code> <code>Ts / Tsd</code> <p>The event to correlate the each of the time series in the group with.</p> required <code>binsize</code> <code>float</code> <p>The bin size. Default is second. If different, specify with the parameter time_units ('s' [default], 'ms', 'us').</p> required <code>windowsize</code> <code>float</code> <p>The window size. Default is second. If different, specify with the parameter time_units ('s' [default], 'ms', 'us').</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch on which cross-corrs are computed. If None, the epoch is the time support of the event.</p> <code>None</code> <code>norm</code> <code>bool</code> <p>If True (default), cross-correlograms are normalized to baseline (i.e. divided by the average rate of the target time series) If False, cross-orrelograms are returned as the rate (Hz) of the target time series (relative to the event time series)</p> <code>True</code> <code>time_units</code> <code>str</code> <p>The time units of the parameters. They have to be consistent for binsize and windowsize. ('s' [default], 'ms', 'us').</p> <code>'s'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>_</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>group must be TsGroup</p> Source code in <code>pynapple/process/correlograms.py</code> <pre><code>def compute_eventcorrelogram(\n    group, event, binsize, windowsize, ep=None, norm=True, time_units=\"s\"\n):\n    \"\"\"\n    Computes the correlograms of a group of Ts/Tsd objects with another single Ts/Tsd object\n    The time of reference is the event times.\n\n    Parameters\n    ----------\n    group : TsGroup\n        The group of Ts/Tsd objects to correlate with the event\n    event : Ts/Tsd\n        The event to correlate the each of the time series in the group with.\n    binsize : float\n        The bin size. Default is second.\n        If different, specify with the parameter time_units ('s' [default], 'ms', 'us').\n    windowsize : float\n        The window size. Default is second.\n        If different, specify with the parameter time_units ('s' [default], 'ms', 'us').\n    ep : IntervalSet\n        The epoch on which cross-corrs are computed.\n        If None, the epoch is the time support of the event.\n    norm : bool, optional\n        If True (default), cross-correlograms are normalized to baseline (i.e. divided by the average rate of the target time series)\n        If False, cross-orrelograms are returned as the rate (Hz) of the target time series (relative to the event time series)\n    time_units : str, optional\n        The time units of the parameters. They have to be consistent for binsize and windowsize.\n        ('s' [default], 'ms', 'us').\n\n    Returns\n    -------\n    pandas.DataFrame\n        _\n\n    Raises\n    ------\n    RuntimeError\n        group must be TsGroup\n\n    \"\"\"\n    if ep is None:\n        ep = event.time_support\n        tsd1 = event.index\n    else:\n        tsd1 = event.restrict(ep).index\n\n    if type(group) is nap.TsGroup:\n        newgroup = group.restrict(ep)\n    else:\n        raise RuntimeError(\"Unknown format for group\")\n\n    crosscorrs = {}\n\n    binsize = nap.TsIndex.format_timestamps(\n        np.array([binsize], dtype=np.float64), time_units\n    )[0]\n    windowsize = nap.TsIndex.format_timestamps(\n        np.array([windowsize], dtype=np.float64), time_units\n    )[0]\n\n    for n in newgroup.keys():\n        spk_time = newgroup[n].index\n        auc, times = cross_correlogram(tsd1, spk_time, binsize, windowsize)\n        crosscorrs[n] = pd.Series(index=times, data=auc, dtype=\"float\")\n\n    crosscorrs = pd.DataFrame.from_dict(crosscorrs)\n\n    if norm:\n        crosscorrs = crosscorrs / newgroup.get_info(\"rate\")\n\n    return crosscorrs.astype(\"float\")\n</code></pre>"},{"location":"reference/process/decoding/","title":"Decoding","text":""},{"location":"reference/process/decoding/#pynapple.process.decoding","title":"pynapple.process.decoding","text":""},{"location":"reference/process/decoding/#pynapple.process.decoding.decode_1d","title":"decode_1d","text":"<pre><code>decode_1d(\n    tuning_curves,\n    group,\n    ep,\n    bin_size,\n    time_units=\"s\",\n    feature=None,\n)\n</code></pre> <p>Performs Bayesian decoding over a one dimensional feature. See: Zhang, K., Ginzburg, I., McNaughton, B. L., &amp; Sejnowski, T. J. (1998). Interpreting neuronal population activity by reconstruction: unified framework with application to hippocampal place cells. Journal of neurophysiology, 79(2), 1017-1044.</p> <p>Parameters:</p> Name Type Description Default <code>tuning_curves</code> <code>DataFrame</code> <p>Each column is the tuning curve of one neuron relative to the feature. Index should be the center of the bin.</p> required <code>group</code> <code>TsGroup or dict of Ts/Tsd object.</code> <p>A group of neurons with the same index as tuning curves column names.</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch on which decoding is computed</p> required <code>bin_size</code> <code>float</code> <p>Bin size. Default is second. Use the parameter time_units to change it.</p> required <code>time_units</code> <code>str</code> <p>Time unit of the bin size ('s' [default], 'ms', 'us').</p> <code>'s'</code> <code>feature</code> <code>Tsd</code> <p>The 1d feature used to compute the tuning curves. Used to correct for occupancy. If feature is not passed, the occupancy is uniform.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tsd</code> <p>The decoded feature</p> <code>TsdFrame</code> <p>The probability distribution of the decoded feature for each time bin</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If group is not a dict of Ts/Tsd or TsGroup. If different size of neurons for tuning_curves and group. If indexes don't match between tuning_curves and group.</p> Source code in <code>pynapple/process/decoding.py</code> <pre><code>def decode_1d(tuning_curves, group, ep, bin_size, time_units=\"s\", feature=None):\n    \"\"\"\n    Performs Bayesian decoding over a one dimensional feature.\n    See:\n    Zhang, K., Ginzburg, I., McNaughton, B. L., &amp; Sejnowski, T. J.\n    (1998). Interpreting neuronal population activity by\n    reconstruction: unified framework with application to\n    hippocampal place cells. Journal of neurophysiology, 79(2),\n    1017-1044.\n\n    Parameters\n    ----------\n    tuning_curves : pandas.DataFrame\n        Each column is the tuning curve of one neuron relative to the feature.\n        Index should be the center of the bin.\n    group : TsGroup or dict of Ts/Tsd object.\n        A group of neurons with the same index as tuning curves column names.\n    ep : IntervalSet\n        The epoch on which decoding is computed\n    bin_size : float\n        Bin size. Default is second. Use the parameter time_units to change it.\n    time_units : str, optional\n        Time unit of the bin size ('s' [default], 'ms', 'us').\n    feature : Tsd, optional\n        The 1d feature used to compute the tuning curves. Used to correct for occupancy.\n        If feature is not passed, the occupancy is uniform.\n\n    Returns\n    -------\n    Tsd\n        The decoded feature\n    TsdFrame\n        The probability distribution of the decoded feature for each time bin\n\n    Raises\n    ------\n    RuntimeError\n        If group is not a dict of Ts/Tsd or TsGroup.\n        If different size of neurons for tuning_curves and group.\n        If indexes don't match between tuning_curves and group.\n    \"\"\"\n    if isinstance(group, dict):\n        newgroup = nap.TsGroup(group, time_support=ep)\n    elif isinstance(group, nap.TsGroup):\n        newgroup = group.restrict(ep)\n    else:\n        raise RuntimeError(\"Unknown format for group\")\n\n    if tuning_curves.shape[1] != len(newgroup):\n        raise RuntimeError(\"Different shapes for tuning_curves and group\")\n\n    if not np.all(tuning_curves.columns.values == np.array(newgroup.keys())):\n        raise RuntimeError(\"Difference indexes for tuning curves and group keys\")\n\n    # Bin spikes\n    count = newgroup.count(bin_size, ep, time_units)\n\n    # Occupancy\n    if feature is None:\n        occupancy = np.ones(tuning_curves.shape[0])\n    elif isinstance(feature, nap.Tsd):\n        diff = np.diff(tuning_curves.index.values)\n        bins = tuning_curves.index.values[:-1] - diff / 2\n        bins = np.hstack(\n            (bins, [bins[-1] + diff[-1], bins[-1] + 2 * diff[-1]])\n        )  # assuming the size of the last 2 bins is equal\n        occupancy, _ = np.histogram(feature.values, bins)\n    else:\n        raise RuntimeError(\"Unknown format for feature in decode_1d\")\n\n    # Transforming to pure numpy array\n    tc = tuning_curves.values\n    ct = count.values\n\n    bin_size_s = nap.TsIndex.format_timestamps(\n        np.array([bin_size], dtype=np.float64), time_units\n    )[0]\n\n    p1 = np.exp(-bin_size_s * tc.sum(1))\n    p2 = occupancy / occupancy.sum()\n\n    ct2 = np.tile(ct[:, np.newaxis, :], (1, tc.shape[0], 1))\n\n    p3 = np.prod(tc**ct2, -1)\n\n    p = p1 * p2 * p3\n    p = p / p.sum(1)[:, np.newaxis]\n\n    idxmax = np.argmax(p, 1)\n\n    p = nap.TsdFrame(\n        t=count.index, d=p, time_support=ep, columns=tuning_curves.index.values\n    )\n\n    decoded = nap.Tsd(\n        t=count.index, d=tuning_curves.index.values[idxmax], time_support=ep\n    )\n\n    return decoded, p\n</code></pre>"},{"location":"reference/process/decoding/#pynapple.process.decoding.decode_2d","title":"decode_2d","text":"<pre><code>decode_2d(\n    tuning_curves,\n    group,\n    ep,\n    bin_size,\n    xy,\n    time_units=\"s\",\n    features=None,\n)\n</code></pre> <p>Performs Bayesian decoding over a two dimensional feature. See: Zhang, K., Ginzburg, I., McNaughton, B. L., &amp; Sejnowski, T. J. (1998). Interpreting neuronal population activity by reconstruction: unified framework with application to hippocampal place cells. Journal of neurophysiology, 79(2), 1017-1044.</p> <p>Parameters:</p> Name Type Description Default <code>tuning_curves</code> <code>dict</code> <p>Dictionnay of 2d tuning curves (one for each neuron).</p> required <code>group</code> <code>TsGroup or dict of Ts/Tsd object.</code> <p>A group of neurons with the same keys as tuning_curves dictionnary.</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch on which decoding is computed</p> required <code>bin_size</code> <code>float</code> <p>Bin size. Default is second. Use the parameter time_units to change it.</p> required <code>xy</code> <code>tuple</code> <p>A tuple of bin positions for the tuning curves i.e. xy=(x,y)</p> required <code>time_units</code> <code>str</code> <p>Time unit of the bin size ('s' [default], 'ms', 'us').</p> <code>'s'</code> <code>features</code> <code>TsdFrame</code> <p>The 2 columns features used to compute the tuning curves. Used to correct for occupancy. If feature is not passed, the occupancy is uniform.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tsd</code> <p>The decoded feature in 2d</p> <code>ndarray</code> <p>The probability distribution of the decoded trajectory for each time bin</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If group is not a dict of Ts/Tsd or TsGroup. If different size of neurons for tuning_curves and group. If indexes don't match between tuning_curves and group.</p> Source code in <code>pynapple/process/decoding.py</code> <pre><code>def decode_2d(tuning_curves, group, ep, bin_size, xy, time_units=\"s\", features=None):\n    \"\"\"\n    Performs Bayesian decoding over a two dimensional feature.\n    See:\n    Zhang, K., Ginzburg, I., McNaughton, B. L., &amp; Sejnowski, T. J.\n    (1998). Interpreting neuronal population activity by\n    reconstruction: unified framework with application to\n    hippocampal place cells. Journal of neurophysiology, 79(2),\n    1017-1044.\n\n    Parameters\n    ----------\n    tuning_curves : dict\n        Dictionnay of 2d tuning curves (one for each neuron).\n    group : TsGroup or dict of Ts/Tsd object.\n        A group of neurons with the same keys as tuning_curves dictionnary.\n    ep : IntervalSet\n        The epoch on which decoding is computed\n    bin_size : float\n        Bin size. Default is second. Use the parameter time_units to change it.\n    xy : tuple\n        A tuple of bin positions for the tuning curves i.e. xy=(x,y)\n    time_units : str, optional\n        Time unit of the bin size ('s' [default], 'ms', 'us').\n    features : TsdFrame\n        The 2 columns features used to compute the tuning curves. Used to correct for occupancy.\n        If feature is not passed, the occupancy is uniform.\n\n    Returns\n    -------\n    Tsd\n        The decoded feature in 2d\n    numpy.ndarray\n        The probability distribution of the decoded trajectory for each time bin\n\n    Raises\n    ------\n    RuntimeError\n        If group is not a dict of Ts/Tsd or TsGroup.\n        If different size of neurons for tuning_curves and group.\n        If indexes don't match between tuning_curves and group.\n\n    \"\"\"\n\n    if type(group) is dict:\n        newgroup = nap.TsGroup(group, time_support=ep)\n        numcells = len(newgroup)\n    elif type(group) is nap.TsGroup:\n        newgroup = group.restrict(ep)\n        numcells = len(newgroup)\n    else:\n        raise RuntimeError(\"Unknown format for group\")\n\n    if len(tuning_curves) != numcells:\n        raise RuntimeError(\"Different shapes for tuning_curves and group\")\n\n    if not np.all(np.array(list(tuning_curves.keys())) == np.array(newgroup.keys())):\n        raise RuntimeError(\"Difference indexes for tuning curves and group keys\")\n\n    # Bin spikes\n    # if type(newgroup) is not nap.TsdFrame:\n    count = newgroup.count(bin_size, ep, time_units)\n    # else:\n    #     #Spikes already \"binned\" with continuous TsdFrame input\n    #     count = newgroup\n\n    indexes = list(tuning_curves.keys())\n\n    # Occupancy\n    if features is None:\n        occupancy = np.ones_like(tuning_curves[indexes[0]]).flatten()\n    else:\n        binsxy = []\n        for i in range(len(xy)):\n            diff = np.diff(xy[i])\n            bins = xy[i][:-1] - diff / 2\n            bins = np.hstack(\n                (bins, [bins[-1] + diff[-1], bins[-1] + 2 * diff[-1]])\n            )  # assuming the size of the last 2 bins is equal\n            binsxy.append(bins)\n\n        occupancy, _, _ = np.histogram2d(\n            features[:, 0].values, features[:, 1].values, [binsxy[0], binsxy[1]]\n        )\n        occupancy = occupancy.flatten()\n\n    # Transforming to pure numpy array\n    tc = np.array([tuning_curves[i] for i in tuning_curves.keys()])\n    tc = tc.reshape(tc.shape[0], np.prod(tc.shape[1:]))\n    tc = tc.T\n\n    ct = count.values\n\n    bin_size_s = nap.TsIndex.format_timestamps(\n        np.array([bin_size], dtype=np.float64), time_units\n    )[0]\n\n    p1 = np.exp(-bin_size_s * np.nansum(tc, 1))\n    p2 = occupancy / occupancy.sum()\n\n    ct2 = np.tile(ct[:, np.newaxis, :], (1, tc.shape[0], 1))\n\n    p3 = np.nanprod(tc**ct2, -1)\n\n    p = p1 * p2 * p3\n    p = p / p.sum(1)[:, np.newaxis]\n\n    idxmax = np.argmax(p, 1)\n\n    p = p.reshape(p.shape[0], len(xy[0]), len(xy[1]))\n\n    idxmax2d = np.unravel_index(idxmax, (len(xy[0]), len(xy[1])))\n\n    if features is not None:\n        cols = features.columns\n    else:\n        cols = np.arange(2)\n\n    decoded = nap.TsdFrame(\n        t=count.index,\n        d=np.vstack((xy[0][idxmax2d[0]], xy[1][idxmax2d[1]])).T,\n        time_support=ep,\n        columns=cols,\n    )\n\n    return decoded, p\n</code></pre>"},{"location":"reference/process/perievent/","title":"Perievent","text":""},{"location":"reference/process/perievent/#pynapple.process.perievent","title":"pynapple.process.perievent","text":""},{"location":"reference/process/perievent/#pynapple.process.perievent.compute_perievent","title":"compute_perievent","text":"<pre><code>compute_perievent(data, tref, minmax, time_unit='s')\n</code></pre> <p>Center the timestamps of a time series object or a time series group around the timestamps given by the <code>tref</code> argument. <code>minmax</code> indicates the start and end of the window. If <code>minmax=(-5, 10)</code>, the window will be from -5 second to 10 second. If <code>minmax=10</code>, the window will be from -10 second to 10 second.</p> <p>To center continuous time series around a set of timestamps, you can use <code>compute_perievent_continuous</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(Ts, Tsd or TsGroup)</code> <p>The data to align to tref. If Ts/Tsd, returns a TsGroup. If TsGroup, returns a dictionnary of TsGroup</p> required <code>tref</code> <code>Ts or Tsd</code> <p>The timestamps of the event to align to</p> required <code>minmax</code> <code>(tuple, int or float)</code> <p>The window size. Can be unequal on each side i.e. (-500, 1000).</p> required <code>time_unit</code> <code>str</code> <p>Time units of the minmax ('s' [default], 'ms', 'us').</p> <code>'s'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A TsGroup if data is a Ts/Tsd or a dictionnary of TsGroup if data is a TsGroup.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if tref is not a Ts/Tsd object or if data is not a Ts/Tsd or TsGroup</p> Source code in <code>pynapple/process/perievent.py</code> <pre><code>def compute_perievent(data, tref, minmax, time_unit=\"s\"):\n    \"\"\"\n    Center the timestamps of a time series object or a time series group around the timestamps given by the `tref` argument.\n    `minmax` indicates the start and end of the window. If `minmax=(-5, 10)`, the window will be from -5 second to 10 second.\n    If `minmax=10`, the window will be from -10 second to 10 second.\n\n    To center continuous time series around a set of timestamps, you can use `compute_perievent_continuous`.\n\n    Parameters\n    ----------\n    data : Ts, Tsd or TsGroup\n        The data to align to tref.\n        If Ts/Tsd, returns a TsGroup.\n        If TsGroup, returns a dictionnary of TsGroup\n    tref : Ts or Tsd\n        The timestamps of the event to align to\n    minmax : tuple, int or float\n        The window size. Can be unequal on each side i.e. (-500, 1000).\n    time_unit : str, optional\n        Time units of the minmax ('s' [default], 'ms', 'us').\n\n    Returns\n    -------\n    dict\n        A TsGroup if data is a Ts/Tsd or\n        a dictionnary of TsGroup if data is a TsGroup.\n\n    Raises\n    ------\n    RuntimeError\n        if tref is not a Ts/Tsd object or if data is not a Ts/Tsd or TsGroup\n    \"\"\"\n    assert isinstance(tref, (nap.Ts, nap.Tsd)), \"tref should be a Ts or Tsd object.\"\n    assert isinstance(\n        data, (nap.Ts, nap.Tsd, nap.TsGroup)\n    ), \"data should be a Ts, Tsd or TsGroup.\"\n    assert isinstance(\n        minmax, (float, int, tuple)\n    ), \"minmax should be a tuple or int or float.\"\n    assert isinstance(time_unit, str), \"time_unit should be a str.\"\n    assert time_unit in [\"s\", \"ms\", \"us\"], \"time_unit should be 's', 'ms' or 'us'\"\n\n    if isinstance(minmax, float) or isinstance(minmax, int):\n        minmax = np.array([minmax, minmax], dtype=np.float64)\n\n    window = np.abs(nap.TsIndex.format_timestamps(np.array(minmax), time_unit))\n\n    time_support = nap.IntervalSet(start=-window[0], end=window[1])\n\n    if isinstance(data, nap.TsGroup):\n        toreturn = {}\n\n        for n in data.index:\n            toreturn[n] = _align_tsd(data[n], tref, window, time_support)\n\n        return toreturn\n\n    else:\n        return _align_tsd(data, tref, window, time_support)\n</code></pre>"},{"location":"reference/process/perievent/#pynapple.process.perievent.compute_perievent_continuous","title":"compute_perievent_continuous","text":"<pre><code>compute_perievent_continuous(\n    data, tref, minmax, ep=None, time_unit=\"s\"\n)\n</code></pre> <p>Center continuous time series around the timestamps given by the 'tref' argument. <code>minmax</code> indicates the start and end of the window. If <code>minmax=(-5, 10)</code>, the window will be from -5 second to 10 second. If <code>minmax=10</code>, the window will be from -10 second to 10 second.</p> <p>To realign timestamps around a set of timestamps, you can use <code>compute_perievent_continuous</code>.</p> <p>This function assumes a constant sampling rate of the time series.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The data to align to tref.</p> required <code>tref</code> <code>Ts or Tsd</code> <p>The timestamps of the event to align to</p> required <code>minmax</code> <code>tuple or int or float</code> <p>The window size. Can be unequal on each side i.e. (-500, 1000).</p> required <code>ep</code> <code>IntervalSet</code> <p>The epochs to perform the operation. If None, the default is the time support of the data.</p> <code>None</code> <code>time_unit</code> <code>str</code> <p>Time units of the minmax ('s' [default], 'ms', 'us').</p> <code>'s'</code> <p>Returns:</p> Type Description <code>(TsdFrame, TsdTensor)</code> <p>If <code>data</code> is a one-dimensional Tsd, the output is a TsdFrame. Each column is one timestamps from <code>tref</code>. If <code>data</code> is a TsdFrame or TsdTensor, the output is a TsdTensor with one more dimension. The first dimension is always time and the second dimension is the 'tref' timestamps.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if tref is not a Ts/Tsd object or if data is not a Tsd/TsdFrame/TsdTensor object.</p> Source code in <code>pynapple/process/perievent.py</code> <pre><code>def compute_perievent_continuous(data, tref, minmax, ep=None, time_unit=\"s\"):\n    \"\"\"\n    Center continuous time series around the timestamps given by the 'tref' argument.\n    `minmax` indicates the start and end of the window. If `minmax=(-5, 10)`, the window will be from -5 second to 10 second.\n    If `minmax=10`, the window will be from -10 second to 10 second.\n\n    To realign timestamps around a set of timestamps, you can use `compute_perievent_continuous`.\n\n    This function assumes a constant sampling rate of the time series.\n\n    Parameters\n    ----------\n    data : Tsd, TsdFrame or TsdTensor\n        The data to align to tref.\n    tref : Ts or Tsd\n        The timestamps of the event to align to\n    minmax : tuple or int or float\n        The window size. Can be unequal on each side i.e. (-500, 1000).\n    ep : IntervalSet, optional\n        The epochs to perform the operation. If None, the default is the time support of the data.\n    time_unit : str, optional\n        Time units of the minmax ('s' [default], 'ms', 'us').\n\n    Returns\n    -------\n    TsdFrame, TsdTensor\n        If `data` is a one-dimensional Tsd, the output is a TsdFrame. Each column is one timestamps from `tref`.\n        If `data` is a TsdFrame or TsdTensor, the output is a TsdTensor with one more dimension. The first dimension is always time and the second dimension is the 'tref' timestamps.\n\n    Raises\n    ------\n    RuntimeError\n        if tref is not a Ts/Tsd object or if data is not a Tsd/TsdFrame/TsdTensor object.\n    \"\"\"\n\n    assert isinstance(tref, (nap.Ts, nap.Tsd)), \"tref should be a Ts or Tsd object.\"\n    assert isinstance(\n        data, (nap.Tsd, nap.TsdFrame, nap.TsdTensor)\n    ), \"data should be a Tsd, TsdFrame or TsdTensor.\"\n    assert isinstance(\n        minmax, (float, int, tuple)\n    ), \"minmax should be a tuple or int or float.\"\n    assert isinstance(time_unit, str), \"time_unit should be a str.\"\n    assert time_unit in [\"s\", \"ms\", \"us\"], \"time_unit should be 's', 'ms' or 'us'\"\n\n    if ep is None:\n        ep = data.time_support\n    else:\n        assert isinstance(ep, (nap.IntervalSet)), \"ep should be an IntervalSet object.\"\n\n    if isinstance(minmax, float) or isinstance(minmax, int):\n        minmax = np.array([minmax, minmax], dtype=np.float64)\n\n    window = np.abs(nap.TsIndex.format_timestamps(np.array(minmax), time_unit))\n\n    time_array = data.index.values\n    data_array = data.values\n    time_target_array = tref.index.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    binsize = time_array[1] - time_array[0]\n    idx1 = -np.arange(0, window[0] + binsize, binsize)[::-1][:-1]\n    idx2 = np.arange(0, window[1] + binsize, binsize)[1:]\n    time_idx = np.hstack((idx1, np.zeros(1), idx2))\n    windowsize = np.array([idx1.shape[0], idx2.shape[0]])\n\n    new_data_array = nap._jitted_functions.jitcontinuous_perievent(\n        time_array, data_array, time_target_array, starts, ends, windowsize\n    )\n\n    time_support = nap.IntervalSet(start=-window[0], end=window[1])\n\n    if new_data_array.ndim == 2:\n        return nap.TsdFrame(t=time_idx, d=new_data_array, time_support=time_support)\n    else:\n        return nap.TsdTensor(t=time_idx, d=new_data_array, time_support=time_support)\n</code></pre>"},{"location":"reference/process/perievent/#pynapple.process.perievent.compute_event_trigger_average","title":"compute_event_trigger_average","text":"<pre><code>compute_event_trigger_average(\n    group,\n    feature,\n    binsize,\n    windowsize=None,\n    ep=None,\n    time_unit=\"s\",\n)\n</code></pre> <p>Bin the event timestamps within binsize and compute the Event Trigger Average (ETA) within windowsize. If C is the event count matrix and <code>feature</code> is a Tsd array, the function computes the Hankel matrix H from windowsize=(-t1,+t2) by offseting the Tsd array.</p> <p>The ETA is then defined as the dot product between H and C divided by the number of events.</p> <p>The object feature can be any dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>TsGroup</code> <p>The group of Ts/Tsd objects that hold the trigger time.</p> required <code>feature</code> <code>(Tsd, TsdFrame or TsdTensor)</code> <p>The feature to average.</p> required <code>binsize</code> <code>float or int</code> <p>The bin size. Default is second. If different, specify with the parameter time_unit ('s' [default], 'ms', 'us').</p> required <code>windowsize</code> <code>tuple of float/int or float/int</code> <p>The window size. Default is second. For example windowsize = (-1, 1) is equivalent to windowsize = 1 If different, specify with the parameter time_unit ('s' [default], 'ms', 'us').</p> <code>None</code> <code>ep</code> <code>IntervalSet</code> <p>The epochs on which the average is computed</p> <code>None</code> <code>time_unit</code> <code>str</code> <p>The time unit of the parameters. They have to be consistent for binsize and windowsize. ('s' [default], 'ms', 'us').</p> <code>'s'</code> Source code in <code>pynapple/process/perievent.py</code> <pre><code>def compute_event_trigger_average(\n    group,\n    feature,\n    binsize,\n    windowsize=None,\n    ep=None,\n    time_unit=\"s\",\n):\n    \"\"\"\n    Bin the event timestamps within binsize and compute the Event Trigger Average (ETA) within windowsize.\n    If C is the event count matrix and `feature` is a Tsd array, the function computes\n    the Hankel matrix H from windowsize=(-t1,+t2) by offseting the Tsd array.\n\n    The ETA is then defined as the dot product between H and C divided by the number of events.\n\n    The object feature can be any dimensions.\n\n    Parameters\n    ----------\n    group : TsGroup\n        The group of Ts/Tsd objects that hold the trigger time.\n    feature : Tsd, TsdFrame or TsdTensor\n        The feature to average.\n    binsize : float or int\n        The bin size. Default is second.\n        If different, specify with the parameter time_unit ('s' [default], 'ms', 'us').\n    windowsize : tuple of float/int or float/int\n        The window size. Default is second. For example windowsize = (-1, 1) is equivalent to windowsize = 1\n        If different, specify with the parameter time_unit ('s' [default], 'ms', 'us').\n    ep : IntervalSet\n        The epochs on which the average is computed\n    time_unit : str, optional\n        The time unit of the parameters. They have to be consistent for binsize and windowsize.\n        ('s' [default], 'ms', 'us').\n    \"\"\"\n    assert isinstance(group, nap.TsGroup), \"group should be a TsGroup.\"\n    assert isinstance(\n        feature, (nap.Tsd, nap.TsdFrame, nap.TsdTensor)\n    ), \"Feature should be a Tsd, TsdFrame or TsdTensor\"\n    assert isinstance(binsize, (float, int)), \"binsize should be int or float.\"\n    assert isinstance(time_unit, str), \"time_unit should be a str.\"\n    assert time_unit in [\"s\", \"ms\", \"us\"], \"time_unit should be 's', 'ms' or 'us'\"\n\n    if windowsize is not None:\n        if isinstance(windowsize, tuple):\n            assert (\n                len(windowsize) == 2\n            ), \"windowsize should be a tuple of 2 elements (-t, +t)\"\n            assert all(\n                [isinstance(t, (float, int)) for t in windowsize]\n            ), \"windowsize should be a tuple of int/float\"\n        else:\n            assert isinstance(\n                windowsize, (float, int)\n            ), \"windowsize should be a tuple of int/float or int/float.\"\n            windowsize = (windowsize, windowsize)\n    else:\n        windowsize = (0.0, 0.0)\n\n    if ep is not None:\n        assert isinstance(ep, (nap.IntervalSet)), \"ep should be an IntervalSet object.\"\n    else:\n        ep = feature.time_support\n\n    binsize = nap.TsIndex.format_timestamps(\n        np.array([binsize], dtype=np.float64), time_unit\n    )[0]\n    start = np.abs(\n        nap.TsIndex.format_timestamps(\n            np.array([windowsize[0]], dtype=np.float64), time_unit\n        )[0]\n    )\n    end = np.abs(\n        nap.TsIndex.format_timestamps(\n            np.array([windowsize[1]], dtype=np.float64), time_unit\n        )[0]\n    )\n\n    idx1 = -np.arange(0, start + binsize, binsize)[::-1][:-1]\n    idx2 = np.arange(0, end + binsize, binsize)[1:]\n    time_idx = np.hstack((idx1, np.zeros(1), idx2))\n\n    eta = np.zeros((time_idx.shape[0], len(group), *feature.shape[1:]))\n\n    windows = np.array([len(idx1), len(idx2)])\n\n    # Bin the spike train\n    count = group.count(binsize, ep)\n\n    time_array = np.round(count.index.values - (binsize / 2), 9)\n    count_array = count.values\n    starts = ep.start.values\n    ends = ep.end.values\n\n    time_target_array = feature.index.values\n    data_target_array = feature.values\n\n    if data_target_array.ndim == 1:\n        eta = nap._jitted_functions.jitperievent_trigger_average(\n            time_array,\n            count_array,\n            time_target_array,\n            np.expand_dims(data_target_array, -1),\n            starts,\n            ends,\n            windows,\n            binsize,\n        )\n        eta = np.squeeze(eta, -1)\n    else:\n        eta = nap._jitted_functions.jitperievent_trigger_average(\n            time_array,\n            count_array,\n            time_target_array,\n            data_target_array,\n            starts,\n            ends,\n            windows,\n            binsize,\n        )\n\n    if eta.ndim == 2:\n        return nap.TsdFrame(t=time_idx, d=eta, columns=group.index)\n    else:\n        return nap.TsdTensor(t=time_idx, d=eta)\n</code></pre>"},{"location":"reference/process/randomize/","title":"Randomize","text":""},{"location":"reference/process/randomize/#pynapple.process.randomize","title":"pynapple.process.randomize","text":""},{"location":"reference/process/randomize/#pynapple.process.randomize.shift_timestamps","title":"shift_timestamps","text":"<pre><code>shift_timestamps(ts, min_shift=0.0, max_shift=None)\n</code></pre> <p>Shifts all the time stamps of a random amount between min_shift and max_shift, wrapping the end of the time support to the beginning.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Ts or TsGroup</code> <p>The timestamps to shift. If TsGroup, shifts all Ts in the group independently.</p> required <code>min_shift</code> <code>float</code> <p>minimum shift (default: 0 )</p> <code>0.0</code> <code>max_shift</code> <code>float</code> <p>maximum shift, (default: length of time support)</p> <code>None</code> <p>Returns:</p> Type Description <code>Ts or TsGroup</code> <p>The randomly shifted timestamps</p> Source code in <code>pynapple/process/randomize.py</code> <pre><code>def shift_timestamps(ts, min_shift=0.0, max_shift=None):\n    \"\"\"\n    Shifts all the time stamps of a random amount between min_shift and max_shift, wrapping the\n    end of the time support to the beginning.\n\n\n    Parameters\n    ----------\n    ts : Ts or TsGroup\n        The timestamps to shift. If TsGroup, shifts all Ts in the group independently.\n    min_shift : float, optional\n        minimum shift (default: 0 )\n    max_shift : float, optional\n        maximum shift, (default: length of time support)\n\n    Returns\n    -------\n    Ts or TsGroup\n        The randomly shifted timestamps\n    \"\"\"\n    strategies = {\n        nap.time_series.Ts: _shift_ts,\n        nap.ts_group.TsGroup: _shift_tsgroup,\n    }\n    # checks input type\n    if type(ts) not in strategies.keys():\n        raise TypeError(\"Invalid input type, should be Ts or TsGroup\")\n\n    strategy = strategies[type(ts)]\n    return strategy(ts, min_shift, max_shift)\n</code></pre>"},{"location":"reference/process/randomize/#pynapple.process.randomize.shuffle_ts_intervals","title":"shuffle_ts_intervals","text":"<pre><code>shuffle_ts_intervals(ts, min_shift=0.0, max_shift=None)\n</code></pre> <p>Randomizes the timestamps by shuffling the intervals between them.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Ts or TsGroup</code> <p>The timestamps to randomize. If TsGroup, randomizes all Ts in the group independently.</p> required <p>Returns:</p> Type Description <code>Ts or TsGroup</code> <p>The randomized timestamps, with shuffled intervals</p> Source code in <code>pynapple/process/randomize.py</code> <pre><code>def shuffle_ts_intervals(ts, min_shift=0.0, max_shift=None):\n    \"\"\"\n    Randomizes the timestamps by shuffling the intervals between them.\n\n\n    Parameters\n    ----------\n    ts : Ts or TsGroup\n        The timestamps to randomize. If TsGroup, randomizes all Ts in the group independently.\n\n    Returns\n    -------\n    Ts or TsGroup\n        The randomized timestamps, with shuffled intervals\n    \"\"\"\n    strategies = {\n        nap.time_series.Ts: _shuffle_intervals_ts,\n        nap.ts_group.TsGroup: _shuffle_intervals_tsgroup,\n    }\n    # checks input type\n    if type(ts) not in strategies.keys():\n        raise TypeError(\"Invalid input type, should be Ts or TsGroup\")\n\n    strategy = strategies[type(ts)]\n    return strategy(ts)\n</code></pre>"},{"location":"reference/process/randomize/#pynapple.process.randomize.jitter_timestamps","title":"jitter_timestamps","text":"<pre><code>jitter_timestamps(ts, max_jitter=None, keep_tsupport=False)\n</code></pre> <p>Jitters each time stamp independently of random amounts uniformly drawn between -max_jitter and max_jitter.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Ts or TsGroup</code> <p>The timestamps to jitter. If TsGroup, jitter is applied to each element of the group.</p> required <code>max_jitter</code> <code>float</code> <p>maximum jitter</p> <code>None</code> <code>keep_tsupport</code> <p>If True, keep time support of the input. The number of timestamps will not be conserved. If False, the time support is inferred from the jittered timestamps. The number of tmestamps is conserved. (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>Ts or TsGroup</code> <p>The jittered timestamps</p> Source code in <code>pynapple/process/randomize.py</code> <pre><code>def jitter_timestamps(ts, max_jitter=None, keep_tsupport=False):\n    \"\"\"\n    Jitters each time stamp independently of random amounts uniformly drawn between -max_jitter and max_jitter.\n\n\n    Parameters\n    ----------\n    ts : Ts or TsGroup\n        The timestamps to jitter. If TsGroup, jitter is applied to each element of the group.\n    max_jitter : float\n        maximum jitter\n    keep_tsupport: bool, optional\n        If True, keep time support of the input. The number of timestamps will not be conserved.\n        If False, the time support is inferred from the jittered timestamps. The number of tmestamps\n        is conserved. (default: False)\n\n    Returns\n    -------\n    Ts or TsGroup\n        The jittered timestamps\n    \"\"\"\n    strategies = {\n        nap.time_series.Ts: _jitter_ts,\n        nap.ts_group.TsGroup: _jitter_tsgroup,\n    }\n    # checks input type\n    if type(ts) not in strategies.keys():\n        raise TypeError(\"Invalid input type, should be Ts or TsGroup\")\n\n    if max_jitter is None:\n        raise TypeError(\"missing required argument: max_jitter \")\n\n    strategy = strategies[type(ts)]\n    return strategy(ts, max_jitter, keep_tsupport)\n</code></pre>"},{"location":"reference/process/randomize/#pynapple.process.randomize.resample_timestamps","title":"resample_timestamps","text":"<pre><code>resample_timestamps(ts)\n</code></pre> <p>Resamples the timestamps in the time support, with uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Ts or TsGroup</code> <p>The timestamps to resample. If TsGroup, each Ts object in the group is independently resampled, in the time support of the whole group.</p> required <p>Returns:</p> Type Description <code>Ts or TsGroup</code> <p>The resampled timestamps</p> Source code in <code>pynapple/process/randomize.py</code> <pre><code>def resample_timestamps(ts):\n    \"\"\"\n    Resamples the timestamps in the time support, with uniform distribution.\n\n\n    Parameters\n    ----------\n    ts : Ts or TsGroup\n        The timestamps to resample. If TsGroup, each Ts object in the group is independently\n        resampled, in the time support of the whole group.\n\n\n    Returns\n    -------\n    Ts or TsGroup\n        The resampled timestamps\n    \"\"\"\n    strategies = {\n        nap.time_series.Ts: _resample_ts,\n        nap.ts_group.TsGroup: _resample_tsgroup,\n    }\n    # checks input type\n    if type(ts) not in strategies.keys():\n        raise TypeError(\"Invalid input type, should be Ts or TsGroup\")\n\n    strategy = strategies[type(ts)]\n    return strategy(ts)\n</code></pre>"},{"location":"reference/process/tuning_curves/","title":"Tuning curves","text":""},{"location":"reference/process/tuning_curves/#pynapple.process.tuning_curves","title":"pynapple.process.tuning_curves","text":""},{"location":"reference/process/tuning_curves/#pynapple.process.tuning_curves.compute_discrete_tuning_curves","title":"compute_discrete_tuning_curves","text":"<pre><code>compute_discrete_tuning_curves(group, dict_ep)\n</code></pre> <p>Compute discrete tuning curves of a TsGroup using a dictionnary of epochs. The function returns a pandas DataFrame with each row being a key of the dictionnary of epochs and each column being a neurons.</p> <p>This function can typically being used for a set of stimulus being presented for multiple epochs. An example of the dictionnary is :</p> <pre><code>&gt;&gt;&gt; dict_ep =  {\n        \"stim0\": nap.IntervalSet(start=0, end=1),\n        \"stim1\":nap.IntervalSet(start=2, end=3)\n    }\n</code></pre> <p>In this case, the function will return a pandas DataFrame :</p> <pre><code>&gt;&gt;&gt; tc\n           neuron0    neuron1    neuron2\nstim0        0 Hz       1 Hz       2 Hz\nstim1        3 Hz       4 Hz       5 Hz\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>TsGroup</code> <p>The group of Ts/Tsd for which the tuning curves will be computed</p> required <code>dict_ep</code> <code>dict</code> <p>Dictionary of IntervalSets</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Table of firing rate for each neuron and each IntervalSet</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If group is not a TsGroup object.</p> Source code in <code>pynapple/process/tuning_curves.py</code> <pre><code>def compute_discrete_tuning_curves(group, dict_ep):\n    \"\"\"\n    Compute discrete tuning curves of a TsGroup using a dictionnary of epochs.\n    The function returns a pandas DataFrame with each row being a key of the dictionnary of epochs\n    and each column being a neurons.\n\n       This function can typically being used for a set of stimulus being presented for multiple epochs.\n    An example of the dictionnary is :\n\n        &gt;&gt;&gt; dict_ep =  {\n                \"stim0\": nap.IntervalSet(start=0, end=1),\n                \"stim1\":nap.IntervalSet(start=2, end=3)\n            }\n    In this case, the function will return a pandas DataFrame :\n\n        &gt;&gt;&gt; tc\n                   neuron0    neuron1    neuron2\n        stim0        0 Hz       1 Hz       2 Hz\n        stim1        3 Hz       4 Hz       5 Hz\n\n\n    Parameters\n    ----------\n    group : nap.TsGroup\n        The group of Ts/Tsd for which the tuning curves will be computed\n    dict_ep : dict\n        Dictionary of IntervalSets\n\n    Returns\n    -------\n    pandas.DataFrame\n        Table of firing rate for each neuron and each IntervalSet\n\n    Raises\n    ------\n    RuntimeError\n        If group is not a TsGroup object.\n    \"\"\"\n    assert isinstance(group, nap.TsGroup), \"group should be a TsGroup.\"\n    assert isinstance(dict_ep, dict), \"dict_ep should be a dictionnary of IntervalSet\"\n    idx = np.sort(list(dict_ep.keys()))\n    for k in idx:\n        assert isinstance(\n            dict_ep[k], nap.IntervalSet\n        ), \"dict_ep argument should contain only IntervalSet. Key {} in dict_ep is not an IntervalSet\".format(\n            k\n        )\n\n    tuning_curves = pd.DataFrame(index=idx, columns=list(group.keys()), data=0.0)\n\n    for k in dict_ep.keys():\n        for n in group.keys():\n            tuning_curves.loc[k, n] = float(len(group[n].restrict(dict_ep[k])))\n\n        tuning_curves.loc[k] = tuning_curves.loc[k] / dict_ep[k].tot_length(\"s\")\n\n    return tuning_curves\n</code></pre>"},{"location":"reference/process/tuning_curves/#pynapple.process.tuning_curves.compute_1d_tuning_curves","title":"compute_1d_tuning_curves","text":"<pre><code>compute_1d_tuning_curves(\n    group, feature, nb_bins, ep=None, minmax=None\n)\n</code></pre> <p>Computes 1-dimensional tuning curves relative to a 1d feature.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>TsGroup</code> <p>The group of Ts/Tsd for which the tuning curves will be computed</p> required <code>feature</code> <code>Tsd (or TsdFrame with 1 column only)</code> <p>The 1-dimensional target feature (e.g. head-direction)</p> required <code>nb_bins</code> <code>int</code> <p>Number of bins in the tuning curve</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch on which tuning curves are computed. If None, the epoch is the time support of the feature.</p> <code>None</code> <code>minmax</code> <code>tuple or list</code> <p>The min and max boundaries of the tuning curves. If None, the boundaries are inferred from the target feature</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame to hold the tuning curves</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If group is not a TsGroup object.</p> Source code in <code>pynapple/process/tuning_curves.py</code> <pre><code>def compute_1d_tuning_curves(group, feature, nb_bins, ep=None, minmax=None):\n    \"\"\"\n    Computes 1-dimensional tuning curves relative to a 1d feature.\n\n    Parameters\n    ----------\n    group : TsGroup\n        The group of Ts/Tsd for which the tuning curves will be computed\n    feature : Tsd (or TsdFrame with 1 column only)\n        The 1-dimensional target feature (e.g. head-direction)\n    nb_bins : int\n        Number of bins in the tuning curve\n    ep : IntervalSet, optional\n        The epoch on which tuning curves are computed.\n        If None, the epoch is the time support of the feature.\n    minmax : tuple or list, optional\n        The min and max boundaries of the tuning curves.\n        If None, the boundaries are inferred from the target feature\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame to hold the tuning curves\n\n    Raises\n    ------\n    RuntimeError\n        If group is not a TsGroup object.\n\n    \"\"\"\n    assert isinstance(group, nap.TsGroup), \"group should be a TsGroup.\"\n    assert isinstance(\n        feature, (nap.Tsd, nap.TsdFrame)\n    ), \"feature should be a Tsd (or TsdFrame with 1 column only)\"\n    if isinstance(feature, nap.TsdFrame):\n        assert (\n            feature.shape[1] == 1\n        ), \"feature should be a Tsd (or TsdFrame with 1 column only)\"\n    assert isinstance(nb_bins, int)\n\n    if ep is None:\n        ep = feature.time_support\n    else:\n        assert isinstance(ep, nap.IntervalSet), \"ep should be an IntervalSet\"\n\n    if minmax is None:\n        bins = np.linspace(np.min(feature), np.max(feature), nb_bins + 1)\n    else:\n        assert isinstance(minmax, tuple), \"minmax should be a tuple of boundaries\"\n        bins = np.linspace(minmax[0], minmax[1], nb_bins + 1)\n\n    idx = bins[0:-1] + np.diff(bins) / 2\n\n    tuning_curves = pd.DataFrame(index=idx, columns=list(group.keys()))\n\n    if isinstance(ep, nap.IntervalSet):\n        group_value = group.value_from(feature, ep)\n        occupancy, _ = np.histogram(feature.restrict(ep).values, bins)\n    else:\n        group_value = group.value_from(feature)\n        occupancy, _ = np.histogram(feature.values, bins)\n\n    for k in group_value:\n        count, _ = np.histogram(group_value[k].values, bins)\n        count = count / occupancy\n        count[np.isnan(count)] = 0.0\n        tuning_curves[k] = count\n        tuning_curves[k] = count * feature.rate\n\n    return tuning_curves\n</code></pre>"},{"location":"reference/process/tuning_curves/#pynapple.process.tuning_curves.compute_2d_tuning_curves","title":"compute_2d_tuning_curves","text":"<pre><code>compute_2d_tuning_curves(\n    group, features, nb_bins, ep=None, minmax=None\n)\n</code></pre> <p>Computes 2-dimensional tuning curves relative to a 2d features</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>TsGroup</code> <p>The group of Ts/Tsd for which the tuning curves will be computed</p> required <code>features</code> <code>TsdFrame</code> <p>The 2d features (i.e. 2 columns features).</p> required <code>nb_bins</code> <code>int</code> <p>Number of bins in the tuning curves</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch on which tuning curves are computed. If None, the epoch is the time support of the feature.</p> <code>None</code> <code>minmax</code> <code>tuple or list</code> <p>The min and max boundaries of the tuning curves given as: (minx, maxx, miny, maxy) If None, the boundaries are inferred from the target variable</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing: </p> <p>tc (dict): Dictionnary of the tuning curves with dimensions (nb_bins, nb_bins).</p> <p>xy (list): List of bins center in the two dimensions</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If group is not a TsGroup object or if features is not 2 columns only.</p> Source code in <code>pynapple/process/tuning_curves.py</code> <pre><code>def compute_2d_tuning_curves(group, features, nb_bins, ep=None, minmax=None):\n    \"\"\"\n    Computes 2-dimensional tuning curves relative to a 2d features\n\n    Parameters\n    ----------\n    group : TsGroup\n        The group of Ts/Tsd for which the tuning curves will be computed\n    features : TsdFrame\n        The 2d features (i.e. 2 columns features).\n    nb_bins : int\n        Number of bins in the tuning curves\n    ep : IntervalSet, optional\n        The epoch on which tuning curves are computed.\n        If None, the epoch is the time support of the feature.\n    minmax : tuple or list, optional\n        The min and max boundaries of the tuning curves given as:\n        (minx, maxx, miny, maxy)\n        If None, the boundaries are inferred from the target variable\n\n    Returns\n    -------\n    tuple\n        A tuple containing: \\n\n        tc (dict): Dictionnary of the tuning curves with dimensions (nb_bins, nb_bins).\\n\n        xy (list): List of bins center in the two dimensions\n\n    Raises\n    ------\n    RuntimeError\n        If group is not a TsGroup object or if features is not 2 columns only.\n\n    \"\"\"\n    assert isinstance(group, nap.TsGroup), \"group should be a TsGroup.\"\n    assert isinstance(\n        features, nap.TsdFrame\n    ), \"features should be a TsdFrame with 2 columns\"\n    if isinstance(features, nap.TsdFrame):\n        assert features.shape[1] == 2, \"features should have 2 columns only.\"\n    assert isinstance(nb_bins, int)\n\n    if ep is None:\n        ep = features.time_support\n    else:\n        assert isinstance(ep, nap.IntervalSet), \"ep should be an IntervalSet\"\n        features = features.restrict(ep)\n\n    cols = list(features.columns)\n    groups_value = {}\n    binsxy = {}\n\n    for i, c in enumerate(cols):\n        groups_value[c] = group.value_from(features.loc[c], ep)\n        if minmax is None:\n            bins = np.linspace(\n                np.min(features.loc[c]), np.max(features.loc[c]), nb_bins + 1\n            )\n        else:\n            assert isinstance(minmax, tuple), \"minmax should be a tuple of 4 elements\"\n            bins = np.linspace(minmax[i + i % 2], minmax[i + 1 + i % 2], nb_bins + 1)\n        binsxy[c] = bins\n\n    occupancy, _, _ = np.histogram2d(\n        features.loc[cols[0]].values.flatten(),\n        features.loc[cols[1]].values.flatten(),\n        [binsxy[cols[0]], binsxy[cols[1]]],\n    )\n\n    tc = {}\n    for n in group.keys():\n        count, _, _ = np.histogram2d(\n            groups_value[cols[0]][n].values.flatten(),\n            groups_value[cols[1]][n].values.flatten(),\n            [binsxy[cols[0]], binsxy[cols[1]]],\n        )\n        count = count / occupancy\n        # count[np.isnan(count)] = 0.0\n        tc[n] = count * features.rate\n\n    xy = [binsxy[c][0:-1] + np.diff(binsxy[c]) / 2 for c in binsxy.keys()]\n\n    return tc, xy\n</code></pre>"},{"location":"reference/process/tuning_curves/#pynapple.process.tuning_curves.compute_1d_mutual_info","title":"compute_1d_mutual_info","text":"<pre><code>compute_1d_mutual_info(\n    tc, feature, ep=None, minmax=None, bitssec=False\n)\n</code></pre> <p>Mutual information as defined in</p> <p>Skaggs, W. E., McNaughton, B. L., &amp; Gothard, K. M. (1993). An information-theoretic approach to deciphering the hippocampal code. In Advances in neural information processing systems (pp. 1030-1037).</p> <p>Parameters:</p> Name Type Description Default <code>tc</code> <code>DataFrame or ndarray</code> <p>Tuning curves in columns</p> required <code>feature</code> <code>Tsd (or TsdFrame with 1 column only)</code> <p>The 1-dimensional target feature (e.g. head-direction)</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch over which the tuning curves were computed If None, the epoch is the time support of the feature.</p> <code>None</code> <code>minmax</code> <code>tuple or list</code> <p>The min and max boundaries of the tuning curves. If None, the boundaries are inferred from the target feature</p> <code>None</code> <code>bitssec</code> <code>bool</code> <p>By default, the function return bits per spikes. Set to true for bits per seconds</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Spatial Information (default is bits/spikes)</p> Source code in <code>pynapple/process/tuning_curves.py</code> <pre><code>def compute_1d_mutual_info(tc, feature, ep=None, minmax=None, bitssec=False):\n    \"\"\"\n    Mutual information as defined in\n\n    Skaggs, W. E., McNaughton, B. L., &amp; Gothard, K. M. (1993).\n    An information-theoretic approach to deciphering the hippocampal code.\n    In Advances in neural information processing systems (pp. 1030-1037).\n\n    Parameters\n    ----------\n    tc : pandas.DataFrame or numpy.ndarray\n        Tuning curves in columns\n    feature : Tsd (or TsdFrame with 1 column only)\n        The 1-dimensional target feature (e.g. head-direction)\n    ep : IntervalSet, optional\n        The epoch over which the tuning curves were computed\n        If None, the epoch is the time support of the feature.\n    minmax : tuple or list, optional\n        The min and max boundaries of the tuning curves.\n        If None, the boundaries are inferred from the target feature\n    bitssec : bool, optional\n        By default, the function return bits per spikes.\n        Set to true for bits per seconds\n\n    Returns\n    -------\n    pandas.DataFrame\n        Spatial Information (default is bits/spikes)\n    \"\"\"\n    if isinstance(tc, pd.DataFrame):\n        columns = tc.columns.values\n        fx = np.atleast_2d(tc.values)\n    elif isinstance(tc, np.ndarray):\n        fx = np.atleast_2d(tc)\n        columns = np.arange(tc.shape[1])\n\n    assert isinstance(\n        feature, (nap.Tsd, nap.TsdFrame)\n    ), \"feature should be a Tsd (or TsdFrame with 1 column only)\"\n    if isinstance(feature, nap.TsdFrame):\n        assert (\n            feature.shape[1] == 1\n        ), \"feature should be a Tsd (or TsdFrame with 1 column only)\"\n\n    nb_bins = tc.shape[0] + 1\n    if minmax is None:\n        bins = np.linspace(np.min(feature), np.max(feature), nb_bins)\n    else:\n        bins = np.linspace(minmax[0], minmax[1], nb_bins)\n\n    if isinstance(ep, nap.IntervalSet):\n        occupancy, _ = np.histogram(feature.restrict(ep).values, bins)\n    else:\n        occupancy, _ = np.histogram(feature.values, bins)\n    occupancy = occupancy / occupancy.sum()\n    occupancy = occupancy[:, np.newaxis]\n\n    fr = np.sum(fx * occupancy, 0)\n    fxfr = fx / fr\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        logfx = np.log2(fxfr)\n    logfx[np.isinf(logfx)] = 0.0\n    SI = np.sum(occupancy * fx * logfx, 0)\n\n    if bitssec:\n        SI = pd.DataFrame(index=columns, columns=[\"SI\"], data=SI)\n        return SI\n    else:\n        SI = SI / fr\n        SI = pd.DataFrame(index=columns, columns=[\"SI\"], data=SI)\n        return SI\n</code></pre>"},{"location":"reference/process/tuning_curves/#pynapple.process.tuning_curves.compute_2d_mutual_info","title":"compute_2d_mutual_info","text":"<pre><code>compute_2d_mutual_info(\n    tc, features, ep=None, minmax=None, bitssec=False\n)\n</code></pre> <p>Mutual information as defined in</p> <p>Skaggs, W. E., McNaughton, B. L., &amp; Gothard, K. M. (1993). An information-theoretic approach to deciphering the hippocampal code. In Advances in neural information processing systems (pp. 1030-1037).</p> <p>Parameters:</p> Name Type Description Default <code>tc</code> <code>dict or ndarray</code> <p>If array, first dimension should be the neuron</p> required <code>features</code> <code>TsdFrame</code> <p>The 2 columns features that were used to compute the tuning curves</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch over which the tuning curves were computed If None, the epoch is the time support of the feature.</p> <code>None</code> <code>minmax</code> <code>tuple or list</code> <p>The min and max boundaries of the tuning curves. If None, the boundaries are inferred from the target features</p> <code>None</code> <code>bitssec</code> <code>bool</code> <p>By default, the function return bits per spikes. Set to true for bits per seconds</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Spatial Information (default is bits/spikes)</p> Source code in <code>pynapple/process/tuning_curves.py</code> <pre><code>def compute_2d_mutual_info(tc, features, ep=None, minmax=None, bitssec=False):\n    \"\"\"\n    Mutual information as defined in\n\n    Skaggs, W. E., McNaughton, B. L., &amp; Gothard, K. M. (1993).\n    An information-theoretic approach to deciphering the hippocampal code.\n    In Advances in neural information processing systems (pp. 1030-1037).\n\n    Parameters\n    ----------\n    tc : dict or numpy.ndarray\n        If array, first dimension should be the neuron\n    features : TsdFrame\n        The 2 columns features that were used to compute the tuning curves\n    ep : IntervalSet, optional\n        The epoch over which the tuning curves were computed\n        If None, the epoch is the time support of the feature.\n    minmax : tuple or list, optional\n        The min and max boundaries of the tuning curves.\n        If None, the boundaries are inferred from the target features\n    bitssec : bool, optional\n        By default, the function return bits per spikes.\n        Set to true for bits per seconds\n\n    Returns\n    -------\n    pandas.DataFrame\n        Spatial Information (default is bits/spikes)\n    \"\"\"\n    # A bit tedious here\n    if type(tc) is dict:\n        fx = np.array([tc[i] for i in tc.keys()])\n        idx = list(tc.keys())\n    elif type(tc) is np.ndarray:\n        fx = tc\n        idx = np.arange(len(tc))\n\n    assert isinstance(\n        features, nap.TsdFrame\n    ), \"features should be a TsdFrame with 2 columns\"\n    if isinstance(features, nap.TsdFrame):\n        assert features.shape[1] == 2, \"features should have 2 columns only.\"\n\n    nb_bins = (fx.shape[1] + 1, fx.shape[2] + 1)\n\n    cols = features.columns\n\n    bins = []\n    for i, c in enumerate(cols):\n        if minmax is None:\n            bins.append(\n                np.linspace(\n                    np.min(features.loc[c]), np.max(features.loc[c]), nb_bins[i]\n                )\n            )\n        else:\n            bins.append(\n                np.linspace(minmax[i + i % 2], minmax[i + 1 + i % 2], nb_bins[i])\n            )\n\n    if isinstance(ep, nap.IntervalSet):\n        features = features.restrict(ep)\n\n    occupancy, _, _ = np.histogram2d(\n        features.loc[cols[0]].values.flatten(),\n        features.loc[cols[1]].values.flatten(),\n        [bins[0], bins[1]],\n    )\n    occupancy = occupancy / occupancy.sum()\n\n    fr = np.nansum(fx * occupancy, (1, 2))\n    fr = fr[:, np.newaxis, np.newaxis]\n    fxfr = fx / fr\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        logfx = np.log2(fxfr)\n    logfx[np.isinf(logfx)] = 0.0\n    SI = np.nansum(occupancy * fx * logfx, (1, 2))\n\n    if bitssec:\n        SI = pd.DataFrame(index=idx, columns=[\"SI\"], data=SI)\n        return SI\n    else:\n        SI = SI / fr[:, 0, 0]\n        SI = pd.DataFrame(index=idx, columns=[\"SI\"], data=SI)\n        return SI\n</code></pre>"},{"location":"reference/process/tuning_curves/#pynapple.process.tuning_curves.compute_1d_tuning_curves_continuous","title":"compute_1d_tuning_curves_continuous","text":"<pre><code>compute_1d_tuning_curves_continuous(\n    tsdframe, feature, nb_bins, ep=None, minmax=None\n)\n</code></pre> <p>Computes 1-dimensional tuning curves relative to a feature with continous data.</p> <p>Parameters:</p> Name Type Description Default <code>tsdframe</code> <code>Tsd or TsdFrame</code> <p>Input data (e.g. continus calcium data where each column is the calcium activity of one neuron)</p> required <code>feature</code> <code>Tsd (or TsdFrame with 1 column only)</code> <p>The 1-dimensional target feature (e.g. head-direction)</p> required <code>nb_bins</code> <code>int</code> <p>Number of bins in the tuning curves</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch on which tuning curves are computed. If None, the epoch is the time support of the feature.</p> <code>None</code> <code>minmax</code> <code>tuple or list</code> <p>The min and max boundaries of the tuning curves. If None, the boundaries are inferred from the target feature</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame to hold the tuning curves</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If tsdframe is not a Tsd or a TsdFrame object.</p> Source code in <code>pynapple/process/tuning_curves.py</code> <pre><code>def compute_1d_tuning_curves_continuous(\n    tsdframe, feature, nb_bins, ep=None, minmax=None\n):\n    \"\"\"\n    Computes 1-dimensional tuning curves relative to a feature with continous data.\n\n    Parameters\n    ----------\n    tsdframe : Tsd or TsdFrame\n        Input data (e.g. continus calcium data\n        where each column is the calcium activity of one neuron)\n    feature : Tsd (or TsdFrame with 1 column only)\n        The 1-dimensional target feature (e.g. head-direction)\n    nb_bins : int\n        Number of bins in the tuning curves\n    ep : IntervalSet, optional\n        The epoch on which tuning curves are computed.\n        If None, the epoch is the time support of the feature.\n    minmax : tuple or list, optional\n        The min and max boundaries of the tuning curves.\n        If None, the boundaries are inferred from the target feature\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame to hold the tuning curves\n\n    Raises\n    ------\n    RuntimeError\n        If tsdframe is not a Tsd or a TsdFrame object.\n\n    \"\"\"\n    if not isinstance(tsdframe, (nap.Tsd, nap.TsdFrame)):\n        raise RuntimeError(\"Unknown format for tsdframe.\")\n\n    assert isinstance(\n        feature, (nap.Tsd, nap.TsdFrame)\n    ), \"feature should be a Tsd (or TsdFrame with 1 column only)\"\n    if isinstance(feature, nap.TsdFrame):\n        assert (\n            feature.shape[1] == 1\n        ), \"feature should be a Tsd (or TsdFrame with 1 column only)\"\n        feature = np.squeeze(feature)\n\n    if isinstance(ep, nap.IntervalSet):\n        feature = feature.restrict(ep)\n        tsdframe = tsdframe.restrict(ep)\n    else:\n        tsdframe = tsdframe.restrict(feature.time_support)\n\n    if minmax is None:\n        bins = np.linspace(np.min(feature), np.max(feature), nb_bins + 1)\n    else:\n        bins = np.linspace(minmax[0], minmax[1], nb_bins + 1)\n\n    align_times = tsdframe.value_from(feature)\n    idx = np.digitize(align_times.values, bins) - 1\n    tmp = tsdframe.as_dataframe().groupby(idx).mean()\n    tmp = tmp.reindex(np.arange(0, len(bins) - 1))\n    tmp.index = pd.Index(bins[0:-1] + np.diff(bins) / 2)\n\n    tmp = tmp.fillna(0)\n\n    return pd.DataFrame(tmp)\n</code></pre>"},{"location":"reference/process/tuning_curves/#pynapple.process.tuning_curves.compute_2d_tuning_curves_continuous","title":"compute_2d_tuning_curves_continuous","text":"<pre><code>compute_2d_tuning_curves_continuous(\n    tsdframe, features, nb_bins, ep=None, minmax=None\n)\n</code></pre> <p>Computes 2-dimensional tuning curves relative to a 2d feature with continous data.</p> <p>Parameters:</p> Name Type Description Default <code>tsdframe</code> <code>Tsd or TsdFrame</code> <p>Input data (e.g. continuous calcium data where each column is the calcium activity of one neuron)</p> required <code>features</code> <code>TsdFrame</code> <p>The 2d feature (two columns)</p> required <code>nb_bins</code> <code>int or tuple</code> <p>Number of bins in the tuning curves (separate for 2 feature dimensions if tuple provided)</p> required <code>ep</code> <code>IntervalSet</code> <p>The epoch on which tuning curves are computed. If None, the epoch is the time support of the feature.</p> <code>None</code> <code>minmax</code> <code>tuple or list</code> <p>The min and max boundaries of the tuning curves. Should be a tuple of minx, maxx, miny, maxy If None, the boundaries are inferred from the target feature</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing: </p> <p>tc (dict): Dictionnary of the tuning curves with dimensions (nb_bins, nb_bins).</p> <p>xy (list): List of bins center in the two dimensions</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If tsdframe is not a Tsd/TsdFrame or if features is not 2 columns</p> Source code in <code>pynapple/process/tuning_curves.py</code> <pre><code>def compute_2d_tuning_curves_continuous(\n    tsdframe, features, nb_bins, ep=None, minmax=None\n):\n    \"\"\"\n    Computes 2-dimensional tuning curves relative to a 2d feature with continous data.\n\n    Parameters\n    ----------\n    tsdframe : Tsd or TsdFrame\n        Input data (e.g. continuous calcium data\n        where each column is the calcium activity of one neuron)\n    features : TsdFrame\n        The 2d feature (two columns)\n    nb_bins : int or tuple\n        Number of bins in the tuning curves (separate for 2 feature dimensions if tuple provided)\n    ep : IntervalSet, optional\n        The epoch on which tuning curves are computed.\n        If None, the epoch is the time support of the feature.\n    minmax : tuple or list, optional\n        The min and max boundaries of the tuning curves.\n        Should be a tuple of minx, maxx, miny, maxy\n        If None, the boundaries are inferred from the target feature\n\n    Returns\n    -------\n    tuple\n        A tuple containing: \\n\n        tc (dict): Dictionnary of the tuning curves with dimensions (nb_bins, nb_bins).\\n\n        xy (list): List of bins center in the two dimensions\n\n    Raises\n    ------\n    RuntimeError\n        If tsdframe is not a Tsd/TsdFrame or if features is not 2 columns\n\n    \"\"\"\n    if not isinstance(tsdframe, (nap.Tsd, nap.TsdFrame)):\n        raise RuntimeError(\"Unknown format for tsdframe.\")\n\n    assert isinstance(\n        features, nap.TsdFrame\n    ), \"features should be a TsdFrame with 2 columns\"\n    if isinstance(features, nap.TsdFrame):\n        assert features.shape[1] == 2, \"features should have 2 columns only.\"\n\n    if isinstance(ep, nap.IntervalSet):\n        features = features.restrict(ep)\n        tsdframe = tsdframe.restrict(ep)\n    else:\n        tsdframe = tsdframe.restrict(features.time_support)\n\n    if isinstance(nb_bins, int):\n        nb_bins = (nb_bins, nb_bins)\n    elif len(nb_bins) != 2:\n        raise RuntimeError(\"nb_bins should be int or tuple of 2 ints\")\n\n    cols = list(features.columns)\n\n    binsxy = {}\n    idxs = {}\n\n    for i, c in enumerate(cols):\n        if minmax is None:\n            bins = np.linspace(\n                np.min(features.loc[c]), np.max(features.loc[c]), nb_bins[i] + 1\n            )\n        else:\n            bins = np.linspace(minmax[i + i % 2], minmax[i + 1 + i % 2], nb_bins[i] + 1)\n\n        align_times = tsdframe.value_from(features.loc[c], ep)\n        idxs[c] = np.digitize(align_times.values.flatten(), bins) - 1\n        binsxy[c] = bins\n\n    idxs = pd.DataFrame(idxs)\n\n    tc_np = np.zeros((tsdframe.shape[1], nb_bins[0], nb_bins[1])) * np.nan\n\n    for k, tmp in idxs.groupby(cols):\n        if (0 &lt;= k[0] &lt; nb_bins[0]) and (0 &lt;= k[1] &lt; nb_bins[1]):\n            tc_np[:, k[0], k[1]] = np.mean(tsdframe[tmp.index].values, 0)\n\n    tc_np[np.isnan(tc_np)] = 0.0\n\n    xy = [binsxy[c][0:-1] + np.diff(binsxy[c]) / 2 for c in binsxy.keys()]\n\n    tc = {c: tc_np[i] for i, c in enumerate(tsdframe.columns)}\n\n    return tc, xy\n</code></pre>"}]}